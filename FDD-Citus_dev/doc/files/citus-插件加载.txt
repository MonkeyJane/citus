[BEGIN] 2019/4/2 ÐÇÆÚ¶þ ÏÂÎç 3:22:48
Xshell 5 (Build 1326)
Copyright (c) 2002-2017 NetSarang Computer, Inc. All rights reserved.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Sun Mar 31 23:21:21 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ gdb attach 3962
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 3962
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007fb97e925163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) b SocketBackend
Breakpoint 1 at 0x812d99: file postgres.c, line 326.
(gdb) bt
#0  0x00007fb97e925163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
#1  0x00000000007ed015 in WaitEventSetWaitBlock (set=0x1a137c8, cur_timeout=-1, occurred_events=0x7ffe6fb7f2e0, nevents=1) at latch.c:1048
#2  0x00000000007ecef0 in WaitEventSetWait (set=0x1a137c8, timeout=-1, occurred_events=0x7ffe6fb7f2e0, nevents=1, wait_event_info=100663296) at latch.c:1000
#3  0x00000000006beacc in secure_read (port=0x1a56840, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:166
#4  0x00000000006cad3b in pq_recvbuf () at pqcomm.c:963
#5  0x00000000006cadd5 in pq_getbyte () at pqcomm.c:1006
#6  0x0000000000812db2 in SocketBackend (inBuf=0x7ffe6fb7f4f0) at postgres.c:328
#7  0x0000000000813281 in ReadCommand (inBuf=0x7ffe6fb7f4f0) at postgres.c:501
#8  0x0000000000817a41 in PostgresMain (argc=1, argv=0x1a5c1c8, dbname=0x1a5c078 "postgres", username=0x1a13d08 "cituscluster") at postgres.c:4030
#9  0x000000000078b2d2 in BackendRun (port=0x1a56840) at postmaster.c:4357
#10 0x000000000078aa7b in BackendStartup (port=0x1a56840) at postmaster.c:4029
#11 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#12 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x1a11be0) at postmaster.c:1361
#13 0x00000000006cf26f in main (argc=1, argv=0x1a11be0) at main.c:228
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) 
WaitEventSetWaitBlock (set=0x1a137c8, cur_timeout=-1, occurred_events=0x7ffe6fb7f2e0, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x1a137c8, timeout=-1, occurred_events=0x7ffe6fb7f2e0, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
1000			rc = WaitEventSetWaitBlock(set, cur_timeout,
(gdb) bt
#0  WaitEventSetWait (set=0x1a137c8, timeout=-1, occurred_events=0x7ffe6fb7f2e0, nevents=1, wait_event_info=100663296) at latch.c:1000
#1  0x00000000006beacc in secure_read (port=0x1a56840, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:166
#2  0x00000000006cad3b in pq_recvbuf () at pqcomm.c:963
#3  0x00000000006cadd5 in pq_getbyte () at pqcomm.c:1006
#4  0x0000000000812db2 in SocketBackend (inBuf=0x7ffe6fb7f4f0) at postgres.c:328
#5  0x0000000000813281 in ReadCommand (inBuf=0x7ffe6fb7f4f0) at postgres.c:501
#6  0x0000000000817a41 in PostgresMain (argc=1, argv=0x1a5c1c8, dbname=0x1a5c078 "postgres", username=0x1a13d08 "cituscluster") at postgres.c:4030
#7  0x000000000078b2d2 in BackendRun (port=0x1a56840) at postmaster.c:4357
#8  0x000000000078aa7b in BackendStartup (port=0x1a56840) at postmaster.c:4029
#9  0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#10 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x1a11be0) at postmaster.c:1361
#11 0x00000000006cf26f in main (argc=1, argv=0x1a11be0) at main.c:228
(gdb) n
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x1a56840, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) q
A debugging session is active.

	Inferior 1 [process 3962] will be detached.

Quit anyway? (y or n) u^Hy
Please answer y or n.
A debugging session is active.

	Inferior 1 [process 3962] will be detached.

Quit anyway? (y or n) y
Detaching from program: /opt/pgsql-10.1/bin/postgres, process 3962
[cituscluster@gtm1 ~]$ 
Socket error Event: 32 Error: 10053.
Connection closing...Socket close.

Connection closed by foreign host.

Disconnected from remote host(citus-cn1) at 18:51:55.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Mon Apr  1 00:08:32 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ 

Connection closed.

Disconnected from remote host(citus-cn1) at 14:52:23.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ pg_ctl stop
'pg_ctl' ?????????,?????????
???????

[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Mon Apr  1 23:52:16 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ 

Connection closed.

Disconnected from remote host(citus-cn1) at 15:18:34.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ cd ~
[c:\~]$ pg_ctl start
'pg_ctl' ?????????,?????????
???????

[c:\~]$ psq-d postgres
'psq-d' ?????????,?????????
???????

[c:\~]$ drop table test1;
'drop' ?????????,?????????
???????

[c:\~]$ drop extension citus;
'drop' ?????????,?????????
???????

[c:\~]$ \q
'\q' ?????????,?????????
???????

[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Tue Apr  2 00:17:22 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ gdb attach 8723
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 8723
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007fbb843d3163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) b CreateExtension
Breakpoint 1 at 0x601881: file extension.c, line 1623.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) n
WaitEventSetWaitBlock (set=0x249f7c8, cur_timeout=-1, occurred_events=0x7ffc17b007c0, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x249f7c8, timeout=-1, occurred_events=0x7ffc17b007c0, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) bt
#0  WaitEventSetWait (set=0x249f7c8, timeout=-1, occurred_events=0x7ffc17b007c0, nevents=1, wait_event_info=100663296) at latch.c:1006
#1  0x00000000006beacc in secure_read (port=0x24e29d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:166
#2  0x00000000006cad3b in pq_recvbuf () at pqcomm.c:963
#3  0x00000000006cadd5 in pq_getbyte () at pqcomm.c:1006
#4  0x0000000000812db2 in SocketBackend (inBuf=0x7ffc17b009d0) at postgres.c:328
#5  0x0000000000813281 in ReadCommand (inBuf=0x7ffc17b009d0) at postgres.c:501
#6  0x0000000000817a41 in PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4030
#7  0x000000000078b2d2 in BackendRun (port=0x24e29d0) at postmaster.c:4357
#8  0x000000000078aa7b in BackendStartup (port=0x24e29d0) at postmaster.c:4029
#9  0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#10 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x249dbe0) at postmaster.c:1361
#11 0x00000000006cf26f in main (argc=1, argv=0x249dbe0) at main.c:228
(gdb) n
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
1000			rc = WaitEventSetWaitBlock(set, cur_timeout,
(gdb) 
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x24e29d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffc17b009d0) at postgres.c:330

330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 

359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffc17b009d0) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) bt
#0  PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4079
#1  0x000000000078b2d2 in BackendRun (port=0x24e29d0) at postmaster.c:4357
#2  0x000000000078aa7b in BackendStartup (port=0x24e29d0) at postmaster.c:4029
#3  0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#4  0x0000000000786a6d in PostmasterMain (argc=1, argv=0x249dbe0) at postmaster.c:1361
#5  0x00000000006cf26f in main (argc=1, argv=0x249dbe0) at main.c:228
(gdb) n
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 1, CreateExtension (pstate=0x2599fc8, stmt=0x254d518) at extension.c:1623

1623		DefElem    *d_schema = NULL;
(gdb) 
1624		DefElem    *d_new_version = NULL;
(gdb) 
1625		DefElem    *d_old_version = NULL;
(gdb) 
1626		DefElem    *d_cascade = NULL;
(gdb) 
1627		char	   *schemaName = NULL;
(gdb) 
1628		char	   *versionName = NULL;
(gdb) 
1629		char	   *oldVersionName = NULL;
(gdb) 
1630		bool		cascade = false;
(gdb) 
1634		check_valid_extension_name(stmt->extname);
(gdb) 
1642		if (get_extension_oid(stmt->extname, true) != InvalidOid)
(gdb) 
1663		if (creating_extension)
(gdb) p creating_extension
$1 = 0 '\000'
(gdb) n
1669		foreach(lc, stmt->options)
(gdb) 
1718		return CreateExtensionInternal(stmt->extname,
(gdb) s
CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x0, versionName=0x0, oldVersionName=0x0, cascade=0 '\000', parents=0x0, is_create=1 '\001') at extension.c:1275
1275		char	   *origSchemaName = schemaName;
(gdb) n
1276		Oid			schemaOid = InvalidOid;
(gdb) 
1277		Oid			extowner = GetUserId();
(gdb) 
1292		pcontrol = read_extension_control_file(extensionName);
(gdb) 
1297		if (versionName == NULL)
(gdb) p pcontrol 
$2 = (ExtensionControlFile *) 0x24e4b18
(gdb) p* pcontrol 
$3 = {name = 0x24e5060 "citus", directory = 0x0, default_version = 0x25d0010 "8.2-2", module_pathname = 0x25d0028 "$libdir/citus", comment = 0x25cffe0 "Citus distributed database", 
  schema = 0x25d0048 "pg_catalog", relocatable = 0 '\000', superuser = 1 '\001', encoding = -1, requires = 0x0}
(gdb) bt
#0  CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x0, versionName=0x0, oldVersionName=0x0, cascade=0 '\000', parents=0x0, is_create=1 '\001') at extension.c:1297
#1  0x0000000000601d4e in CreateExtension (pstate=0x2599fc8, stmt=0x254d518) at extension.c:1718
#2  0x000000000081c66d in ProcessUtilitySlow (pstate=0x2599fc8, pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, 
    dest=0x254d918, completionTag=0x7ffc17b007c0 "") at utility.c:1349
#3  0x000000000081bb2c in standard_ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, 
    dest=0x254d918, completionTag=0x7ffc17b007c0 "") at utility.c:928
#4  0x00007fbb7daeaab8 in multi_ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x254d918, 
    completionTag=0x7ffc17b007c0 "") at commands/utility_hook.c:136
#5  0x000000000081ac94 in ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x254d918, 
    completionTag=0x7ffc17b007c0 "") at utility.c:353
#6  0x0000000000819ed1 in PortalRunUtility (portal=0x2597068, pstmt=0x254d838, isTopLevel=1 '\001', setHoldSnapshot=0 '\000', dest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:1178
#7  0x000000000081a0b2 in PortalRunMulti (portal=0x2597068, isTopLevel=1 '\001', setHoldSnapshot=0 '\000', dest=0x254d918, altdest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:1324
#8  0x000000000081968a in PortalRun (portal=0x2597068, count=9223372036854775807, isTopLevel=1 '\001', run_once=1 '\001', dest=0x254d918, altdest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:799
#9  0x0000000000813b59 in exec_simple_query (query_string=0x254caf8 "create extension citus;") at postgres.c:1099
#10 0x0000000000817b1f in PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4088
#11 0x000000000078b2d2 in BackendRun (port=0x24e29d0) at postmaster.c:4357
#12 0x000000000078aa7b in BackendStartup (port=0x24e29d0) at postmaster.c:4029
#13 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#14 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x249dbe0) at postmaster.c:1361
#15 0x00000000006cf26f in main (argc=1, argv=0x249dbe0) at main.c:228
(gdb) 
(gdb) n
1299			if (pcontrol->default_version)
(gdb) 
1300				versionName = pcontrol->default_version;
(gdb) 
1306		check_valid_version_name(versionName);
(gdb) 
1314		if (oldVersionName)
(gdb) p oldVersionName 
$4 = 0x0
(gdb) n
1362			oldVersionName = NULL;
(gdb) 
1364			filename = get_extension_script_filename(pcontrol, NULL, versionName);
(gdb) 
1365			if (stat(filename, &fst) == 0)
(gdb) p filename 
$5 = 0x25d0068 "/opt/pgsql-10.1/share/extension/citus--8.2-2.sql"
(gdb) n
1378				evi_list = get_ext_ver_list(pcontrol);
(gdb) 
1381				evi_target = get_ext_ver_info(versionName, &evi_list);
(gdb) 
1384				evi_start = find_install_path(evi_list, evi_target,
(gdb) 
1388				if (evi_start == NULL)
(gdb) p evi_target 
$6 = (ExtensionVersionInfo *) 0x25dca88
(gdb) p* evi_target 
$7 = {name = 0x25dcab8 "8.2-2", reachable = 0x0, installable = 0 '\000', distance_known = 1 '\001', distance = 104, previous = 0x25dacc8}
(gdb) p* evi_start 
$8 = {name = 0x25daaa8 "5.0", reachable = 0x25dbf18, installable = 1 '\001', distance_known = 1 '\001', distance = 0, previous = 0x0}
(gdb) n
1395				versionName = evi_start->name;
(gdb) 
1402		control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$9 = 0x25daaa8 "5.0"
(gdb) n
1407		if (schemaName)
(gdb) p control
$10 = (ExtensionControlFile *) 0x24e4e80
(gdb) p *control
$11 = {name = 0x24e5060 "citus", directory = 0x0, default_version = 0x25d0010 "8.2-2", module_pathname = 0x25d0028 "$libdir/citus", comment = 0x25cffe0 "Citus distributed database", 
  schema = 0x25d0048 "pg_catalog", relocatable = 0 '\000', superuser = 1 '\001', encoding = -1, requires = 0x0}
(gdb) p schemaName 
$12 = 0x0
(gdb) n
1413		if (control->schema != NULL)
(gdb) 
1422			if (schemaName && strcmp(control->schema, schemaName) != 0 &&
(gdb) 
1431			schemaName = control->schema;
(gdb) 
1434			schemaOid = get_namespace_oid(schemaName, true);
(gdb) p schemaName 
$13 = 0x25d0048 "pg_catalog"
(gdb) n
1436			if (!OidIsValid(schemaOid))
(gdb) p schemaOid 
$14 = 11
(gdb) n
1490		requiredExtensions = NIL;
(gdb) 
1491		requiredSchemas = NIL;
(gdb) 
1492		foreach(lc, control->requires)
(gdb) 
1513									   schemaOid, control->relocatable,
(gdb) list
1508	
1509		/*
1510		 * Insert new tuple into pg_extension, and create dependency entries.
1511		 */
1512		address = InsertExtensionTuple(control->name, extowner,
1513									   schemaOid, control->relocatable,
1514									   versionName,
1515									   PointerGetDatum(NULL),
1516									   PointerGetDatum(NULL),
1517									   requiredExtensions);
(gdb) s
1512		address = InsertExtensionTuple(control->name, extowner,
(gdb) s
InsertExtensionTuple (extName=0x24e5060 "citus", extOwner=16814, schemaOid=11, relocatable=0 '\000', extVersion=0x25daaa8 "5.0", extConfig=0, extCondition=0, requiredExtensions=0x0)
    at extension.c:1758
1758		rel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) n
1760		memset(values, 0, sizeof(values));
(gdb) 
1761		memset(nulls, 0, sizeof(nulls));
(gdb) 
1764			DirectFunctionCall1(namein, CStringGetDatum(extName));
(gdb) s
DirectFunctionCall1Coll (func=0x8b07c7 <namein>, collation=0, arg1=38686816) at fmgr.c:712
712		InitFunctionCallInfoData(fcinfo, NULL, 1, collation, NULL, NULL);
(gdb) n
714		fcinfo.arg[0] = arg1;
(gdb) 
715		fcinfo.argnull[0] = false;
(gdb) 
717		result = (*func) (&fcinfo);
(gdb) 
720		if (fcinfo.isnull)
(gdb) 
723		return result;
(gdb) p result
$15 = 39649168
(gdb) n
724	}
(gdb) 
InsertExtensionTuple (extName=0x24e5060 "citus", extOwner=16814, schemaOid=11, relocatable=0 '\000', extVersion=0x25daaa8 "5.0", extConfig=0, extCondition=0, requiredExtensions=0x0)
    at extension.c:1763
1763		values[Anum_pg_extension_extname - 1] =
(gdb) 
1765		values[Anum_pg_extension_extowner - 1] = ObjectIdGetDatum(extOwner);
(gdb) 
1766		values[Anum_pg_extension_extnamespace - 1] = ObjectIdGetDatum(schemaOid);
(gdb) 
1767		values[Anum_pg_extension_extrelocatable - 1] = BoolGetDatum(relocatable);
(gdb) 
1768		values[Anum_pg_extension_extversion - 1] = CStringGetTextDatum(extVersion);
(gdb) 
1770		if (extConfig == PointerGetDatum(NULL))
(gdb) 
1771			nulls[Anum_pg_extension_extconfig - 1] = true;
(gdb) 
1775		if (extCondition == PointerGetDatum(NULL))
(gdb) 
1776			nulls[Anum_pg_extension_extcondition - 1] = true;
(gdb) 
1780		tuple = heap_form_tuple(rel->rd_att, values, nulls);
(gdb) 
1782		extensionOid = CatalogTupleInsert(rel, tuple);
(gdb) 
1784		heap_freetuple(tuple);
(gdb) p rel
$16 = (Relation) 0x7fbb851c5a38
(gdb) p *rel
$17 = {rd_node = {spcNode = 1663, dbNode = 13212, relNode = 3079}, rd_smgr = 0x2567018, rd_refcnt = 1, rd_backend = -1, rd_islocaltemp = 0 '\000', rd_isnailed = 0 '\000', 
  rd_isvalid = 1 '\001', rd_indexvalid = 1 '\001', rd_statvalid = 0 '\000', rd_createSubid = 0, rd_newRelfilenodeSubid = 0, rd_rel = 0x7fbb851c5c48, rd_att = 0x7fbb851c5d58, rd_id = 3079, 
  rd_lockInfo = {lockRelId = {relId = 3079, dbId = 13212}}, rd_rules = 0x0, rd_rulescxt = 0x0, trigdesc = 0x0, rd_rsdesc = 0x0, rd_fkeylist = 0x0, rd_fkeyvalid = 0 '\000', 
  rd_partkeycxt = 0x0, rd_partkey = 0x0, rd_pdcxt = 0x0, rd_partdesc = 0x0, rd_partcheck = 0x0, rd_indexlist = 0x7fbb851c7880, rd_oidindex = 3080, rd_pkindex = 0, rd_replidindex = 0, 
  rd_statlist = 0x0, rd_indexattr = 0x0, rd_keyattr = 0x0, rd_pkattr = 0x0, rd_idattr = 0x0, rd_pubactions = 0x0, rd_options = 0x0, rd_index = 0x0, rd_indextuple = 0x0, rd_amhandler = 0, 
  rd_indexcxt = 0x0, rd_amroutine = 0x0, rd_opfamily = 0x0, rd_opcintype = 0x0, rd_support = 0x0, rd_supportinfo = 0x0, rd_indoption = 0x0, rd_indexprs = 0x0, rd_indpred = 0x0, 
  rd_exclops = 0x0, rd_exclprocs = 0x0, rd_exclstrats = 0x0, rd_amcache = 0x0, rd_indcollation = 0x0, rd_fdwroutine = 0x0, rd_toastoid = 0, pgstat_info = 0x2549db8}
(gdb) n
1785		heap_close(rel, RowExclusiveLock);
(gdb) 
1790		recordDependencyOnOwner(ExtensionRelationId, extensionOid, extOwner);
(gdb) p ExtensionRelationId
No symbol "ExtensionRelationId" in current context.
(gdb) p extensionOid
$18 = 100956
(gdb) p extOwner
$19 = 16814
(gdb) n
1792		myself.classId = ExtensionRelationId;
(gdb) 
1793		myself.objectId = extensionOid;
(gdb) n
1794		myself.objectSubId = 0;
(gdb) 
1796		nsp.classId = NamespaceRelationId;
(gdb) p myself 
$20 = {classId = 3079, objectId = 100956, objectSubId = 0}
(gdb) n
1797		nsp.objectId = schemaOid;
(gdb) 
1798		nsp.objectSubId = 0;
(gdb) 
1800		recordDependencyOn(&myself, &nsp, DEPENDENCY_NORMAL);
(gdb) p nsp
$21 = {classId = 2615, objectId = 11, objectSubId = 0}
(gdb) n
1802		foreach(lc, requiredExtensions)
(gdb) 
1814		InvokeObjectPostCreateHook(ExtensionRelationId, extensionOid, 0);
(gdb) s
1816		return myself;
(gdb) n
1817	}
(gdb) 
CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x25d0048 "pg_catalog", versionName=0x25daaa8 "5.0", oldVersionName=0x0, cascade=0 '\000', parents=0x0, 
    is_create=1 '\001') at extension.c:1518
1518		extensionOid = address.objectId;
(gdb) 
1523		if (control->comment != NULL)
(gdb) 
1524			CreateComments(extensionOid, ExtensionRelationId, 0, control->comment);
(gdb) p control->comment
$22 = 0x25cffe0 "Citus distributed database"
(gdb) n
1529		execute_extension_script(extensionOid, control,
(gdb) s
execute_extension_script (extensionOid=100956, control=0x24e4e80, from_version=0x0, version=0x25daaa8 "5.0", requiredSchemas=0x0, schemaName=0x25d0048 "pg_catalog", schemaOid=11)
    at extension.c:802
802		if (control->superuser && !superuser())
(gdb) p control
$23 = (ExtensionControlFile *) 0x24e4e80
(gdb) p *control
$24 = {name = 0x24e5060 "citus", directory = 0x0, default_version = 0x25d0010 "8.2-2", module_pathname = 0x25d0028 "$libdir/citus", comment = 0x25cffe0 "Citus distributed database", 
  schema = 0x25d0048 "pg_catalog", relocatable = 0 '\000', superuser = 1 '\001', encoding = -1, requires = 0x0}
(gdb) n
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) p filename
$25 = 0x25df058 "/opt/pgsql-10.1/share/extension/citus--5.0.sql"
(gdb) n
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) p pathbuf
$26 = {data = 0x25df468 "pg_catalog", len = 10, maxlen = 1024, cursor = 0}
(gdb) p requiredSchemas
$27 = (List *) 0x0
(gdb) n
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) list
869		 */
870		creating_extension = true;
871		CurrentExtensionObject = extensionOid;
872		PG_TRY();
873		{
874			char	   *c_sql = read_extension_script_file(control, filename);
875			Datum		t_sql;
876	
877			/* We use various functions that want to operate on text datums */
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) s
read_extension_script_file (control=0x24e4e80, filename=0x25df058 "/opt/pgsql-10.1/share/extension/citus--5.0.sql") at extension.c:662
662		src_str = read_whole_file(filename, &len);
(gdb) n
665		if (control->encoding < 0)
(gdb) p src_str
$28 = 0x25dfee8 "/* citus.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION citus\" to load this file. \\quit\n\nCREATE SCHEMA citus;\n\n-- Ensure CREATE EXTENSIO"...
(gdb) n
666			src_encoding = GetDatabaseEncoding();
(gdb) 
671		pg_verify_mbstr_len(src_encoding, src_str, len, false);
(gdb) p len
$29 = 14934
(gdb) n
678		dest_str = pg_any_to_server(src_str, len, src_encoding);
(gdb) 
680		return dest_str;
(gdb) p dest_str
$30 = 0x25dfee8 "/* citus.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION citus\" to load this file. \\quit\n\nCREATE SCHEMA citus;\n\n-- Ensure CREATE EXTENSIO"...
(gdb) n
681	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x24e4e80, from_version=0x0, version=0x25daaa8 "5.0", requiredSchemas=0x0, schemaName=0x25d0048 "pg_catalog", schemaOid=11)
    at extension.c:878
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) p t_sql
$31 = 39729544
(gdb) s
889											CStringGetTextDatum(""),
(gdb) n
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) s
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) n
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) s
DirectFunctionCall4Coll (func=0x8e1630 <textregexreplace>, collation=950, arg1=39729544, arg2=39714328, arg3=39658384, arg4=39658264) at fmgr.c:780
780		InitFunctionCallInfoData(fcinfo, NULL, 4, collation, NULL, NULL);
(gdb) n
782		fcinfo.arg[0] = arg1;
(gdb) 
783		fcinfo.arg[1] = arg2;
(gdb) 
784		fcinfo.arg[2] = arg3;
(gdb) 
785		fcinfo.arg[3] = arg4;
(gdb) 
786		fcinfo.argnull[0] = false;
(gdb) 
787		fcinfo.argnull[1] = false;
(gdb) 
788		fcinfo.argnull[2] = false;
(gdb) 
789		fcinfo.argnull[3] = false;
(gdb) 
791		result = (*func) (&fcinfo);
(gdb) 
794		if (fcinfo.isnull)
(gdb) 
797		return result;
(gdb) p result
$32 = 39820808
(gdb) n
798	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x24e4e80, from_version=0x0, version=0x25daaa8 "5.0", requiredSchemas=0x0, schemaName=0x25d0048 "pg_catalog", schemaOid=11)
    at extension.c:899
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) p qSchemaName 
$33 = 0x25d0048 "pg_catalog"
(gdb) n
913			if (control->module_pathname)
(gdb) p t_sql
$34 = 39820808
(gdb) p control->module_pathname
$35 = 0x25d0028 "$libdir/citus"
(gdb) n
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) p t_sql
$36 = 39744552
(gdb) n
924			execute_sql_string(c_sql, filename);
(gdb) p c_sql
$37 = 0x25eae58 "/* citus.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE SCHEMA citus;\n\n-- Ensure CREATE EXTENSION is not run against an old citus data\n-- directory, we're "...
(gdb) p filename
$38 = 0x25df058 "/opt/pgsql-10.1/share/extension/citus--5.0.sql"
(gdb) s
execute_sql_string (
    sql=0x25eae58 "/* citus.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE SCHEMA citus;\n\n-- Ensure CREATE EXTENSION is not run against an old citus data\n-- directory, we're "..., filename=0x25df058 "/opt/pgsql-10.1/share/extension/citus--5.0.sql") at extension.c:706
706		raw_parsetree_list = pg_parse_query(sql);
(gdb) n
709		dest = CreateDestReceiver(DestNone);
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) p  *parsetree
$39 = {type = T_RawStmt, stmt = 0x24e4da8, stmt_location = 0, stmt_len = 113}
(gdb) n
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) p  *stmt
$40 = {type = T_PlannedStmt, commandType = CMD_UTILITY, queryId = 0, hasReturning = 0 '\000', hasModifyingCTE = 0 '\000', canSetTag = 1 '\001', transientPlan = 0 '\000', 
  dependsOnRole = 0 '\000', parallelModeNeeded = 0 '\000', planTree = 0x0, rtable = 0x0, resultRelations = 0x0, nonleafResultRelations = 0x0, rootResultRelations = 0x0, subplans = 0x0, 
  rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x0, invalItems = 0x0, nParamExec = 0, utilityStmt = 0x24e4da8, stmt_location = 0, stmt_len = 113}
(gdb) n
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) p  *stmt
$41 = {type = T_PlannedStmt, commandType = CMD_UTILITY, queryId = 0, hasReturning = 0 '\000', hasModifyingCTE = 0 '\000', canSetTag = 1 '\001', transientPlan = 0 '\000', 
  dependsOnRole = 0 '\000', parallelModeNeeded = 0 '\000', planTree = 0x0, rtable = 0x0, resultRelations = 0x0, nonleafResultRelations = 0x0, rootResultRelations = 0x0, subplans = 0x0, 
  rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x0, invalItems = 0x0, nParamExec = 0, utilityStmt = 0x25d28e0, stmt_location = 114, stmt_len = 331}
(gdb) n
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) p  *stmt
$42 = {type = T_PlannedStmt, commandType = CMD_UTILITY, queryId = 0, hasReturning = 0 '\000', hasModifyingCTE = 0 '\000', canSetTag = 1 '\001', transientPlan = 0 '\000', 
  dependsOnRole = 0 '\000', parallelModeNeeded = 0 '\000', planTree = 0x0, rtable = 0x0, resultRelations = 0x0, nonleafResultRelations = 0x0, rootResultRelations = 0x0, subplans = 0x0, 
  rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x0, invalItems = 0x0, nParamExec = 0, utilityStmt = 0x24e51c0, stmt_location = 446, stmt_len = 443}
(gdb) n
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) p  *stmt
$43 = {type = T_PlannedStmt, commandType = CMD_UTILITY, queryId = 0, hasReturning = 0 '\000', hasModifyingCTE = 0 '\000', canSetTag = 1 '\001', transientPlan = 0 '\000', 
  dependsOnRole = 0 '\000', parallelModeNeeded = 0 '\000', planTree = 0x0, rtable = 0x0, resultRelations = 0x0, nonleafResultRelations = 0x0, rootResultRelations = 0x0, subplans = 0x0, 
  rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x0, invalItems = 0x0, nParamExec = 0, utilityStmt = 0x25d2da8, stmt_location = 890, stmt_len = 188}
(gdb) n
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 






772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)

(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);

(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)

(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) p version
No symbol "version" in current context.
(gdb) b execute_extension_script
Breakpoint 2 at 0x6002fd: file extension.c, line 802.
(gdb) n
716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);

(gdb) 


732			foreach(lc2, stmt_list)

(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());

(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))

(gdb) 

763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);

(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 

772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 


736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 



763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 

730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 


736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 


772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);

(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,

(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)

(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 


723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 

730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)

(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 



716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 




730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)

(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 


723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 




730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)

(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);

(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);

(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);

(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 


736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 


723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 


736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 


772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);

(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 



734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 




772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());

(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 


725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 




734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 




730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 


758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);

(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 



740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) n
730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 


736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 


723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,

(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);

(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)

(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 


740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 


763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);

(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 



730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();

(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)

(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))

(gdb) 

763					ProcessUtility(stmt,
(gdb) 


772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);

(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))

(gdb) 

763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)
(gdb) 


718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 



732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)

(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))

(gdb) 
763					ProcessUtility(stmt,
(gdb) 


772				PopActiveSnapshot();

(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,

(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 


772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 


732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 


738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 


772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 


734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 

772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 
758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 


772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 

772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 
718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 

723			CommandCounterIncrement();
(gdb) 
725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 


730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 
763					ProcessUtility(stmt,
(gdb) 



772				PopActiveSnapshot();
(gdb) 
732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 

730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 

772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 

730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 
736				CommandCounterIncrement();
(gdb) 

738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 
772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

716		foreach(lc1, raw_parsetree_list)
(gdb) 

718			RawStmt    *parsetree = lfirst_node(RawStmt, lc1);
(gdb) 
723			CommandCounterIncrement();
(gdb) 

725			stmt_list = pg_analyze_and_rewrite(parsetree,
(gdb) 

730			stmt_list = pg_plan_queries(stmt_list, CURSOR_OPT_PARALLEL_OK, NULL);
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 

734				PlannedStmt *stmt = lfirst_node(PlannedStmt, lc2);
(gdb) 

736				CommandCounterIncrement();
(gdb) 
738				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 

740				if (stmt->utilityStmt == NULL)
(gdb) 

758					if (IsA(stmt->utilityStmt, TransactionStmt))
(gdb) 

763					ProcessUtility(stmt,
(gdb) 

772				PopActiveSnapshot();
(gdb) 

732			foreach(lc2, stmt_list)
(gdb) 
716		foreach(lc1, raw_parsetree_list)

(gdb) 
777		CommandCounterIncrement();
(gdb) 

778	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x24e4e80, from_version=0x0, version=0x25daaa8 "5.0", requiredSchemas=0x0, schemaName=0x25d0048 "pg_catalog", schemaOid=11)
    at extension.c:932
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 


CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x25d0048 "pg_catalog", versionName=0x25daaa8 "5.0", oldVersionName=0x0, cascade=0 '\000', parents=0x0, 
    is_create=1 '\001') at extension.c:1538
1538		ApplyExtensionUpdates(extensionOid, pcontrol,
(gdb) 



Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x269cc70, from_version=0x25daaa8 "5.0", version=0x25dbb48 "5.0-1", requiredSchemas=0x0, 
    schemaName=0x269db60 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 

852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) p versionName
$44 = 0x25da870 "5.0-2"
(gdb) n
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) bt
#0  ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3090
#1  0x0000000000601613 in CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x25d0048 "pg_catalog", versionName=0x25daaa8 "5.0", oldVersionName=0x0, cascade=0 '\000', 
    parents=0x0, is_create=1 '\001') at extension.c:1538
#2  0x0000000000601d4e in CreateExtension (pstate=0x2599fc8, stmt=0x254d518) at extension.c:1718
#3  0x000000000081c66d in ProcessUtilitySlow (pstate=0x2599fc8, pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, 
    dest=0x254d918, completionTag=0x7ffc17b007c0 "") at utility.c:1349
#4  0x000000000081bb2c in standard_ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, 
    dest=0x254d918, completionTag=0x7ffc17b007c0 "") at utility.c:928
#5  0x00007fbb7daeaab8 in multi_ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x254d918, 
    completionTag=0x7ffc17b007c0 "") at commands/utility_hook.c:136
#6  0x000000000081ac94 in ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x254d918, 
    completionTag=0x7ffc17b007c0 "") at utility.c:353
#7  0x0000000000819ed1 in PortalRunUtility (portal=0x2597068, pstmt=0x254d838, isTopLevel=1 '\001', setHoldSnapshot=0 '\000', dest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:1178
#8  0x000000000081a0b2 in PortalRunMulti (portal=0x2597068, isTopLevel=1 '\001', setHoldSnapshot=0 '\000', dest=0x254d918, altdest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:1324
#9  0x000000000081968a in PortalRun (portal=0x2597068, count=9223372036854775807, isTopLevel=1 '\001', run_once=1 '\001', dest=0x254d918, altdest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:799
#10 0x0000000000813b59 in exec_simple_query (query_string=0x254caf8 "create extension citus;") at postgres.c:1099
#11 0x0000000000817b1f in PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4088
#12 0x000000000078b2d2 in BackendRun (port=0x24e29d0) at postmaster.c:4357
#13 0x000000000078aa7b in BackendStartup (port=0x24e29d0) at postmaster.c:4029
#14 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#15 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x249dbe0) at postmaster.c:1361
#16 0x00000000006cf26f in main (argc=1, argv=0x249dbe0) at main.c:228
(gdb) n
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26906c8, from_version=0x25dbb48 "5.0-1", version=0x25da870 "5.0-2", requiredSchemas=0x0, 
    schemaName=0x26a02d0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) bt
#0  execute_extension_script (extensionOid=100956, control=0x26906c8, from_version=0x25dbb48 "5.0-1", version=0x25da870 "5.0-2", requiredSchemas=0x0, schemaName=0x26a02d0 "pg_catalog", 
    schemaOid=11) at extension.c:802
#1  0x0000000000605485 in ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', 
    is_create=1 '\001') at extension.c:3148
#2  0x0000000000601613 in CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x25d0048 "pg_catalog", versionName=0x25daaa8 "5.0", oldVersionName=0x0, cascade=0 '\000', 
    parents=0x0, is_create=1 '\001') at extension.c:1538
#3  0x0000000000601d4e in CreateExtension (pstate=0x2599fc8, stmt=0x254d518) at extension.c:1718
#4  0x000000000081c66d in ProcessUtilitySlow (pstate=0x2599fc8, pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, 
    dest=0x254d918, completionTag=0x7ffc17b007c0 "") at utility.c:1349
#5  0x000000000081bb2c in standard_ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, 
    dest=0x254d918, completionTag=0x7ffc17b007c0 "") at utility.c:928
#6  0x00007fbb7daeaab8 in multi_ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x254d918, 
    completionTag=0x7ffc17b007c0 "") at commands/utility_hook.c:136
#7  0x000000000081ac94 in ProcessUtility (pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x254d918, 
    completionTag=0x7ffc17b007c0 "") at utility.c:353
#8  0x0000000000819ed1 in PortalRunUtility (portal=0x2597068, pstmt=0x254d838, isTopLevel=1 '\001', setHoldSnapshot=0 '\000', dest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:1178
#9  0x000000000081a0b2 in PortalRunMulti (portal=0x2597068, isTopLevel=1 '\001', setHoldSnapshot=0 '\000', dest=0x254d918, altdest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:1324
#10 0x000000000081968a in PortalRun (portal=0x2597068, count=9223372036854775807, isTopLevel=1 '\001', run_once=1 '\001', dest=0x254d918, altdest=0x254d918, completionTag=0x7ffc17b007c0 "")
    at pquery.c:799
#11 0x0000000000813b59 in exec_simple_query (query_string=0x254caf8 "create extension citus;") at postgres.c:1099
#12 0x0000000000817b1f in PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4088
#13 0x000000000078b2d2 in BackendRun (port=0x24e29d0) at postmaster.c:4357
#14 0x000000000078aa7b in BackendStartup (port=0x24e29d0) at postmaster.c:4029
#15 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#16 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x249dbe0) at postmaster.c:1361
#17 0x00000000006cf26f in main (argc=1, argv=0x249dbe0) at main.c:228
(gdb) b ApplyExtensionUpdates
Breakpoint 3 at 0x6050b4: file extension.c, line 3021.
(gdb) n
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) p filename
$45 = 0x268fc98 "/opt/pgsql-10.1/share/extension/citus--5.0-1--5.0-2.sql"
(gdb) p from_version 
$46 = 0x25dbb48 "5.0-1"
(gdb) p version
$47 = 0x25da870 "5.0-2"
(gdb) b get_extension_script_filename
Breakpoint 4 at 0x5ff88d: file extension.c, line 440.
(gdb) n
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$48 = 0x25d0d08 "5.1-1"
(gdb) n
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2699a10, from_version=0x25da870 "5.0-2", version=0x25d0d08 "5.1-1", requiredSchemas=0x0, 
    schemaName=0x2699c80 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) n
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2699a10, from_version=0x25da870 "5.0-2", version=0x25d0d08 "5.1-1") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) n
442		result = (char *) palloc(MAXPGPATH);
(gdb) p scriptdir 
$49 = 0x269a140 "/opt/pgsql-10.1/share/extension"
(gdb) n
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) p result
$50 = 0x2699d30 "/opt/pgsql-10.1/share/extension/citus--5.0-2--5.1-1.sql"
(gdb) n
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2699a10, from_version=0x25da870 "5.0-2", version=0x25d0d08 "5.1-1", requiredSchemas=0x0, schemaName=0x2699c80 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 

924			execute_sql_string(c_sql, filename);

(gdb) 


932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);

(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);

(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 



3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);

(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x269a550, from_version=0x25d0d08 "5.1-1", version=0x24e4b88 "5.1-2", requiredSchemas=0x0, 
    schemaName=0x26a5bd8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x269a550, from_version=0x25d0d08 "5.1-1", version=0x24e4b88 "5.1-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);

(gdb) 
443		if (from_version)

(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x269a550, from_version=0x25d0d08 "5.1-1", version=0x24e4b88 "5.1-2", requiredSchemas=0x0, schemaName=0x26a5bd8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26a8b38, from_version=0x24e4b88 "5.1-2", version=0x24e4ab0 "5.1-3", requiredSchemas=0x0, 
    schemaName=0x26a8c98 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x26a8b38, from_version=0x24e4b88 "5.1-2", version=0x24e4ab0 "5.1-3") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x26a8b38, from_version=0x24e4b88 "5.1-2", version=0x24e4ab0 "5.1-3", requiredSchemas=0x0, schemaName=0x26a8c98 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",

(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,

(gdb) 


870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);

(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


899			if (!control->relocatable)

(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);

(gdb) 

932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],

(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);

(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */

(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 

3077			memset(nulls, 0, sizeof(nulls));

(gdb) 

3078			memset(repl, 0, sizeof(repl));

(gdb) 

3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =

(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);

(gdb) 

3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;

(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;

(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26ad130, from_version=0x24e4ab0 "5.1-3", version=0x25dd278 "5.1-4", requiredSchemas=0x0, 
    schemaName=0x26ad040 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x26ad130, from_version=0x24e4ab0 "5.1-3", version=0x25dd278 "5.1-4") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 


450		pfree(scriptdir);
(gdb) 

452		return result;

(gdb) 
453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x26ad130, from_version=0x24e4ab0 "5.1-3", version=0x25dd278 "5.1-4", requiredSchemas=0x0, schemaName=0x26ad040 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",

(gdb) 

835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 


870		creating_extension = true;

(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();

(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),

(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,

(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 



913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 



922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);

(gdb) 

941	}
(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 

3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 

3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);

(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 

3092			systable_endscan(extScan);
(gdb) 


3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 

3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 



Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26b25c0, from_version=0x25dd278 "5.1-4", version=0x25dd2e0 "5.1-5", requiredSchemas=0x0, 
    schemaName=0x26b2720 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x26b25c0, from_version=0x25dd278 "5.1-4", version=0x25dd2e0 "5.1-5") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 



450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 

453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x26b25c0, from_version=0x25dd278 "5.1-4", version=0x25dd2e0 "5.1-5", requiredSchemas=0x0, schemaName=0x26b2720 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 

852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 

870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 

878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 


913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 


922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 

932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 

ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 

3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 

3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 

3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 

3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 

3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 

3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 

3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26c0158, from_version=0x25dd2e0 "5.1-5", version=0x25dc4b0 "5.1-6", requiredSchemas=0x0, 
    schemaName=0x26c0a98 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x26c0158, from_version=0x25dd2e0 "5.1-5", version=0x25dc4b0 "5.1-6") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 


450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 

453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x26c0158, from_version=0x25dd2e0 "5.1-5", version=0x25dc4b0 "5.1-6", requiredSchemas=0x0, schemaName=0x26c0a98 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 

835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)
(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 

870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 

878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 



913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 


922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 

932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 

ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;

(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 

3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 

3077			memset(nulls, 0, sizeof(nulls));
(gdb) 

3078			memset(repl, 0, sizeof(repl));
(gdb) 

3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 

3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 

3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 

3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 

3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 



Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26d05d8, from_version=0x25dc4b0 "5.1-6", version=0x25da400 "5.1-7", requiredSchemas=0x0, 
    schemaName=0x26d0878 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x26d05d8, from_version=0x25dc4b0 "5.1-6", version=0x25da400 "5.1-7") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 



450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 

453	}
(gdb) 

execute_extension_script (extensionOid=100956, control=0x26d05d8, from_version=0x25dc4b0 "5.1-6", version=0x25da400 "5.1-7", requiredSchemas=0x0, schemaName=0x26d0878 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 

835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 

852		foreach(lc, requiredSchemas)
(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 

870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 

874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 



3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);

(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 







Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26dfdc0, from_version=0x25da400 "5.1-7", version=0x25da468 "5.1-8", requiredSchemas=0x0, 
    schemaName=0x26dff20 "pg_catalog", schemaOid=11) at extension.c:802

802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x26dfdc0, from_version=0x25da400 "5.1-7", version=0x25da468 "5.1-8") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 



450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x26dfdc0, from_version=0x25da400 "5.1-7", version=0x25da468 "5.1-8", requiredSchemas=0x0, schemaName=0x26dff20 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)

(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 


872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 

878			t_sql = CStringGetTextDatum(c_sql);

(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


899			if (!control->relocatable)
(gdb) 


901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,

(gdb) 



922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));

(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);

(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 

3077			memset(nulls, 0, sizeof(nulls));

(gdb) 

3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =

(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);

(gdb) 

3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;

(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);

(gdb) 
3148			execute_extension_script(extensionOid, control,

(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26e37b0, from_version=0x25da468 "5.1-8", version=0x25db098 "5.2-1", requiredSchemas=0x0, 
    schemaName=0x26e8c28 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x26e37b0, from_version=0x25da468 "5.1-8", version=0x25db098 "5.2-1") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)

(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);

(gdb) 
452		return result;

(gdb) 
453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x26e37b0, from_version=0x25da468 "5.1-8", version=0x25db098 "5.2-1", requiredSchemas=0x0, schemaName=0x26e8c28 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)

(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));

(gdb) 

852		foreach(lc, requiredSchemas)

(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,

(gdb) 


870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));

(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,

(gdb) 
889											CStringGetTextDatum(""),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);

(gdb) 

932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;

(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);

(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);

(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);

(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 

3070			schemaOid = extForm->extnamespace;

(gdb) 
3071			schemaName = get_namespace_name(schemaOid);

(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 

3078			memset(repl, 0, sizeof(repl));

(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26e3fa8, from_version=0x25db098 "5.2-1", version=0x25db100 "5.2-2", requiredSchemas=0x0, 
    schemaName=0x26e4e48 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x26e3fa8, from_version=0x25db098 "5.2-1", version=0x25db100 "5.2-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x26e3fa8, from_version=0x25db098 "5.2-1", version=0x25db100 "5.2-2", requiredSchemas=0x0, schemaName=0x26e4e48 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 

3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 



3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 




3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26d4578, from_version=0x25db100 "5.2-2", version=0x25d9f48 "5.2-3", requiredSchemas=0x0, 
    schemaName=0x26d4410 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x26d4578, from_version=0x25db100 "5.2-2", version=0x25d9f48 "5.2-3") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x26d4578, from_version=0x25db100 "5.2-2", version=0x25d9f48 "5.2-3", requiredSchemas=0x0, schemaName=0x26d4410 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 


850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);

(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 
934		creating_extension = false;

(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}

(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 

3059			extTup = systable_getnext(extScan);

(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */

(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 

3070			schemaOid = extForm->extnamespace;
(gdb) 


3071			schemaName = get_namespace_name(schemaOid);
(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 

3077			memset(nulls, 0, sizeof(nulls));

(gdb) 

3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);

(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26f6c78, from_version=0x25d9f48 "5.2-3", version=0x25d9f90 "5.2-4", requiredSchemas=0x0, 
    schemaName=0x26f6b78 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x26f6c78, from_version=0x25d9f48 "5.2-3", version=0x25d9f90 "5.2-4") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x26f6c78, from_version=0x25d9f48 "5.2-3", version=0x25d9f90 "5.2-4", requiredSchemas=0x0, schemaName=0x26f6b78 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));

(gdb) 

852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 


870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,

(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2708b88, from_version=0x25d9f90 "5.2-4", version=0x25d1c10 "6.0-1", requiredSchemas=0x0, 
    schemaName=0x2708ef8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2708b88, from_version=0x25d9f90 "5.2-4", version=0x25d1c10 "6.0-1") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2708b88, from_version=0x25d9f90 "5.2-4", version=0x25d1c10 "6.0-1", requiredSchemas=0x0, schemaName=0x2708ef8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();

(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}

(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);

(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);

(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 




3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);

(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2727738, from_version=0x25d1c10 "6.0-1", version=0x25d1c78 "6.0-2", requiredSchemas=0x0, 
    schemaName=0x27281c8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);

(gdb) 


Breakpoint 4, get_extension_script_filename (control=0x2727738, from_version=0x25d1c10 "6.0-1", version=0x25d1c78 "6.0-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)

(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 



450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 
453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x2727738, from_version=0x25d1c10 "6.0-1", version=0x25d1c78 "6.0-2", requiredSchemas=0x0, schemaName=0x27281c8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)

(gdb) 
832			(void) set_config_option("client_min_messages", "warning",

(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));

(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 


870		creating_extension = true;

(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 

878			t_sql = CStringGetTextDatum(c_sql);

(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,

(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,

(gdb) 


899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);

(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 

932		PG_END_TRY();
(gdb) 


934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 

3078			memset(repl, 0, sizeof(repl));

(gdb) 

3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;

(gdb) 
3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;

(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x272bed0, from_version=0x25d1c78 "6.0-2", version=0x25da550 "6.0-3", requiredSchemas=0x0, 
    schemaName=0x272c140 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x272bed0, from_version=0x25d1c78 "6.0-2", version=0x25da550 "6.0-3") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x272bed0, from_version=0x25d1c78 "6.0-2", version=0x25da550 "6.0-3", requiredSchemas=0x0, schemaName=0x272c140 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2738278, from_version=0x25da550 "6.0-3", version=0x25dcd08 "6.0-4", requiredSchemas=0x0, 
    schemaName=0x273fbd8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x2738278, from_version=0x25da550 "6.0-3", version=0x25dcd08 "6.0-4") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 


452		return result;
(gdb) 
453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x2738278, from_version=0x25da550 "6.0-3", version=0x25dcd08 "6.0-4", requiredSchemas=0x0, schemaName=0x273fbd8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 


832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 





932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);

(gdb) 
3051			ScanKeyInit(&key[0],

(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,

(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */

(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);

(gdb) 

3076			memset(values, 0, sizeof(values));

(gdb) 

3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;

(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;

(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27452b0, from_version=0x25dcd08 "6.0-4", version=0x25db1e8 "6.0-5", requiredSchemas=0x0, 
    schemaName=0x27455a0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x27452b0, from_version=0x25dcd08 "6.0-4", version=0x25db1e8 "6.0-5") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 



450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 
453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x27452b0, from_version=0x25dcd08 "6.0-4", version=0x25db1e8 "6.0-5", requiredSchemas=0x0, schemaName=0x27455a0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();

(gdb) 
831		if (client_min_messages < WARNING)

(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 


870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));

(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


899			if (!control->relocatable)

(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,

(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 





932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);

(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */

(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);

(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 

3081				BoolGetDatum(control->relocatable);

(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2792d30, from_version=0x25db1e8 "6.0-5", version=0x25db250 "6.0-6", requiredSchemas=0x0, 
    schemaName=0x2792ec0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2792d30, from_version=0x25db1e8 "6.0-5", version=0x25db250 "6.0-6") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2792d30, from_version=0x25db1e8 "6.0-5", version=0x25db250 "6.0-6", requiredSchemas=0x0, schemaName=0x2792ec0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 

3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);

(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 






Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27b5210, from_version=0x25db250 "6.0-6", version=0x25db658 "6.0-7", requiredSchemas=0x0, 
    schemaName=0x27b5480 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x27b5210, from_version=0x25db250 "6.0-6", version=0x25db658 "6.0-7") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x27b5210, from_version=0x25db250 "6.0-6", version=0x25db658 "6.0-7", requiredSchemas=0x0, schemaName=0x27b5480 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",

(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 


850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 


934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 



3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27bbee8, from_version=0x25db658 "6.0-7", version=0x25db6c0 "6.0-8", requiredSchemas=0x0, 
    schemaName=0x27bc188 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x27bbee8, from_version=0x25db658 "6.0-7", version=0x25db6c0 "6.0-8") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 


452		return result;
(gdb) 
453	}
(gdb) 




execute_extension_script (extensionOid=100956, control=0x27bbee8, from_version=0x25db658 "6.0-7", version=0x25db6c0 "6.0-8", requiredSchemas=0x0, schemaName=0x27bc188 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)

(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 

852		foreach(lc, requiredSchemas)

(gdb) 

861		(void) set_config_option("search_path", pathbuf.data,

(gdb) 

870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 


ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,

(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */

(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 



3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 

3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27c5c98, from_version=0x25db6c0 "6.0-8", version=0x25d0bb8 "6.0-9", requiredSchemas=0x0, 
    schemaName=0x27c6898 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())

(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x27c5c98, from_version=0x25db6c0 "6.0-8", version=0x25d0bb8 "6.0-9") at extension.c:440
440		scriptdir = get_extension_script_directory(control);

(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x27c5c98, from_version=0x25db6c0 "6.0-8", version=0x25d0bb8 "6.0-9", requiredSchemas=0x0, schemaName=0x27c6898 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,

(gdb) 


870		creating_extension = true;

(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 

3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 






Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27c00c8, from_version=0x25d0bb8 "6.0-9", version=0x25d0c20 "6.0-10", requiredSchemas=0x0, 
    schemaName=0x27d8ce8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);

(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x27c00c8, from_version=0x25d0bb8 "6.0-9", version=0x25d0c20 "6.0-10") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x27c00c8, from_version=0x25d0bb8 "6.0-9", version=0x25d0c20 "6.0-10", requiredSchemas=0x0, schemaName=0x27d8ce8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 







874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 



903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 







913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 



3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27f17d8, from_version=0x25d0c20 "6.0-10", version=0x25db508 "6.0-11", requiredSchemas=0x0, 
    schemaName=0x27f4bd8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x27f17d8, from_version=0x25d0c20 "6.0-10", version=0x25db508 "6.0-11") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x27f17d8, from_version=0x25d0c20 "6.0-10", version=0x25db508 "6.0-11", requiredSchemas=0x0, schemaName=0x27f4bd8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);

(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 

3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 



3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 



3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27a12a8, from_version=0x25db508 "6.0-11", version=0x25db570 "6.0-12", requiredSchemas=0x0, 
    schemaName=0x27a2f68 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x27a12a8, from_version=0x25db508 "6.0-11", version=0x25db570 "6.0-12") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x27a12a8, from_version=0x25db508 "6.0-11", version=0x25db570 "6.0-12", requiredSchemas=0x0, schemaName=0x27a2f68 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 


832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x27a8190, from_version=0x25db570 "6.0-12", version=0x25dbc30 "6.0-13", requiredSchemas=0x0, 
    schemaName=0x27a8dd0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x27a8190, from_version=0x25db570 "6.0-12", version=0x25dbc30 "6.0-13") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x27a8190, from_version=0x25db570 "6.0-12", version=0x25dbc30 "6.0-13", requiredSchemas=0x0, schemaName=0x27a8dd0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 

903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));

(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 


934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 




ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 


3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 

3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;

(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 




3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 


3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x28105f0, from_version=0x25dbc30 "6.0-13", version=0x25dafb0 "6.0-14", requiredSchemas=0x0, 
    schemaName=0x2810860 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x28105f0, from_version=0x25dbc30 "6.0-13", version=0x25dafb0 "6.0-14") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x28105f0, from_version=0x25dbc30 "6.0-13", version=0x25dafb0 "6.0-14", requiredSchemas=0x0, schemaName=0x2810860 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 





874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 



878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 


901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 



903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 







913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 








922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 




924			execute_sql_string(c_sql, filename);
(gdb) 














932		PG_END_TRY();
(gdb) 


934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x28111a0, from_version=0x25dafb0 "6.0-14", version=0x25d1738 "6.0-15", requiredSchemas=0x0, 
    schemaName=0x280ffe0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x28111a0, from_version=0x25dafb0 "6.0-14", version=0x25d1738 "6.0-15") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x28111a0, from_version=0x25dafb0 "6.0-14", version=0x25d1738 "6.0-15", requiredSchemas=0x0, schemaName=0x280ffe0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,

(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));

(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 




932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;

(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);

(gdb) 



3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 


3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 




3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 


3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x281a498, from_version=0x25d1738 "6.0-15", version=0x25d17a0 "6.0-16", requiredSchemas=0x0, 
    schemaName=0x281a5f8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x281a498, from_version=0x25d1738 "6.0-15", version=0x25d17a0 "6.0-16") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x281a498, from_version=0x25d1738 "6.0-15", version=0x25d17a0 "6.0-16", requiredSchemas=0x0, schemaName=0x281a5f8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 




852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 




870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);

(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));

(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 



932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 



3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 




3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 




3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x281d370, from_version=0x25d17a0 "6.0-16", version=0x25d07c8 "6.0-17", requiredSchemas=0x0, 
    schemaName=0x281e040 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x281d370, from_version=0x25d17a0 "6.0-16", version=0x25d07c8 "6.0-17") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x281d370, from_version=0x25d17a0 "6.0-16", version=0x25d07c8 "6.0-17", requiredSchemas=0x0, schemaName=0x281e040 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2823948, from_version=0x25d07c8 "6.0-17", version=0x25d0830 "6.0-18", requiredSchemas=0x0, 
    schemaName=0x28241a8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2823948, from_version=0x25d07c8 "6.0-17", version=0x25d0830 "6.0-18") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2823948, from_version=0x25d07c8 "6.0-17", version=0x25d0830 "6.0-18", requiredSchemas=0x0, schemaName=0x28241a8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 


3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),

(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2828af8, from_version=0x25d0830 "6.0-18", version=0x25db338 "6.1-1", requiredSchemas=0x0, 

    schemaName=0x2828f48 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x2828af8, from_version=0x25d0830 "6.0-18", version=0x25db338 "6.1-1") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x2828af8, from_version=0x25d0830 "6.0-18", version=0x25db338 "6.1-1", requiredSchemas=0x0, schemaName=0x2828f48 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 


832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 



3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,

(gdb) 

3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;

(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 

3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x282c7e8, from_version=0x25db338 "6.1-1", version=0x25dd6b0 "6.1-2", requiredSchemas=0x0, 
    schemaName=0x282d458 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x282c7e8, from_version=0x25db338 "6.1-1", version=0x25dd6b0 "6.1-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x282c7e8, from_version=0x25db338 "6.1-1", version=0x25dd6b0 "6.1-2", requiredSchemas=0x0, schemaName=0x282d458 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 




852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 



878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 







913			if (control->module_pathname)

(gdb) 


915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 






922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 




924			execute_sql_string(c_sql, filename);
(gdb) 



932		PG_END_TRY();
(gdb) 

934		creating_extension = false;

(gdb) 
935		CurrentExtensionObject = InvalidOid;

(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}

(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 


3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 


3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);

(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);

(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 


3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x283f8c8, from_version=0x25dd6b0 "6.1-2", version=0x25dcf58 "6.1-3", requiredSchemas=0x0, 

    schemaName=0x2840508 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x283f8c8, from_version=0x25dd6b0 "6.1-2", version=0x25dcf58 "6.1-3") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x283f8c8, from_version=0x25dd6b0 "6.1-2", version=0x25dcf58 "6.1-3", requiredSchemas=0x0, schemaName=0x2840508 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 




852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 





874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 






913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 






922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 



932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 





941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 



3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 


3071			schemaName = get_namespace_name(schemaOid);
(gdb) 



3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 

3081				BoolGetDatum(control->relocatable);

(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =

(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 






Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2843fb0, from_version=0x25dcf58 "6.1-3", version=0x25dcfc0 "6.1-4", requiredSchemas=0x0, 
    schemaName=0x2844c20 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())

(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x2843fb0, from_version=0x25dcf58 "6.1-3", version=0x25dcfc0 "6.1-4") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 


452		return result;
(gdb) 
453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x2843fb0, from_version=0x25dcf58 "6.1-3", version=0x25dcfc0 "6.1-4", requiredSchemas=0x0, schemaName=0x2844c20 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 





874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 


901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)

(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 



3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 




3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2846708, from_version=0x25dcfc0 "6.1-4", version=0x25ddb68 "6.1-5", requiredSchemas=0x0, 
    schemaName=0x2846f78 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2846708, from_version=0x25dcfc0 "6.1-4", version=0x25ddb68 "6.1-5") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2846708, from_version=0x25dcfc0 "6.1-4", version=0x25ddb68 "6.1-5", requiredSchemas=0x0, schemaName=0x2846f78 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2866160, from_version=0x25ddb68 "6.1-5", version=0x25d1348 "6.1-6", requiredSchemas=0x0, 
    schemaName=0x28669c0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2866160, from_version=0x25ddb68 "6.1-5", version=0x25d1348 "6.1-6") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2866160, from_version=0x25ddb68 "6.1-5", version=0x25d1348 "6.1-6", requiredSchemas=0x0, schemaName=0x28669c0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x28652e8, from_version=0x25d1348 "6.1-6", version=0x25d13b0 "6.1-7", requiredSchemas=0x0, 
    schemaName=0x286a580 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x28652e8, from_version=0x25d1348 "6.1-6", version=0x25d13b0 "6.1-7") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x28652e8, from_version=0x25d1348 "6.1-6", version=0x25d13b0 "6.1-7", requiredSchemas=0x0, schemaName=0x286a580 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 


3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;

(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x286e8f0, from_version=0x25d13b0 "6.1-7", version=0x25db420 "6.1-8", requiredSchemas=0x0, 
    schemaName=0x286b898 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())

(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x286e8f0, from_version=0x25d13b0 "6.1-7", version=0x25db420 "6.1-8") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 
453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x286e8f0, from_version=0x25d13b0 "6.1-7", version=0x25db420 "6.1-8", requiredSchemas=0x0, schemaName=0x286b898 "pg_catalog", 

    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 




835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 



3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 






Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2875ea0, from_version=0x25db420 "6.1-8", version=0x25dae60 "6.1-9", requiredSchemas=0x0, 
    schemaName=0x2876b70 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 


818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x2875ea0, from_version=0x25db420 "6.1-8", version=0x25dae60 "6.1-9") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 



442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 
453	}
(gdb) 












execute_extension_script (extensionOid=100956, control=0x2875ea0, from_version=0x25db420 "6.1-8", version=0x25dae60 "6.1-9", requiredSchemas=0x0, schemaName=0x2876b70 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",

(gdb) 

835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 



3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x28817b8, from_version=0x25dae60 "6.1-9", version=0x25daec8 "6.1-10", requiredSchemas=0x0, 
    schemaName=0x28816d8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x28817b8, from_version=0x25dae60 "6.1-9", version=0x25daec8 "6.1-10") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x28817b8, from_version=0x25dae60 "6.1-9", version=0x25daec8 "6.1-10", requiredSchemas=0x0, schemaName=0x28816d8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 




852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 



878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);

(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 






922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);

(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);

(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26c1240, from_version=0x25daec8 "6.1-10", version=0x25d0678 "6.1-11", requiredSchemas=0x0, 
    schemaName=0x2854568 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x26c1240, from_version=0x25daec8 "6.1-10", version=0x25d0678 "6.1-11") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x26c1240, from_version=0x25daec8 "6.1-10", version=0x25d0678 "6.1-11", requiredSchemas=0x0, schemaName=0x2854568 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 


870		creating_extension = true;

(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,

(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)

(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);

(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 



3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 




3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 






Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x28a3fa0, from_version=0x25d0678 "6.1-11", version=0x25d06e0 "6.1-12", requiredSchemas=0x0, 
    schemaName=0x28a3e90 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x28a3fa0, from_version=0x25d0678 "6.1-11", version=0x25d06e0 "6.1-12") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);

(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x28a3fa0, from_version=0x25d0678 "6.1-11", version=0x25d06e0 "6.1-12", requiredSchemas=0x0, schemaName=0x28a3e90 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);

(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));

(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,

(gdb) 




899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 






913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 


934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);

(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */

(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 



3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 



3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2830538, from_version=0x25d06e0 "6.1-12", version=0x25dc7e8 "6.1-13", requiredSchemas=0x0, 
    schemaName=0x2831178 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x2830538, from_version=0x25d06e0 "6.1-12", version=0x25dc7e8 "6.1-13") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 

execute_extension_script (extensionOid=100956, control=0x2830538, from_version=0x25d06e0 "6.1-12", version=0x25dc7e8 "6.1-13", requiredSchemas=0x0, schemaName=0x2831178 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2834ca0, from_version=0x25dc7e8 "6.1-13", version=0x25dc850 "6.1-14", requiredSchemas=0x0, 
    schemaName=0x28358e0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2834ca0, from_version=0x25dc7e8 "6.1-13", version=0x25dc850 "6.1-14") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2834ca0, from_version=0x25dc7e8 "6.1-13", version=0x25dc850 "6.1-14", requiredSchemas=0x0, schemaName=0x28358e0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x26f4dd0, from_version=0x25dc850 "6.1-14", version=0x25dc618 "6.1-15", requiredSchemas=0x0, 
    schemaName=0x26f5720 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x26f4dd0, from_version=0x25dc850 "6.1-14", version=0x25dc618 "6.1-15") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x26f4dd0, from_version=0x25dc850 "6.1-14", version=0x25dc618 "6.1-15", requiredSchemas=0x0, schemaName=0x26f5720 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 






Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x290bea0, from_version=0x25dc618 "6.1-15", version=0x25dba60 "6.1-16", requiredSchemas=0x0, 
    schemaName=0x290d470 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 





Breakpoint 4, get_extension_script_filename (control=0x290bea0, from_version=0x25dc618 "6.1-15", version=0x25dba60 "6.1-16") at extension.c:440
440		scriptdir = get_extension_script_directory(control);

(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x290bea0, from_version=0x25dc618 "6.1-15", version=0x25dba60 "6.1-16", requiredSchemas=0x0, schemaName=0x290d470 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 


870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 


901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,

(gdb) 







922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 


3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x290e758, from_version=0x25dba60 "6.1-16", version=0x25d0f40 "6.1-17", requiredSchemas=0x0, 

    schemaName=0x290f288 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x290e758, from_version=0x25dba60 "6.1-16", version=0x25d0f40 "6.1-17") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x290e758, from_version=0x25dba60 "6.1-16", version=0x25d0f40 "6.1-17", requiredSchemas=0x0, schemaName=0x290f288 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 



878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 




3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 


3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 



3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 






Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2916130, from_version=0x25d0f40 "6.1-17", version=0x25d0fa8 "6.2-1", requiredSchemas=0x0, 
    schemaName=0x2916c60 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x2916130, from_version=0x25d0f40 "6.1-17", version=0x25d0fa8 "6.2-1") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 


452		return result;
(gdb) 
453	}
(gdb) 




execute_extension_script (extensionOid=100956, control=0x2916130, from_version=0x25d0f40 "6.1-17", version=0x25d0fa8 "6.2-1", requiredSchemas=0x0, schemaName=0x2916c60 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 


899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 



903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 


932		PG_END_TRY();
(gdb) 


934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 




ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 



3078			memset(repl, 0, sizeof(repl));
(gdb) 

3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 



3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 



3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 


3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x291b988, from_version=0x25d0fa8 "6.2-1", version=0x25d0a68 "6.2-2", requiredSchemas=0x0, 
    schemaName=0x29183b8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 



818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 




Breakpoint 4, get_extension_script_filename (control=0x291b988, from_version=0x25d0fa8 "6.2-1", version=0x25d0a68 "6.2-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 





450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 


execute_extension_script (extensionOid=100956, control=0x291b988, from_version=0x25d0fa8 "6.2-1", version=0x25d0a68 "6.2-2", requiredSchemas=0x0, schemaName=0x29183b8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();

(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 


901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 



903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 



932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2921e98, from_version=0x25d0a68 "6.2-2", version=0x25d0ad0 "6.2-3", requiredSchemas=0x0, 
    schemaName=0x2922ac0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2921e98, from_version=0x25d0a68 "6.2-2", version=0x25d0ad0 "6.2-3") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x2921e98, from_version=0x25d0a68 "6.2-2", version=0x25d0ad0 "6.2-3", requiredSchemas=0x0, schemaName=0x2922ac0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 



3127			myself.classId = ExtensionRelationId;

(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x294fb08, from_version=0x25d0ad0 "6.2-3", version=0x25da9d8 "6.2-4", requiredSchemas=0x0, 
    schemaName=0x294fef8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 


Breakpoint 4, get_extension_script_filename (control=0x294fb08, from_version=0x25d0ad0 "6.2-3", version=0x25da9d8 "6.2-4") at extension.c:440
440		scriptdir = get_extension_script_directory(control);

(gdb) 


442		result = (char *) palloc(MAXPGPATH);
(gdb) 

443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 






450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x294fb08, from_version=0x25d0ad0 "6.2-3", version=0x25da9d8 "6.2-4", requiredSchemas=0x0, schemaName=0x294fef8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 


831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 


872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 



899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);

(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




913			if (control->module_pathname)

(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 


924			execute_sql_string(c_sql, filename);
(gdb) 



932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 


935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 




ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 


3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x292aff0, from_version=0x25da9d8 "6.2-4", version=0x25da160 "7.0-1", requiredSchemas=0x0, 
    schemaName=0x292b040 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x292aff0, from_version=0x25da9d8 "6.2-4", version=0x25da160 "7.0-1") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x292aff0, from_version=0x25da9d8 "6.2-4", version=0x25da160 "7.0-1", requiredSchemas=0x0, schemaName=0x292b040 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 

878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 

901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 





922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 



932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 


941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 



3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 



3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x292b970, from_version=0x25da160 "7.0-1", version=0x25da1c8 "7.0-2", requiredSchemas=0x0, 
    schemaName=0x293b248 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 


Breakpoint 4, get_extension_script_filename (control=0x292b970, from_version=0x25da160 "7.0-1", version=0x25da1c8 "7.0-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x292b970, from_version=0x25da160 "7.0-1", version=0x25da1c8 "7.0-2", requiredSchemas=0x0, schemaName=0x293b248 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 

850		initStringInfo(&pathbuf);
(gdb) 


851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 

922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 


3070			schemaOid = extForm->extnamespace;
(gdb) 


3071			schemaName = get_namespace_name(schemaOid);
(gdb) 

3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 



3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 

3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 


3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);

(gdb) 

3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;

(gdb) 
3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;

(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)

(gdb) 


3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 




Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x29573b0, from_version=0x25da1c8 "7.0-2", version=0x25dc028 "7.0-3", requiredSchemas=0x0, 
    schemaName=0x2957620 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())

(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x29573b0, from_version=0x25da1c8 "7.0-2", version=0x25dc028 "7.0-3") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 

execute_extension_script (extensionOid=100956, control=0x29573b0, from_version=0x25da1c8 "7.0-2", version=0x25dc028 "7.0-3", requiredSchemas=0x0, schemaName=0x2957620 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 


922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 





932		PG_END_TRY();
(gdb) 


934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 

940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 


3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 


3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 

3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 

3127			myself.classId = ExtensionRelationId;

(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 


3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2996ff0, from_version=0x25dc028 "7.0-3", version=0x25dab40 "7.0-4", requiredSchemas=0x0, 
    schemaName=0x29a3380 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) n
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 



Breakpoint 4, get_extension_script_filename (control=0x2996ff0, from_version=0x25dc028 "7.0-3", version=0x25dab40 "7.0-4") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 

442		result = (char *) palloc(MAXPGPATH);
(gdb) 


443		if (from_version)
(gdb) 

444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 




450		pfree(scriptdir);
(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 

execute_extension_script (extensionOid=100956, control=0x2996ff0, from_version=0x25dc028 "7.0-3", version=0x25dab40 "7.0-4", requiredSchemas=0x0, schemaName=0x29a3380 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 


870		creating_extension = true;
(gdb) 

871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 



874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 



878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

889											CStringGetTextDatum(""),
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 




899			if (!control->relocatable)
(gdb) 


901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 


903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 



913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) n
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 

3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 



3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 

3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 




3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 



3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,

(gdb) 

3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x29b4978, from_version=0x25dab40 "7.0-4", version=0x25daba8 "7.0-5", requiredSchemas=0x0, 
    schemaName=0x29b7878 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x29b4978, from_version=0x25dab40 "7.0-4", version=0x25daba8 "7.0-5") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x29b4978, from_version=0x25dab40 "7.0-4", version=0x25daba8 "7.0-5", requiredSchemas=0x0, schemaName=0x29b7878 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 


835		if (log_min_messages < WARNING)
(gdb) 

850
		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 




852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 


872		PG_TRY();
(gdb) 


874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 

915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 




922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));

(gdb) 



924			execute_sql_string(c_sql, filename);
(gdb) 







932		PG_END_TRY();
(gdb) 

934		creating_extension = false;
(gdb) 

935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 



941	}
(gdb) 



ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 


3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 

3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 

3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 




3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 



3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x29e96b8, from_version=0x25daba8 "7.0-5", version=0x25ddd50 "7.0-6", requiredSchemas=0x0, 
    schemaName=0x29e9ed0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x29e96b8, from_version=0x25daba8 "7.0-5", version=0x25ddd50 "7.0-6") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) n
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 



450		pfree(scriptdir);

(gdb) 

452		return result;
(gdb) 

453	}
(gdb) 



execute_extension_script (extensionOid=100956, control=0x29e96b8, from_version=0x25daba8 "7.0-5", version=0x25ddd50 "7.0-6", requiredSchemas=0x0, schemaName=0x29e9ed0 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 

831		if (client_min_messages < WARNING)
(gdb) 

832			(void) set_config_option("client_min_messages", "warning",
(gdb) 



835		if (log_min_messages < WARNING)
(gdb) 


850		initStringInfo(&pathbuf);
(gdb) 

851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 



852		foreach(lc, requiredSchemas)
(gdb) 


861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 



878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 

890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 

888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 

941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 


3059			extTup = systable_getnext(extScan);
(gdb) 

3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 



3070			schemaOid = extForm->extnamespace;
(gdb) 

3071			schemaName = get_namespace_name(schemaOid);
(gdb) 


3076			memset(values, 0, sizeof(values));
(gdb) 


3077			memset(nulls, 0, sizeof(nulls));
(gdb) 


3078			memset(repl, 0, sizeof(repl));
(gdb) 


3081				BoolGetDatum(control->relocatable);
(gdb) 


3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 

3084				CStringGetTextDatum(versionName);
(gdb) 


3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 

3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 

3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);
(gdb) 


3094			heap_close(extRel, RowExclusiveLock);
(gdb) 

3101			requiredExtensions = NIL;
(gdb) 

3102			requiredSchemas = NIL;
(gdb) 

3103			foreach(lc, control->requires)
(gdb) 



3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 


3127			myself.classId = ExtensionRelationId;
(gdb) 

3128			myself.objectId = extensionOid;
(gdb) 

3129			myself.objectSubId = 0;
(gdb) 

3131			foreach(lc, requiredExtensions)
(gdb) 



3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 

3148			execute_extension_script(extensionOid, control,
(gdb) 





Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x29f5f88, from_version=0x25ddd50 "7.0-6", version=0x25da788 "7.0-7", requiredSchemas=0x0, 
    schemaName=0x29f2328 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 

818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x29f5f88, from_version=0x25ddd50 "7.0-6", version=0x25da788 "7.0-7") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 

450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=100956, control=0x29f5f88, from_version=0x25ddd50 "7.0-6", version=0x25da788 "7.0-7", requiredSchemas=0x0, schemaName=0x29f2328 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 


852		foreach(lc, requiredSchemas)
(gdb) 



861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 



870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 

872		PG_TRY();
(gdb) 




874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 


878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 


890											CStringGetTextDatum("ng"));
(gdb) 


885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 

885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=100956, pcontrol=0x24e4b18, initialVersion=0x25daaa8 "5.0", updateVersions=0x25de348, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 

3051			ScanKeyInit(&key[0],
(gdb) 


3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 



3059			extTup = systable_getnext(extScan);
(gdb) 


3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 

3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 




3070			schemaOid = extForm->extnamespace;

(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 



3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 


3092			systable_endscan(extScan);

(gdb) 

3094			heap_close(extRel, RowExclusiveLock);
(gdb) 


3101			requiredExtensions = NIL;

(gdb) 
3102			requiredSchemas = NIL;
(gdb) 


3103			foreach(lc, control->requires)
(gdb) 


3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 



3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=100956, control=0x2a1db50, from_version=0x25da788 "7.0-7", version=0x25d19d8 "7.0-8", requiredSchemas=0x0, 
    schemaName=0x2a1e000 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 4, get_extension_script_filename (control=0x2a1db50, from_version=0x25da788 "7.0-7", version=0x25d19d8 "7.0-8") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 

450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000601881 in CreateExtension at extension.c:1623
	breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000006002fd in execute_extension_script at extension.c:802
	breakpoint already hit 61 times
3       breakpoint     keep y   0x00000000006050b4 in ApplyExtensionUpdates at extension.c:3021
4       breakpoint     keep y   0x00000000005ff88d in get_extension_script_filename at extension.c:440
	breakpoint already hit 59 times
(gdb) q
A debugging session is active.

	Inferior 1 [process 8723] will be detached.

Quit anyway? (y or n) y
Detaching from program: /opt/pgsql-10.1/bin/postgres, process 8723
[cituscluster@gtm1 ~]$ gdb attach 8723
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 8723
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
Reading symbols from /opt/pgsql-10.1/lib/plpgsql.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/plpgsql.so
0x00007fbb843d3163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) b CreateExtension
Breakpoint 1 at 0x601881: file extension.c, line 1623.
(gdb) b execute_extension_script
Breakpoint 2 at 0x6002fd: file extension.c, line 802.
(gdb) b get_extension_script_filename
Breakpoint 3 at 0x5ff88d: file extension.c, line 440.
(gdb) b ApplyExtensionUpdates
Breakpoint 4 at 0x6050b4: file extension.c, line 3021.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) 
WaitEventSetWaitBlock (set=0x249f7c8, cur_timeout=-1, occurred_events=0x7ffc17b007c0, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x249f7c8, timeout=-1, occurred_events=0x7ffc17b007c0, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
1000			rc = WaitEventSetWaitBlock(set, cur_timeout,
(gdb) 
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x24e29d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffc17b009d0) at postgres.c:330
330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 
359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffc17b009d0) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) 
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 1, CreateExtension (pstate=0x25997b8, stmt=0x254d518) at extension.c:1623
1623		DefElem    *d_schema = NULL;
(gdb) 
1624		DefElem    *d_new_version = NULL;
(gdb) 
1625		DefElem    *d_old_version = NULL;
(gdb) 
1626		DefElem    *d_cascade = NULL;
(gdb) 
1627		char	   *schemaName = NULL;
(gdb) 
1628		char	   *versionName = NULL;
(gdb) 
1629		char	   *oldVersionName = NULL;
(gdb) 
1630		bool		cascade = false;
(gdb) 
1634		check_valid_extension_name(stmt->extname);
(gdb) 
1642		if (get_extension_oid(stmt->extname, true) != InvalidOid)
(gdb) 
1663		if (creating_extension)
(gdb) 
1669		foreach(lc, stmt->options)
(gdb) 
1718		return CreateExtensionInternal(stmt->extname,
(gdb) 

Breakpoint 3, get_extension_script_filename (control=0x26b7ce0, from_version=0x0, version=0x28e7e28 "8.2-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) p scriptdir 
$1 = 0x26b7838 "/opt/pgsql-10.1/share/extension"
(gdb) n
443		if (from_version)
(gdb) 
447			snprintf(result, MAXPGPATH, "%s/%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) p result
$2 = 0x28e7e80 "/opt/pgsql-10.1/share/extension/citus--8.2-2.sql"
(gdb) n
452		return result;
(gdb) 
453	}
(gdb) 
CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x0, versionName=0x28e7e28 "8.2-2", oldVersionName=0x0, cascade=0 '\000', parents=0x0, is_create=1 '\001')
    at extension.c:1365
1365			if (stat(filename, &fst) == 0)
(gdb) 
1378				evi_list = get_ext_ver_list(pcontrol);
(gdb) 
1381				evi_target = get_ext_ver_info(versionName, &evi_list);
(gdb) 
1384				evi_start = find_install_path(evi_list, evi_target,
(gdb) 
1388				if (evi_start == NULL)
(gdb) 
1395				versionName = evi_start->name;
(gdb) 
1402		control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$3 = 0x25a2fb0 "5.0"
(gdb) p evi_list
No symbol "evi_list" in current context.
(gdb) n
1407		if (schemaName)
(gdb) 
1413		if (control->schema != NULL)
(gdb) 
1422			if (schemaName && strcmp(control->schema, schemaName) != 0 &&
(gdb) 
1431			schemaName = control->schema;
(gdb) 
1434			schemaOid = get_namespace_oid(schemaName, true);
(gdb) 
1436			if (!OidIsValid(schemaOid))
(gdb) 
1490		requiredExtensions = NIL;
(gdb) 
1491		requiredSchemas = NIL;
(gdb) 
1492		foreach(lc, control->requires)
(gdb) 
1513									   schemaOid, control->relocatable,
(gdb) 
1512		address = InsertExtensionTuple(control->name, extowner,
(gdb) 
1518		extensionOid = address.objectId;
(gdb) 
1523		if (control->comment != NULL)
(gdb) 
1524			CreateComments(extensionOid, ExtensionRelationId, 0, control->comment);
(gdb) 
1529		execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x28e7d58, from_version=0x0, version=0x25a2fb0 "5.0", requiredSchemas=0x0, schemaName=0x28e7e60 "pg_catalog", 
    schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 3, get_extension_script_filename (control=0x28e7d58, from_version=0x0, version=0x25a2fb0 "5.0") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) n
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
447			snprintf(result, MAXPGPATH, "%s/%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) p result
$4 = 0x27966f0 "/opt/pgsql-10.1/share/extension/citus--5.0.sql"
(gdb) n
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=101388, control=0x28e7d58, from_version=0x0, version=0x25a2fb0 "5.0", requiredSchemas=0x0, schemaName=0x28e7e60 "pg_catalog", schemaOid=11)
    at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x28e7e60 "pg_catalog", versionName=0x25a2fb0 "5.0", oldVersionName=0x0, cascade=0 '\000', parents=0x0, 
    is_create=1 '\001') at extension.c:1538
1538		ApplyExtensionUpdates(extensionOid, pcontrol,
(gdb) 

Breakpoint 4, ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', 
    is_create=1 '\001') at extension.c:3021
3021		const char *oldVersionName = initialVersion;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) p oldVersionName 
$5 = 0x25a2fb0 "5.0"
(gdb) n
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) p versionName 
$6 = 0x25a4050 "5.0-1"
(gdb) n
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x2a71108, from_version=0x25a2fb0 "5.0", version=0x25a4050 "5.0-1", requiredSchemas=0x0, 
    schemaName=0x2a71ff8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) n
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 3, get_extension_script_filename (control=0x2a71108, from_version=0x25a2fb0 "5.0", version=0x25a4050 "5.0-1") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) p result
$7 = 0x2b058f8 "/opt/pgsql-10.1/share/extension/citus--5.0--5.0-1.sql"
(gdb) n
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=101388, control=0x2a71108, from_version=0x25a2fb0 "5.0", version=0x25a4050 "5.0-1", requiredSchemas=0x0, schemaName=0x2a71ff8 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) n
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) n
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) p versionName 
$8 = 0x25a2d78 "5.0-2"
(gdb) n
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x2a6c728, from_version=0x25a4050 "5.0-1", version=0x25a2d78 "5.0-2", requiredSchemas=0x0, 
    schemaName=0x29f1318 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 

Breakpoint 3, get_extension_script_filename (control=0x2a6c728, from_version=0x25a4050 "5.0-1", version=0x25a2d78 "5.0-2") at extension.c:440
440		scriptdir = get_extension_script_directory(control);
(gdb) 
442		result = (char *) palloc(MAXPGPATH);
(gdb) 
443		if (from_version)
(gdb) 
444			snprintf(result, MAXPGPATH, "%s/%s--%s--%s.sql",
(gdb) 
450		pfree(scriptdir);
(gdb) 
452		return result;
(gdb) 
453	}
(gdb) 
execute_extension_script (extensionOid=101388, control=0x2a6c728, from_version=0x25a4050 "5.0-1", version=0x25a2d78 "5.0-2", requiredSchemas=0x0, schemaName=0x29f1318 "pg_catalog", 
    schemaOid=11) at extension.c:829
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000601881 in CreateExtension at extension.c:1623
	breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000006002fd in execute_extension_script at extension.c:802
	breakpoint already hit 3 times
3       breakpoint     keep y   0x00000000005ff88d in get_extension_script_filename at extension.c:440
	breakpoint already hit 4 times
4       breakpoint     keep y   0x00000000006050b4 in ApplyExtensionUpdates at extension.c:3021
	breakpoint already hit 1 time
(gdb) d 3
(gdb) n
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x29f4b80, from_version=0x25a2d78 "5.0-2", version=0x28e8b20 "5.1-1", requiredSchemas=0x0, 
    schemaName=0x29f4df0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x29f56c0, from_version=0x28e8b20 "5.1-1", version=0x26b7d50 "5.1-2", requiredSchemas=0x0, 
    schemaName=0x29f2b38 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 

874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x29f7990, from_version=0x26b7d50 "5.1-2", version=0x26b7c48 "5.1-3", requiredSchemas=0x0, 
    schemaName=0x29f8000 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x29fbf78, from_version=0x26b7c48 "5.1-3", version=0x29a81c0 "5.1-4", requiredSchemas=0x0, 
    schemaName=0x29fc018 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x25db240, from_version=0x29a81c0 "5.1-4", version=0x29a8228 "5.1-5", requiredSchemas=0x0, 
    schemaName=0x25db3a0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x25e91d8, from_version=0x29a8228 "5.1-5", version=0x29a73f8 "5.1-6", requiredSchemas=0x0, 
    schemaName=0x25e9338 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x2893130, from_version=0x29a73f8 "5.1-6", version=0x25a2908 "5.1-7", requiredSchemas=0x0, 
    schemaName=0x28954f8 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x289e4f8, from_version=0x25a2908 "5.1-7", version=0x25a2970 "5.1-8", requiredSchemas=0x0, 
    schemaName=0x289e658 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x277bd60, from_version=0x25a2970 "5.1-8", version=0x25a35a0 "5.2-1", requiredSchemas=0x0, 
    schemaName=0x277c858 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x277c558, from_version=0x25a35a0 "5.2-1", version=0x25a3608 "5.2-2", requiredSchemas=0x0, 
    schemaName=0x25df7e0 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x27855a0, from_version=0x25a3608 "5.2-2", version=0x25a2430 "5.2-3", requiredSchemas=0x0, 
    schemaName=0x2785438 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) 
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

Breakpoint 2, execute_extension_script (extensionOid=101388, control=0x2788698, from_version=0x25a2430 "5.2-3", version=0x25a2498 "5.2-4", requiredSchemas=0x0, 
    schemaName=0x2788580 "pg_catalog", schemaOid=11) at extension.c:802
802		if (control->superuser && !superuser())
(gdb) 
818		filename = get_extension_script_filename(control, from_version, version);
(gdb) 
829		save_nestlevel = NewGUCNestLevel();
(gdb) 
831		if (client_min_messages < WARNING)
(gdb) 
832			(void) set_config_option("client_min_messages", "warning",
(gdb) 
835		if (log_min_messages < WARNING)
(gdb) 
850		initStringInfo(&pathbuf);
(gdb) 
851		appendStringInfoString(&pathbuf, quote_identifier(schemaName));
(gdb) 
852		foreach(lc, requiredSchemas)
(gdb) 
861		(void) set_config_option("search_path", pathbuf.data,
(gdb) 
870		creating_extension = true;
(gdb) 
871		CurrentExtensionObject = extensionOid;
(gdb) 
872		PG_TRY();
(gdb) 
874			char	   *c_sql = read_extension_script_file(control, filename);
(gdb) 
878			t_sql = CStringGetTextDatum(c_sql);
(gdb) 
890											CStringGetTextDatum("ng"));
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
889											CStringGetTextDatum(""),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
888											CStringGetTextDatum("^\\\\echo.*$"),
(gdb) 
885			t_sql = DirectFunctionCall4Coll(textregexreplace,
(gdb) 
899			if (!control->relocatable)
(gdb) 
901				const char *qSchemaName = quote_identifier(schemaName);
(gdb) 
903				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
913			if (control->module_pathname)
(gdb) 
915				t_sql = DirectFunctionCall3(replace_text,
(gdb) 
922			c_sql = text_to_cstring(DatumGetTextPP(t_sql));
(gdb) 
924			execute_sql_string(c_sql, filename);
(gdb) 
932		PG_END_TRY();
(gdb) 
934		creating_extension = false;
(gdb) 
935		CurrentExtensionObject = InvalidOid;
(gdb) 
940		AtEOXact_GUC(true, save_nestlevel);
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000601881 in CreateExtension at extension.c:1623
	breakpoint already hit 1 time
2       breakpoint     keep y   0x00000000006002fd in execute_extension_script at extension.c:802
	breakpoint already hit 15 times
4       breakpoint     keep y   0x00000000006050b4 in ApplyExtensionUpdates at extension.c:3021
	breakpoint already hit 1 time
(gdb) d 2
(gdb) n
941	}
(gdb) 
ApplyExtensionUpdates (extensionOid=101388, pcontrol=0x26b7ce0, initialVersion=0x25a2fb0 "5.0", updateVersions=0x27959e0, origSchemaName=0x0, cascade=0 '\000', is_create=1 '\001')
    at extension.c:3158
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 


3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) p versionName 
$9 = 0x28e8a38 "6.0-10"
(gdb) n
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 



3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 

3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,

(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 


3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 

3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) p versionName 
$10 = 0x25a3840 "6.1-1"
(gdb) n
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) p versionName 
$11 = 0x29a7798 "6.1-14"
(gdb) n
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) p versionName 
$12 = 0x25a30b0 "7.0-5"
(gdb) n
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) p versionName 
$13 = 0x29a6d18 "7.0-11"
(gdb) n
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) p versionName 
$14 = 0x25a3cb0 "7.0-14"
(gdb) n
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$15 = 0x28e9400 "7.1-3"
(gdb) n
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) p versionName 
$16 = 0x29a7310 "7.2-2"
(gdb) n
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) p versionName 
$17 = 0x25a20a8 "7.3-1"
(gdb) n
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) p versionName 
$18 = 0x26b7f08 "7.4-1"
(gdb) n
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) n
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 

3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) p versionName 
$19 = 0x28e9708 "7.5-5"
(gdb) n
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) p versionName 
$20 = 0x29a86e0 "8.0-3"
(gdb) n
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$21 = 0x25a2820 "8.0-6"
(gdb) n
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 

3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) p versionName 
$22 = 0x29a7058 "8.0-9"
(gdb) n
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) p versionName 
$23 = 0x28e8f28 "8.0-10"
(gdb) n
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$24 = 0x28e8f90 "8.0-11"
(gdb) n
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) p versionName 
$25 = 0x28e8c08 "8.0-12"
(gdb) n
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) p versionName 
$26 = 0x28e8c70 "8.0-13"
(gdb) n
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) 
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$27 = 0x25a3200 "8.2-1"
(gdb) n
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) 
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3026			char	   *versionName = (char *) lfirst(lcv);
(gdb) 
3046			control = read_extension_aux_control_file(pcontrol, versionName);
(gdb) p versionName 
$28 = 0x29a7a00 "8.2-2"
(gdb) n
3049			extRel = heap_open(ExtensionRelationId, RowExclusiveLock);
(gdb) 
3051			ScanKeyInit(&key[0],
(gdb) 
3056			extScan = systable_beginscan(extRel, ExtensionOidIndexId, true,
(gdb) 
3059			extTup = systable_getnext(extScan);
(gdb) 
3061			if (!HeapTupleIsValid(extTup))	/* should not happen */
(gdb) 
3065			extForm = (Form_pg_extension) GETSTRUCT(extTup);
(gdb) 
3070			schemaOid = extForm->extnamespace;
(gdb) 
3071			schemaName = get_namespace_name(schemaOid);
(gdb) 
3076			memset(values, 0, sizeof(values));
(gdb) 
3077			memset(nulls, 0, sizeof(nulls));
(gdb) 
3078			memset(repl, 0, sizeof(repl));
(gdb) 
3081				BoolGetDatum(control->relocatable);
(gdb) 
3080			values[Anum_pg_extension_extrelocatable - 1] =
(gdb) 
3082			repl[Anum_pg_extension_extrelocatable - 1] = true;
(gdb) n
3084				CStringGetTextDatum(versionName);
(gdb) 
3083			values[Anum_pg_extension_extversion - 1] =
(gdb) 
3085			repl[Anum_pg_extension_extversion - 1] = true;
(gdb) 
3087			extTup = heap_modify_tuple(extTup, RelationGetDescr(extRel),
(gdb) 
3090			CatalogTupleUpdate(extRel, &extTup->t_self, extTup);
(gdb) 
3092			systable_endscan(extScan);
(gdb) 
3094			heap_close(extRel, RowExclusiveLock);
(gdb) 
3101			requiredExtensions = NIL;
(gdb) 
3102			requiredSchemas = NIL;
(gdb) 
3103			foreach(lc, control->requires)
(gdb) 
3123			deleteDependencyRecordsForClass(ExtensionRelationId, extensionOid,
(gdb) 
3127			myself.classId = ExtensionRelationId;
(gdb) 
3128			myself.objectId = extensionOid;
(gdb) 
3129			myself.objectSubId = 0;
(gdb) 
3131			foreach(lc, requiredExtensions)
(gdb) 
3143			InvokeObjectPostAlterHook(ExtensionRelationId, extensionOid, 0);
(gdb) 
3148			execute_extension_script(extensionOid, control,
(gdb) 
3158			oldVersionName = versionName;
(gdb) 
3024		foreach(lcv, updateVersions)
(gdb) 
3160	}
(gdb) 
CreateExtensionInternal (extensionName=0x254d500 "citus", schemaName=0x28e7e60 "pg_catalog", versionName=0x25a2fb0 "5.0", oldVersionName=0x0, cascade=0 '\000', parents=0x0, 
    is_create=1 '\001') at extension.c:1542
1542		return address;
(gdb) p address
$29 = {classId = 3079, objectId = 101388, objectSubId = 0}
(gdb) n
1543	}
(gdb) 
CreateExtension (pstate=0x25997b8, stmt=0x254d518) at extension.c:1725
1725	}
(gdb) 
ProcessUtilitySlow (pstate=0x25997b8, pstmt=0x254d838, queryString=0x254caf8 "create extension citus;", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x254d918, 
    completionTag=0x7ffc17b007c0 "") at utility.c:1350
1350					break;
(gdb) q
A debugging session is active.

	Inferior 1 [process 8723] will be detached.

Quit anyway? (y or n) y
Detaching from program: /opt/pgsql-10.1/bin/postgres, process 8723
[cituscluster@gtm1 ~]$ gdb attach 10300
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 10300
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007fbb843d3163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) b get_ext_ver_list
Breakpoint 1 at 0x6008f0: file extension.c, line 1015.
(gdb) b get_ext_ver_info
Breakpoint 2 at 0x60079e: file extension.c, line 957.
(gdb) b find_install_path
Breakpoint 3 at 0x600d97: file extension.c, line 1215.
(gdb) b read_extension_aux_control_file
Breakpoint 4 at 0x5fffda: file extension.c, line 639.
(gdb) 
Note: breakpoint 4 also set at pc 0x5fffda.
Breakpoint 5 at 0x5fffda: file extension.c, line 639.
(gdb) 
Note: breakpoints 4 and 5 also set at pc 0x5fffda.
Breakpoint 6 at 0x5fffda: file extension.c, line 639.
(gdb) 
Note: breakpoints 4, 5 and 6 also set at pc 0x5fffda.
Breakpoint 7 at 0x5fffda: file extension.c, line 639.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000006008f0 in get_ext_ver_list at extension.c:1015
2       breakpoint     keep y   0x000000000060079e in get_ext_ver_info at extension.c:957
3       breakpoint     keep y   0x0000000000600d97 in find_install_path at extension.c:1215
4       breakpoint     keep y   0x00000000005fffda in read_extension_aux_control_file at extension.c:639
5       breakpoint     keep y   0x00000000005fffda in read_extension_aux_control_file at extension.c:639
6       breakpoint     keep y   0x00000000005fffda in read_extension_aux_control_file at extension.c:639
7       breakpoint     keep y   0x00000000005fffda in read_extension_aux_control_file at extension.c:639
(gdb) d 5
(gdb) d 6
(gdb) d 7
(gdb) n
WaitEventSetWaitBlock (set=0x249f7c8, cur_timeout=-1, occurred_events=0x7ffc17b007c0, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x249f7c8, timeout=-1, occurred_events=0x7ffc17b007c0, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
984				occurred_events->fd = PGINVALID_SOCKET;
(gdb) 
985				occurred_events->pos = set->latch_pos;
(gdb) 
987					set->events[set->latch_pos].user_data;
(gdb) 
986				occurred_events->user_data =
(gdb) 
988				occurred_events->events = WL_LATCH_SET;
(gdb) 
989				occurred_events++;
(gdb) 
990				returned_events++;
(gdb) 
992				break;
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x24e2a00, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
194				ResetLatch(MyLatch);
(gdb) 
195				ProcessClientReadInterrupt(true);
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffc17b009d0) at postgres.c:330
330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 
359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffc17b009d0) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x24e8358, dbname=0x24e8208 "postgres", username=0x249fd08 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) 
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 1, get_ext_ver_list (control=0x25a3798) at extension.c:1015
1015		List	   *evi_list = NIL;
(gdb) 
1016		int			extnamelen = strlen(control->name);
(gdb) 
1021		location = get_extension_script_directory(control);
(gdb) d get_extension_script_directory
warning: bad breakpoint number at or near 'get_extension_script_directory'
(gdb) b get_extension_script_directory
Breakpoint 8 at 0x5ff76a: file extension.c, line 402.
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000006008f0 in get_ext_ver_list at extension.c:1015
	breakpoint already hit 1 time
2       breakpoint     keep y   0x000000000060079e in get_ext_ver_info at extension.c:957
3       breakpoint     keep y   0x0000000000600d97 in find_install_path at extension.c:1215
4       breakpoint     keep y   0x00000000005fffda in read_extension_aux_control_file at extension.c:639
8       breakpoint     keep y   0x00000000005ff76a in get_extension_script_directory at extension.c:402
(gdb) n

Breakpoint 8, get_extension_script_directory (control=0x25a3798) at extension.c:402
402		if (!control->directory)
(gdb) 
403			return get_extension_control_directory();
(gdb) p control->directory
$1 = 0x0
(gdb) s
get_extension_control_directory () at extension.c:371
371		get_share_path(my_exec_path, sharepath);
(gdb) n
372		result = (char *) palloc(MAXPGPATH);
(gdb) 
373		snprintf(result, MAXPGPATH, "%s/extension", sharepath);
(gdb) 
375		return result;
(gdb) p result
$2 = 0x25a3320 "/opt/pgsql-10.1/share/extension"
(gdb) n
376	}
(gdb) 
get_extension_script_directory (control=0x25a3798) at extension.c:413
413	}
(gdb) 
get_ext_ver_list (control=0x25a3798) at extension.c:1022
1022		dir = AllocateDir(location);
(gdb) 
1023		while ((de = ReadDir(dir, location)) != NULL)
(gdb) 
1031			if (!is_extension_script_filename(de->d_name))
(gdb) p de
$3 = (struct dirent *) 0x25ccfa0
(gdb) p *de
$4 = {d_ino = 53083683, d_off = 10, d_reclen = 24, d_type = 4 '\004', 
  d_name = ".\000io\004\207\062\071\000\000\000\000\000\f\000\000\000\000\000\000\000\030\000\004..\000n\004\024\376)\003\000\000\000\000\020\000\000\000\000\000\000\000(\000\bplpgsql.control\000fals\b\026\376)\003\000\000\000\000\024\000\000\000\000\000\000\000(\000\bplpgsql--1.0.sql\000\000\000\000\b\027\376)\003\000\000\000\000\031\000\000\000\000\000\000\000\060\000\bplpgsql--unpackaged--1.0.sql\000\034\376)\003\000\000\000\000\035\000\000\000\000\000\000\000(\000\bcitus.control\000\000\000\000\000\000\000\b\035\376)"...}
(gdb) n
1032				continue;
(gdb) 
1023		while ((de = ReadDir(dir, location)) != NULL)
(gdb) 
1031			if (!is_extension_script_filename(de->d_name))
(gdb) p *de
$5 = {d_ino = 3748487, d_off = 12, d_reclen = 24, d_type = 4 '\004', 
  d_name = "..\000n\004\024\376)\003\000\000\000\000\020\000\000\000\000\000\000\000(\000\bplpgsql.control\000fals\b\026\376)\003\000\000\000\000\024\000\000\000\000\000\000\000(\000\bplpgsql--1.0.sql\000\000\000\000\b\027\376)\003\000\000\000\000\031\000\000\000\000\000\000\000\060\000\bplpgsql--unpackaged--1.0.sql\000\034\376)\003\000\000\000\000\035\000\000\000\000\000\000\000(\000\bcitus.control\000\000\000\000\000\000\000\b\035\376)\003\000\000\000\000\"\000\000\000\000\000\000\000\060\000\bcitus--7"...}
(gdb) n
1032				continue;
(gdb) 
1023		while ((de = ReadDir(dir, location)) != NULL)
(gdb) 
1031			if (!is_extension_script_filename(de->d_name))
(gdb) p *de
$6 = {d_ino = 53083668, d_off = 16, d_reclen = 40, d_type = 8 '\b', 
  d_name = "plpgsql.control\000fals\b\026\376)\003\000\000\000\000\024\000\000\000\000\000\000\000(\000\bplpgsql--1.0.sql\000\000\000\000\b\027\376)\003\000\000\000\000\031\000\000\000\000\000\000\000\060\000\bplpgsql--unpackaged--1.0.sql\000\034\376)\003\000\000\000\000\035\000\000\000\000\000\000\000(\000\bcitus.control\000\000\000\000\000\000\000\b\035\376)\003\000\000\000\000\"\000\000\000\000\000\000\000\060\000\bcitus--7.3-3--7.4-1.sql\000\000\000\000\000\b\036\376)"...}
(gdb) n
1032				continue;
(gdb) 
1023		while ((de = ReadDir(dir, location)) != NULL)
(gdb) 
1031			if (!is_extension_script_filename(de->d_name))
(gdb) p *de
$7 = {d_ino = 53083670, d_off = 20, d_reclen = 40, d_type = 8 '\b', 
  d_name = "plpgsql--1.0.sql\000\000\000\000\b\027\376)\003\000\000\000\000\031\000\000\000\000\000\000\000\060\000\bplpgsql--unpackaged--1.0.sql\000\034\376)\003\000\000\000\000\035\000\000\000\000\000\000\000(\000\bcitus.control\000\000\000\000\000\000\000\b\035\376)\003\000\000\000\000\"\000\000\000\000\000\000\000\060\000\bcitus--7.3-3--7.4-1.sql\000\000\000\000\000\b\036\376)\003\000\000\000\000'\000\000\000\000\000\000\000\060\000\bcitus--5.1-2--5.1-3.sql\000\000\000\000\000"...}
(gdb) n
1035			if (strncmp(de->d_name, control->name, extnamelen) != 0 ||
(gdb) p de->d_name
$8 = "plpgsql--1.0.sql\000\000\000\000\b\027\376)\003\000\000\000\000\031\000\000\000\000\000\000\000\060\000\bplpgsql--unpackaged--1.0.sql\000\034\376)\003\000\000\000\000\035\000\000\000\000\000\000\000(\000\bcitus.control\000\000\000\000\000\000\000\b\035\376)\003\000\000\000\000\"\000\000\000\000\000\000\000\060\000\bcitus--7.3-3--7.4-1.sql\000\000\000\000\000\b\036\376)\003\000\000\000\000'\000\000\000\000\000\000\000\060\000\bcitus--5.1-2--5.1-3.sql\000\000\000\000\000"...
(gdb) p control->name
$9 = 0x25a3ce0 "citus"
(gdb) nn
Undefined command: "nn".  Try "help".
(gdb) n
1038				continue;
(gdb) 
1023		while ((de = ReadDir(dir, location)) != NULL)
(gdb) 
1031			if (!is_extension_script_filename(de->d_name))
(gdb) p de->d_name
$10 = "plpgsql--unpackaged--1.0.sql\000\034\376)\003\000\000\000\000\035\000\000\000\000\000\000\000(\000\bcitus.control\000\000\000\000\000\000\000\b\035\376)\003\000\000\000\000\"\000\000\000\000\000\000\000\060\000\bcitus--7.3-3--7.4-1.sql\000\000\000\000\000\b\036\376)\003\000\000\000\000'\000\000\000\000\000\000\000\060\000\bcitus--5.1-2--5.1-3.sql\000\000\000\000\000\b\037\376)\003\000\000\000\000,\000\000\000\000\000\000\000\060\000\bcitus--6.1-11--6"...
(gdb) n
1035			if (strncmp(de->d_name, control->name, extnamelen) != 0 ||
(gdb) 
1038				continue;
(gdb) n
1023		while ((de = ReadDir(dir, location)) != NULL)
(gdb) 
1031			if (!is_extension_script_filename(de->d_name))
(gdb) p de->d_name
$11 = "citus.control\000\000\000\000\000\000\000\b\035\376)\003\000\000\000\000\"\000\000\000\000\000\000\000\060\000\bcitus--7.3-3--7.4-1.sql\000\000\000\000\000\b\036\376)\003\000\000\000\000'\000\000\000\000\000\000\000\060\000\bcitus--5.1-2--5.1-3.sql\000\000\000\000\000\b\037\376)\003\000\000\000\000,\000\000\000\000\000\000\000\060\000\bcitus--6.1-11--6.1-12.sql\000\000\000\b \376)\003\000\000\000\000\061\000\000\000\000\000\000\000\060\000\bcitus--6.0-17--6"...
(gdb) n
1032				continue;
(gdb) 
1023		while ((de = ReadDir(dir, location)) != NULL)
(gdb) 
1031			if (!is_extension_script_filename(de->d_name))
(gdb) p de->d_name
$12 = "citus--7.3-3--7.4-1.sql\000\000\000\000\000\b\036\376)\003\000\000\000\000'\000\000\000\000\000\000\000\060\000\bcitus--5.1-2--5.1-3.sql\000\000\000\000\000\b\037\376)\003\000\000\000\000,\000\000\000\000\000\000\000\060\000\bcitus--6.1-11--6.1-12.sql\000\000\000\b \376)\003\000\000\000\000\061\000\000\000\000\000\000\000\060\000\bcitus--6.0-17--6.0-18.sql\000\000\000\b!\376)\003\000\000\000\000\066\000\000\000\000\000\000\000\060\000\bcitus--8"...
(gdb) n
1035			if (strncmp(de->d_name, control->name, extnamelen) != 0 ||
(gdb) 
1036				de->d_name[extnamelen] != '-' ||
(gdb) 
1035			if (strncmp(de->d_name, control->name, extnamelen) != 0 ||
(gdb) 
1037				de->d_name[extnamelen + 1] != '-')
(gdb) 
1036				de->d_name[extnamelen] != '-' ||
(gdb) 
1041			vername = pstrdup(de->d_name + extnamelen + 2);
(gdb) n
1042			*strrchr(vername, '.') = '\0';
(gdb) n
1043			vername2 = strstr(vername, "--");
(gdb) 
1044			if (!vername2)
(gdb) 
1051			*vername2 = '\0';		/* terminate first version */
(gdb) 
1052			vername2 += 2;			/* and point to second */
(gdb) 
1055			if (strstr(vername2, "--"))
(gdb) 
1059			evi = get_ext_ver_info(vername, &evi_list);
(gdb) 

Breakpoint 2, get_ext_ver_info (versionname=0x25a3d80 "7.3-3", evi_list=0x7ffc17affc58) at extension.c:957
957		foreach(lc, *evi_list)
(gdb) n
964		evi = (ExtensionVersionInfo *) palloc(sizeof(ExtensionVersionInfo));
(gdb) 
965		evi->name = pstrdup(versionname);
(gdb) 
966		evi->reachable = NIL;
(gdb) 
967		evi->installable = false;
(gdb) 
969		evi->distance_known = false;
(gdb) 
970		evi->distance = INT_MAX;
(gdb) 
971		evi->previous = NULL;
(gdb) 
973		*evi_list = lappend(*evi_list, evi);
(gdb) 
975		return evi;
(gdb) p evi
$13 = (ExtensionVersionInfo *) 0x25cb5a8
(gdb) p *evi
$14 = {name = 0x25cb0a8 "7.3-3", reachable = 0x0, installable = 0 '\000', distance_known = 0 '\000', distance = 2147483647, previous = 0x0}
(gdb) n
976	}
(gdb) 
get_ext_ver_list (control=0x25a3798) at extension.c:1060
1060			evi2 = get_ext_ver_info(vername2, &evi_list);
(gdb) 

Breakpoint 2, get_ext_ver_info (versionname=0x25a3d87 "7.4-1", evi_list=0x7ffc17affc58) at extension.c:957
957		foreach(lc, *evi_list)
(gdb) p vername2
No symbol "vername2" in current context.
(gdb) p evi2
No symbol "evi2" in current context.
(gdb) n
959			evi = (ExtensionVersionInfo *) lfirst(lc);
(gdb) 
960			if (strcmp(evi->name, versionname) == 0)
(gdb) n
957		foreach(lc, *evi_list)
(gdb) 
964		evi = (ExtensionVersionInfo *) palloc(sizeof(ExtensionVersionInfo));
(gdb) 
965		evi->name = pstrdup(versionname);
(gdb) 
966		evi->reachable = NIL;
(gdb) 
967		evi->installable = false;
(gdb) 
969		evi->distance_known = false;
(gdb) 
970		evi->distance = INT_MAX;
(gdb) 
971		evi->previous = NULL;
(gdb) 
973		*evi_list = lappend(*evi_list, evi);
(gdb) 
975		return evi;
(gdb) 
976	}
(gdb) 
get_ext_ver_list (control=0x25a3798) at extension.c:1061
1061			evi->reachable = lappend(evi->reachable, evi2);
(gdb) p evi2
$15 = (ExtensionVersionInfo *) 0x25cb608
(gdb) p *evi2
$16 = {name = 0x25a39c0 "7.4-1", reachable = 0x0, installable = 0 '\000', distance_known = 0 '\000', distance = 2147483647, previous = 0x0}
(gdb) p *evi
$17 = {name = 0x25cb0a8 "7.3-3", reachable = 0x0, installable = 0 '\000', distance_known = 0 '\000', distance = 2147483647, previous = 0x0}
(gdb) q
A debugging session is active.

	Inferior 1 [process 10300] will be detached.

Quit anyway? (y or n) y
Detaching from program: /opt/pgsql-10.1/bin/postgres, process 10300

[END] 2019/4/2 ÐÇÆÚ¶þ ÏÂÎç 7:06:48
