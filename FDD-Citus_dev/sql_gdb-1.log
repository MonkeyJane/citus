[BEGIN] 2019/3/15 ÐÇÆÚÎå ÏÂÎç 2:19:50
[cituscluster@gtm1 ~]$ gdb attach 8346
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 8346
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007f274fc22163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) b PostgresMain
Breakpoint 1 at 0x81741b: file postgres.c, line 3587.
(gdb) b exec_simple_query
Breakpoint 2 at 0x813787: file postgres.c, line 880.
(gdb) b transformStmt
Breakpoint 3 at 0x56e414: file analyze.c, line 273.
(gdb) b transformFromClause
Breakpoint 4 at 0x5a4292: file parse_clause.c, line 125.
(gdb) b transformStmt
Note: breakpoint 3 also set at pc 0x56e414.
Breakpoint 5 at 0x56e414: file analyze.c, line 273.
(gdb) b transformSelectStmt
Breakpoint 6 at 0x56fc5c: file analyze.c, line 1182.
(gdb) b transformFromClause
Note: breakpoint 4 also set at pc 0x5a4292.
Breakpoint 7 at 0x5a4292: file parse_clause.c, line 125.
(gdb) b transformTargetList
Breakpoint 8 at 0x5c3fbc: file parse_target.c, line 134.
(gdb) b transformWhereClause
Breakpoint 9 at 0x5a7584: file parse_clause.c, line 1720.
(gdb) b transformSortClause
Breakpoint 10 at 0x5a86d5: file parse_clause.c, line 2589.
(gdb) b transformGroupClause
Breakpoint 11 at 0x5a84a4: file parse_clause.c, line 2487.
(gdb) b transformDistinctClause
Breakpoint 12 at 0x5a8d51: file parse_clause.c, line 2790.
(gdb) b transformDistinctOnClause
Breakpoint 13 at 0x5a8f76: file parse_clause.c, line 2874.
(gdb) b transformSelectStmt
Note: breakpoint 6 also set at pc 0x56fc5c.
Breakpoint 14 at 0x56fc5c: file analyze.c, line 1182.
(gdb) 
Note: breakpoints 6 and 14 also set at pc 0x56fc5c.
Breakpoint 15 at 0x56fc5c: file analyze.c, line 1182.
(gdb) b pg_plan_queries
Breakpoint 16 at 0x813679: file postgres.c, line 842.
(gdb) b pg_plan_query
Breakpoint 17 at 0x8135e2: file postgres.c, line 784.
(gdb) b distributed_planner
Breakpoint 18 at 0x7f274935a96d: file planner/distributed_planner.c, line 94.
(gdb) b standard_planner
Breakpoint 19 at 0x742910: file planner.c, line 233.
(gdb) b CreateDistributedPlan
Breakpoint 20 at 0x7f274935b1c7: file planner/distributed_planner.c, line 580.
(gdb) 
Note: breakpoint 20 also set at pc 0x7f274935b1c7.
Breakpoint 21 at 0x7f274935b1c7: file planner/distributed_planner.c, line 580.
(gdb) b PrepareMasterJobDirectory
Breakpoint 22 at 0x7f274934653b: file executor/multi_real_time_executor.c, line 1069.
(gdb) b ExecuteSubPlans
Breakpoint 23 at 0x7f274934d56e: file executor/subplan_execution.c, line 35.
(gdb) b PortalStart
Breakpoint 24 at 0x818eac: file pquery.c, line 461.
(gdb) b PortalRun
Breakpoint 25 at 0x819407: file pquery.c, line 707.
(gdb) b MultiRealTimeExecute
Breakpoint 26 at 0x7f2749344c5f: file executor/multi_real_time_executor.c, line 88.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) 
WaitEventSetWaitBlock (set=0x16f8728, cur_timeout=-1, occurred_events=0x7ffe485cf350, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x16f8728, timeout=-1, occurred_events=0x7ffe485cf350, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
984				occurred_events->fd = PGINVALID_SOCKET;
(gdb) 
985				occurred_events->pos = set->latch_pos;
(gdb) 
987					set->events[set->latch_pos].user_data;
(gdb) 
986				occurred_events->user_data =
(gdb) 
988				occurred_events->events = WL_LATCH_SET;
(gdb) 
989				occurred_events++;
(gdb) 
990				returned_events++;
(gdb) 
992				break;
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x173b3d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
194				ResetLatch(MyLatch);
(gdb) 
195				ProcessClientReadInterrupt(true);
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffe485cf560) at postgres.c:330
330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 
359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffe485cf560) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) 
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 2, exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:880
880		CommandDest dest = whereToSendOutput;
(gdb) 
884		bool		save_log_statement_stats = log_statement_stats;
(gdb) 
885		bool		was_logged = false;
(gdb) 
893		debug_query_string = query_string;
(gdb) 
895		pgstat_report_activity(STATE_RUNNING, query_string);
(gdb) 
903		if (save_log_statement_stats)
(gdb) 
913		start_xact_command();
(gdb) 
921		drop_unnamed_stmt();
(gdb) 
926		oldcontext = MemoryContextSwitchTo(MessageContext);
(gdb) 
932		parsetree_list = pg_parse_query(query_string);
(gdb) 
935		if (check_log_statement(parsetree_list))
(gdb) 
947		MemoryContextSwitchTo(oldcontext);
(gdb) 
956		isTopLevel = (list_length(parsetree_list) == 1);
(gdb) 
961		foreach(parsetree_item, parsetree_list)
(gdb) 
963			RawStmt    *parsetree = lfirst_node(RawStmt, parsetree_item);
(gdb) 
964			bool		snapshot_set = false;
(gdb) 
979			commandTag = CreateCommandTag(parsetree->stmt);
(gdb) 
981			set_ps_display(commandTag, false);
(gdb) 
983			BeginCommand(commandTag, dest);
(gdb) 
993			if (IsAbortedTransactionBlockState() &&
(gdb) 
1002			start_xact_command();
(gdb) 
1005			CHECK_FOR_INTERRUPTS();
(gdb) 
1010			if (analyze_requires_snapshot(parsetree))
(gdb) 
1012				PushActiveSnapshot(GetTransactionSnapshot());
(gdb) 
1013				snapshot_set = true;
(gdb) 
1022			oldcontext = MemoryContextSwitchTo(MessageContext);
(gdb) 
1024			querytree_list = pg_analyze_and_rewrite(parsetree, query_string,
(gdb) p parsetree
$1 = (RawStmt *) 0x17a4828
(gdb) p *parsetree
$2 = {type = T_RawStmt, stmt = 0x17a4718, stmt_location = 0, stmt_len = 57}
(gdb) p parsetree->stmt
$3 = (Node *) 0x17a4718
(gdb) n

Breakpoint 3, transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:273
273		switch (nodeTag(parseTree))
(gdb) 
292					SelectStmt *n = (SelectStmt *) parseTree;
(gdb) bt
#0  transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:292
#1  0x000000000056e402 in transformOptionalSelectInto (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:242
#2  0x000000000056e2fd in transformTopLevelStmt (pstate=0x17a48a8, parseTree=0x17a4828) at analyze.c:192
#3  0x000000000056e175 in parse_analyze (parseTree=0x17a4828, sourceText=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0)
    at analyze.c:112
#4  0x0000000000813402 in pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, 
    queryEnv=0x0) at postgres.c:653
#5  0x00000000008139d2 in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1024
#6  0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#7  0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#8  0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#9  0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#10 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#11 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
294					if (n->valuesLists)
(gdb) p n
$4 = (SelectStmt *) 0x17a4718
(gdb) p *n
$5 = {type = T_SelectStmt, distinctClause = 0x0, intoClause = 0x0, targetList = 0x17a4178, fromClause = 0x17a46e8, whereClause = 0x0, groupClause = 0x0, havingClause = 0x0, 
  windowClause = 0x0, valuesLists = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, lockingClause = 0x0, withClause = 0x0, op = SETOP_NONE, all = 0 '\000', larg = 0x0, 
  rarg = 0x0}
(gdb) n
296					else if (n->op == SETOP_NONE)
(gdb) 
297						result = transformSelectStmt(pstate, n);
(gdb) 

Breakpoint 6, transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1182
1182		Query	   *qry = makeNode(Query);
(gdb) 
1186		qry->commandType = CMD_SELECT;
(gdb) 
1189		if (stmt->withClause)
(gdb) 
1197		if (stmt->intoClause)
(gdb) 
1205		pstate->p_locking_clause = stmt->lockingClause;
(gdb) 
1208		pstate->p_windowdefs = stmt->windowClause;
(gdb) 
1211		transformFromClause(pstate, stmt->fromClause);
(gdb) 

Breakpoint 4, transformFromClause (pstate=0x17a48a8, frmList=0x17a46e8) at parse_clause.c:125
125		foreach(fl, frmList)
(gdb) 
127			Node	   *n = lfirst(fl);
(gdb) 
132			n = transformFromClauseItem(pstate, n,
(gdb) 

Breakpoint 3, transformStmt (pstate=0x17a4ac8, parseTree=0x17a4540) at analyze.c:273
273		switch (nodeTag(parseTree))
(gdb) bt
#0  transformStmt (pstate=0x17a4ac8, parseTree=0x17a4540) at analyze.c:273
#1  0x000000000056e2c0 in parse_sub_analyze (parseTree=0x17a4540, parentParseState=0x17a48a8, parentCTE=0x0, locked_from_parent=0 '\000', resolve_unknowns=1 '\001') at analyze.c:172
#2  0x00000000005a49e8 in transformRangeSubselect (pstate=0x17a48a8, r=0x17a4698) at parse_clause.c:471
#3  0x00000000005a6279 in transformFromClauseItem (pstate=0x17a48a8, n=0x17a4698, top_rte=0x7ffe485cf168, top_rti=0x7ffe485cf164, namespace=0x7ffe485cf158) at parse_clause.c:1133
#4  0x00000000005a42d1 in transformFromClause (pstate=0x17a48a8, frmList=0x17a46e8) at parse_clause.c:132
#5  0x000000000056fd9b in transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1211
#6  0x000000000056e4d4 in transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:297
#7  0x000000000056e402 in transformOptionalSelectInto (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:242
#8  0x000000000056e2fd in transformTopLevelStmt (pstate=0x17a48a8, parseTree=0x17a4828) at analyze.c:192
#9  0x000000000056e175 in parse_analyze (parseTree=0x17a4828, sourceText=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0)
    at analyze.c:112
#10 0x0000000000813402 in pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, 
    queryEnv=0x0) at postgres.c:653
#11 0x00000000008139d2 in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1024
#12 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#13 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#14 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#15 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#16 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#17 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
292					SelectStmt *n = (SelectStmt *) parseTree;
(gdb) 
294					if (n->valuesLists)
(gdb) p *n
$6 = {type = T_SelectStmt, distinctClause = 0x0, intoClause = 0x0, targetList = 0x17a42b0, fromClause = 0x17a4368, whereClause = 0x17a4480, groupClause = 0x0, havingClause = 0x0, 
  windowClause = 0x0, valuesLists = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, lockingClause = 0x0, withClause = 0x0, op = SETOP_NONE, all = 0 '\000', larg = 0x0, 
  rarg = 0x0}
(gdb) n
296					else if (n->op == SETOP_NONE)
(gdb) 
297						result = transformSelectStmt(pstate, n);
(gdb) 

Breakpoint 6, transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1182
1182		Query	   *qry = makeNode(Query);
(gdb) 
1186		qry->commandType = CMD_SELECT;
(gdb) 
1189		if (stmt->withClause)
(gdb) 
1197		if (stmt->intoClause)
(gdb) 
1205		pstate->p_locking_clause = stmt->lockingClause;
(gdb) 
1208		pstate->p_windowdefs = stmt->windowClause;
(gdb) 
1211		transformFromClause(pstate, stmt->fromClause);
(gdb) 

Breakpoint 4, transformFromClause (pstate=0x17a4ac8, frmList=0x17a4368) at parse_clause.c:125
125		foreach(fl, frmList)
(gdb) 
127			Node	   *n = lfirst(fl);
(gdb) 
132			n = transformFromClauseItem(pstate, n,
(gdb) 
137			checkNameSpaceConflicts(pstate, pstate->p_namespace, namespace);
(gdb) p *n
$7 = {type = T_RangeTblRef}
(gdb) n
140			setNamespaceLateralState(namespace, true, true);
(gdb) 
142			pstate->p_joinlist = lappend(pstate->p_joinlist, n);
(gdb) 
143			pstate->p_namespace = list_concat(pstate->p_namespace, namespace);
(gdb) 
125		foreach(fl, frmList)
(gdb) 
152		setNamespaceLateralState(pstate->p_namespace, false, true);
(gdb) 
153	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1214
1214		qry->targetList = transformTargetList(pstate, stmt->targetList,
(gdb) 

Breakpoint 8, transformTargetList (pstate=0x17a4ac8, targetlist=0x17a42b0, exprKind=EXPR_KIND_SELECT_TARGET) at parse_target.c:134
134		List	   *p_target = NIL;
(gdb) 
142		expand_star = (exprKind != EXPR_KIND_UPDATE_SOURCE);
(gdb) 
144		foreach(o_target, targetlist)
(gdb) 
146			ResTarget  *res = (ResTarget *) lfirst(o_target);
(gdb) 
153			if (expand_star)
(gdb) pres
Undefined command: "pres".  Try "help".
(gdb) p*res
$8 = {type = T_ResTarget, name = 0x0, indirection = 0x0, val = 0x17a41a8, location = 22}
(gdb) n
155				if (IsA(res->val, ColumnRef))
(gdb) 
157					ColumnRef  *cref = (ColumnRef *) res->val;
(gdb) 
159					if (IsA(llast(cref->fields), A_Star))
(gdb) 
162						p_target = list_concat(p_target,
(gdb) 
166						continue;
(gdb) p p_target
$9 = (List *) 0x179f428
(gdb) p p_target->head
$10 = (ListCell *) 0x179f408
(gdb) p *p_target->head
$11 = {data = {ptr_value = 0x179f3b8, int_value = 24769464, oid_value = 24769464}, next = 0x179f4c0}
(gdb) n
144		foreach(o_target, targetlist)
(gdb) 
205		if (pstate->p_multiassign_exprs)
(gdb) p *p_target->head->next
$12 = {data = {ptr_value = 0x179f470, int_value = 24769648, oid_value = 24769648}, next = 0x0}
(gdb) n
212		return p_target;
(gdb) 
213	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1218
1218		markTargetListOrigins(pstate, qry->targetList);
(gdb) 
1221		qual = transformWhereClause(pstate, stmt->whereClause,
(gdb) p qry->targetLis
There is no member named targetLis.
(gdb) p qry->targetList
$13 = (List *) 0x179f428
(gdb) p *qry->targetList
$14 = {type = T_List, length = 2, head = 0x179f408, tail = 0x179f4c0}
(gdb) n

Breakpoint 9, transformWhereClause (pstate=0x17a4ac8, clause=0x17a4480, exprKind=EXPR_KIND_WHERE, constructName=0x9e8358 "WHERE") at parse_clause.c:1720
1720		if (clause == NULL)
(gdb) 
1723		qual = transformExpr(pstate, clause, exprKind);
(gdb) s
transformExpr (pstate=0x17a4ac8, expr=0x17a4480, exprKind=EXPR_KIND_WHERE) at parse_expr.c:153
153		sv_expr_kind = pstate->p_expr_kind;
(gdb) n
154		pstate->p_expr_kind = exprKind;
(gdb) 
156		result = transformExprRecurse(pstate, expr);
(gdb) s
transformExprRecurse (pstate=0x17a4ac8, expr=0x17a4480) at parse_expr.c:168
168		if (expr == NULL)
(gdb) n
172		check_stack_depth();
(gdb) 
174		switch (nodeTag(expr))
(gdb) 
212					A_Expr	   *a = (A_Expr *) expr;
(gdb) 
214					switch (a->kind)
(gdb) p *a
$15 = {type = T_A_Expr, kind = AEXPR_OP, name = 0x17a4510, lexpr = 0x17a43b0, rexpr = 0x17a4450, location = 44}
(gdb) n
217							result = transformAExprOp(pstate, a);
(gdb) s
transformAExprOp (pstate=0x17a4ac8, a=0x17a4480) at parse_expr.c:846
846		Node	   *lexpr = a->lexpr;
(gdb) n
847		Node	   *rexpr = a->rexpr;
(gdb) 
850		if (operator_precedence_warning)
(gdb) 
877		if (Transform_null_equals &&
(gdb) p rexpr
$16 = (Node *) 0x17a4450
(gdb) p rexpr->type
$17 = T_A_Const
(gdb) bt
#0  transformAExprOp (pstate=0x17a4ac8, a=0x17a4480) at parse_expr.c:877
#1  0x00000000005b09a6 in transformExprRecurse (pstate=0x17a4ac8, expr=0x17a4480) at parse_expr.c:217
#2  0x00000000005b06eb in transformExpr (pstate=0x17a4ac8, expr=0x17a4480, exprKind=EXPR_KIND_WHERE) at parse_expr.c:156
#3  0x00000000005a75a8 in transformWhereClause (pstate=0x17a4ac8, clause=0x17a4480, exprKind=EXPR_KIND_WHERE, constructName=0x9e8358 "WHERE") at parse_clause.c:1723
#4  0x000000000056fdf4 in transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1221
#5  0x000000000056e4d4 in transformStmt (pstate=0x17a4ac8, parseTree=0x17a4540) at analyze.c:297
#6  0x000000000056e2c0 in parse_sub_analyze (parseTree=0x17a4540, parentParseState=0x17a48a8, parentCTE=0x0, locked_from_parent=0 '\000', resolve_unknowns=1 '\001') at analyze.c:172
#7  0x00000000005a49e8 in transformRangeSubselect (pstate=0x17a48a8, r=0x17a4698) at parse_clause.c:471
#8  0x00000000005a6279 in transformFromClauseItem (pstate=0x17a48a8, n=0x17a4698, top_rte=0x7ffe485cf168, top_rti=0x7ffe485cf164, namespace=0x7ffe485cf158) at parse_clause.c:1133
#9  0x00000000005a42d1 in transformFromClause (pstate=0x17a48a8, frmList=0x17a46e8) at parse_clause.c:132
#10 0x000000000056fd9b in transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1211
#11 0x000000000056e4d4 in transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:297
#12 0x000000000056e402 in transformOptionalSelectInto (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:242
#13 0x000000000056e2fd in transformTopLevelStmt (pstate=0x17a48a8, parseTree=0x17a4828) at analyze.c:192
#14 0x000000000056e175 in parse_analyze (parseTree=0x17a4828, sourceText=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0)
    at analyze.c:112
#15 0x0000000000813402 in pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, 
    queryEnv=0x0) at postgres.c:653
#16 0x00000000008139d2 in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1024
#17 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#18 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#19 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#20 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#21 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#22 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) p operator_precedence_warning
$18 = 0 '\000'
(gdb) p Transform_null_equals
$19 = 0 '\000'
(gdb) n
895		else if (lexpr && IsA(lexpr, RowExpr) &&
(gdb) 
912		else if (lexpr && IsA(lexpr, RowExpr) &&
(gdb) 
928			Node	   *last_srf = pstate->p_last_srf;
(gdb) p lexpr->type
$20 = T_ColumnRef
(gdb) p (const Node*)lexpr->type
$21 = (const Node *) 0x14f
(gdb) p ((const Node*)lexpr)->type
$22 = T_ColumnRef
(gdb) p lexpr
$23 = (Node *) 0x17a43b0
(gdb) p rexpr
$24 = (Node *) 0x17a4450
(gdb) p rexpr->type
$25 = T_A_Const
(gdb) n
930			lexpr = transformExprRecurse(pstate, lexpr);
(gdb) s
transformExprRecurse (pstate=0x17a4ac8, expr=0x17a43b0) at parse_expr.c:168
168		if (expr == NULL)
(gdb) n
172		check_stack_depth();
(gdb) 
174		switch (nodeTag(expr))
(gdb) 
177				result = transformColumnRef(pstate, (ColumnRef *) expr);
(gdb) s
transformColumnRef (pstate=0x17a4ac8, cref=0x17a43b0) at parse_expr.c:510
510		Node	   *node = NULL;
(gdb) n
511		char	   *nspname = NULL;
(gdb) 
512		char	   *relname = NULL;
(gdb) 
513		char	   *colname = NULL;
(gdb) 
522		}			crerr = CRERR_NO_COLUMN;
(gdb) 
528		if (pstate->p_pre_columnref_hook != NULL)
(gdb) 
558		switch (list_length(cref->fields))
(gdb) p *cref
$26 = {type = T_ColumnRef, fields = 0x17a4420, location = 41}
(gdb) p cref->fileds
There is no member named fileds.
(gdb) p cref->fields
$27 = (List *) 0x17a4420
(gdb) p cref->fields.size()
Structure has no component named size.
(gdb) p cref->fields->size()
Structure has no component named size.
(gdb) n
562					Node	   *field1 = (Node *) linitial(cref->fields);
(gdb) 
565					colname = strVal(field1);
(gdb) 
568					node = colNameToVar(pstate, colname, false, cref->location);
(gdb) 
570					if (node == NULL)
(gdb) p colname
$28 = 0x17a4398 "id"
(gdb) p node
$29 = (Node *) 0x179f4e0
(gdb) p node->type
$30 = T_Var
(gdb) n
757		if (pstate->p_post_columnref_hook != NULL)
(gdb) 
775		if (node == NULL)
(gdb) 
803		return node;
(gdb) 
804	}
(gdb) 
transformExprRecurse (pstate=0x17a4ac8, expr=0x17a43b0) at parse_expr.c:178
178				break;
(gdb) 
379		return result;
(gdb) 
380	}
(gdb) 
transformAExprOp (pstate=0x17a4ac8, a=0x17a4480) at parse_expr.c:931
931			rexpr = transformExprRecurse(pstate, rexpr);
(gdb) s
transformExprRecurse (pstate=0x17a4ac8, expr=0x17a4450) at parse_expr.c:168
168		if (expr == NULL)
(gdb) n
172		check_stack_depth();
(gdb) 
174		switch (nodeTag(expr))
(gdb) 
186					A_Const    *con = (A_Const *) expr;
(gdb) 
187					Value	   *val = &con->val;
(gdb) 
189					result = (Node *) make_const(pstate, val, con->location);
(gdb) p val
$31 = (Value *) 0x17a4458
(gdb) p *val
$32 = {type = T_Integer, val = {ival = 10, str = 0xa <Address 0xa out of bounds>}}
(gdb) n
190					break;
(gdb) 
379		return result;
(gdb) 
380	}
(gdb) 
transformAExprOp (pstate=0x17a4ac8, a=0x17a4480) at parse_expr.c:933
933			result = (Node *) make_op(pstate,
(gdb) s
make_op (pstate=0x17a4ac8, opname=0x17a4510, ltree=0x179f4e0, rtree=0x179f560, last_srf=0x0, location=44) at parse_oper.c:759
759		if (rtree == NULL)
(gdb) nn
Undefined command: "nn".  Try "help".
(gdb) n
766		else if (ltree == NULL)
(gdb) 
776			ltypeId = exprType(ltree);
(gdb) 
777			rtypeId = exprType(rtree);
(gdb) 
778			tup = oper(pstate, opname, ltypeId, rtypeId, false, location);
(gdb) p ltypeId
$33 = 23
(gdb) p rtypeId
$34 = 23
(gdb) s
oper (pstate=0x17a4ac8, opname=0x17a4510, ltypeId=23, rtypeId=23, noError=0 '\000', location=44) at parse_oper.c:383
383		FuncDetailCode fdresult = FUNCDETAIL_NOTFOUND;
(gdb) n
384		HeapTuple	tup = NULL;
(gdb) p opname
$35 = (List *) 0x17a4510
(gdb) p *opname
$36 = {type = T_List, length = 1, head = 0x17a44f0, tail = 0x17a44f0}
(gdb) p *opname->head
$37 = {data = {ptr_value = 0x17a44d0, int_value = 24790224, oid_value = 24790224}, next = 0x0}
(gdb) n
389		key_ok = make_oper_cache_key(pstate, &key, opname, ltypeId, rtypeId, location);
(gdb) s
make_oper_cache_key (pstate=0x17a4ac8, key=0x7ffe485ceb60, opname=0x17a4510, ltypeId=23, rtypeId=23, location=44) at parse_oper.c:1037
1037		DeconstructQualifiedName(opname, &schemaname, &opername);
(gdb) n
1040		MemSet(key, 0, sizeof(OprCacheKey));
(gdb) 
1043		strlcpy(key->oprname, opername, NAMEDATALEN);
(gdb) p key->oprname
$38 = '\000' <repeats 63 times>
(gdb) p opername
$39 = 0xa55076 ">"
(gdb) n
1044		key->left_arg = ltypeId;
(gdb) p key->oprname
$40 = ">", '\000' <repeats 62 times>
(gdb) n
1045		key->right_arg = rtypeId;
(gdb) 
1047		if (schemaname)
(gdb) 
1059			if (fetch_search_path_array(key->search_path,
(gdb) 
1064		return true;
(gdb) 
1065	}
(gdb) 
oper (pstate=0x17a4ac8, opname=0x17a4510, ltypeId=23, rtypeId=23, noError=0 '\000', location=44) at parse_oper.c:391
391		if (key_ok)
(gdb) 
393			operOid = find_oper_cache_entry(&key);
(gdb) p key
$41 = {oprname = ">", '\000' <repeats 62 times>, left_arg = 23, right_arg = 23, search_path = {11, 2200, 0 <repeats 14 times>}}
(gdb) n
394			if (OidIsValid(operOid))
(gdb) p operOid
$42 = 0
(gdb) n
405		operOid = binary_oper_exact(opname, ltypeId, rtypeId);
(gdb) 
406		if (!OidIsValid(operOid))
(gdb) p operOid
$43 = 521
(gdb) n
435		if (OidIsValid(operOid))
(gdb) 
436			tup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operOid));
(gdb) 
438		if (HeapTupleIsValid(tup))
(gdb) p tup
$44 = (HeapTuple) 0x7f2750a1a550
(gdb) n
440			if (key_ok)
(gdb) 
441				make_oper_cache_entry(&key, operOid);
(gdb) 
446		return (Operator) tup;
(gdb) 
447	}
(gdb) 
make_op (pstate=0x17a4ac8, opname=0x17a4510, ltree=0x179f4e0, rtree=0x179f560, last_srf=0x0, location=44) at parse_oper.c:781
781		opform = (Form_pg_operator) GETSTRUCT(tup);
(gdb) p tup
$45 = (Operator) 0x7f2750a1a550
(gdb) p *tup
$46 = {t_len = 140, t_self = {ip_blkid = {bi_hi = 0, bi_lo = 1}, ip_posid = 31}, t_tableOid = 2617, t_data = 0x7f2750a1a5a8}
(gdb) n
784		if (!RegProcedureIsValid(opform->oprcode))
(gdb) p opform
$47 = (Form_pg_operator) 0x7f2750a1a5c8
(gdb) p *opform
$48 = {oprname = {data = ">", '\000' <repeats 62 times>}, oprnamespace = 11, oprowner = 10, oprkind = 98 'b', oprcanmerge = 0 '\000', oprcanhash = 0 '\000', oprleft = 23, oprright = 23, 
  oprresult = 16, oprcom = 97, oprnegate = 523, oprcode = 147, oprrest = 104, oprjoin = 108}
(gdb) n
795		if (rtree == NULL)
(gdb) 
803		else if (ltree == NULL)
(gdb) 
814			args = list_make2(ltree, rtree);
(gdb) 
815			actual_arg_types[0] = ltypeId;
(gdb) p args
$49 = (List *) 0x179f6d0
(gdb) p *args
$50 = {type = T_List, length = 2, head = 0x179f700, tail = 0x179f620}
(gdb) p *args->head
$51 = {data = {ptr_value = 0x179f4e0, int_value = 24769760, oid_value = 24769760}, next = 0x179f620}
(gdb) p *args->head->next
$52 = {data = {ptr_value = 0x179f560, int_value = 24769888, oid_value = 24769888}, next = 0x0}
(gdb) n
816			actual_arg_types[1] = rtypeId;
(gdb) 
817			declared_arg_types[0] = opform->oprleft;
(gdb) 
818			declared_arg_types[1] = opform->oprright;
(gdb) 
819			nargs = 2;
(gdb) p declared_arg_types
$53 = {23, 23}
(gdb) n
827		rettype = enforce_generic_type_consistency(actual_arg_types,
(gdb) 
834		make_fn_arguments(pstate, args, actual_arg_types, declared_arg_types);
(gdb) n
837		result = makeNode(OpExpr);
(gdb) 
838		result->opno = oprid(tup);
(gdb) 
839		result->opfuncid = opform->oprcode;
(gdb) 
840		result->opresulttype = rettype;
(gdb) 
841		result->opretset = get_func_retset(opform->oprcode);
(gdb) 
843		result->args = args;
(gdb) 
844		result->location = location;
(gdb) 
847		if (result->opretset)
(gdb) p result
$54 = (OpExpr *) 0x179f5b0
(gdb) p *result
$55 = {xpr = {type = T_OpExpr}, opno = 521, opfuncid = 147, opresulttype = 16, opretset = 0 '\000', opcollid = 0, inputcollid = 0, args = 0x179f6d0, location = 44}
(gdb) n
854		ReleaseSysCache(tup);
(gdb) 
856		return (Expr *) result;
(gdb) 
857	}
(gdb) 
transformAExprOp (pstate=0x17a4ac8, a=0x17a4480) at parse_expr.c:941
941		return result;
(gdb) p result
$56 = (Node *) 0x179f5b0
(gdb) n
942	}
(gdb) 
transformExprRecurse (pstate=0x17a4ac8, expr=0x17a4480) at parse_expr.c:218
218							break;
(gdb) 
258					break;
(gdb) 
379		return result;
(gdb) 
380	}
(gdb) 
transformExpr (pstate=0x17a4ac8, expr=0x17a4480, exprKind=EXPR_KIND_WHERE) at parse_expr.c:158
158		pstate->p_expr_kind = sv_expr_kind;
(gdb) 
160		return result;
(gdb) 
161	}
(gdb) 
transformWhereClause (pstate=0x17a4ac8, clause=0x17a4480, exprKind=EXPR_KIND_WHERE, constructName=0x9e8358 "WHERE") at parse_clause.c:1725
1725		qual = coerce_to_boolean(pstate, qual, constructName);
(gdb) p *pstate
$57 = {parentParseState = 0x17a48a8, p_sourcetext = 0x17a3648 "select * from (select * from test2 where id >10) as temp1;", p_rtable = 0x179f110, p_joinexprs = 0x0, p_joinlist = 0x179f1e8, 
  p_namespace = 0x179f180, p_lateral_active = 0 '\000', p_ctenamespace = 0x0, p_future_ctes = 0x0, p_parent_cte = 0x0, p_target_relation = 0x0, p_target_rangetblentry = 0x0, 
  p_is_insert = 0 '\000', p_windowdefs = 0x0, p_expr_kind = EXPR_KIND_NONE, p_next_resno = 3, p_multiassign_exprs = 0x0, p_locking_clause = 0x0, p_locked_from_parent = 0 '\000', 
  p_resolve_unknowns = 1 '\001', p_queryEnv = 0x0, p_hasAggs = 0 '\000', p_hasWindowFuncs = 0 '\000', p_hasTargetSRFs = 0 '\000', p_hasSubLinks = 0 '\000', p_hasModifyingCTE = 0 '\000', 
  p_last_srf = 0x0, p_pre_columnref_hook = 0x0, p_post_columnref_hook = 0x0, p_paramref_hook = 0x0, p_coerce_param_hook = 0x0, p_ref_hook_state = 0x0}
(gdb) s
coerce_to_boolean (pstate=0x17a4ac8, node=0x179f5b0, constructName=0x9e8358 "WHERE") at parse_coerce.c:1065
1065		Oid			inputTypeId = exprType(node);
(gdb) n
1067		if (inputTypeId != BOOLOID)
(gdb) 
1087		if (expression_returns_set(node))
(gdb) p inputTypeId
$58 = 16
(gdb) n
1095		return node;
(gdb) p node
$59 = (Node *) 0x179f5b0
(gdb) p node->type
$60 = T_OpExpr
(gdb) n
1096	}
(gdb) 
transformWhereClause (pstate=0x17a4ac8, clause=0x17a4480, exprKind=EXPR_KIND_WHERE, constructName=0x9e8358 "WHERE") at parse_clause.c:1727
1727		return qual;
(gdb) 
1728	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1225
1225		qry->havingQual = transformWhereClause(pstate, stmt->havingClause,
(gdb) 

Breakpoint 9, transformWhereClause (pstate=0x17a4ac8, clause=0x0, exprKind=EXPR_KIND_HAVING, constructName=0x9e8544 "HAVING") at parse_clause.c:1720
1720		if (clause == NULL)
(gdb) 
1721			return NULL;
(gdb) n
1728	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1234
1234		qry->sortClause = transformSortClause(pstate,
(gdb) 

Breakpoint 10, transformSortClause (pstate=0x17a4ac8, orderlist=0x0, targetlist=0x17a4c20, exprKind=EXPR_KIND_ORDER_BY, useSQL99=0 '\000') at parse_clause.c:2589
2589		List	   *sortlist = NIL;
(gdb) 
2592		foreach(olitem, orderlist)
(gdb) 
2608		return sortlist;
(gdb) 
2609	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1240
1240		qry->groupClause = transformGroupClause(pstate,
(gdb) 

Breakpoint 11, transformGroupClause (pstate=0x17a4ac8, grouplist=0x0, groupingSets=0x17a4c48, targetlist=0x17a4c20, sortClause=0x0, exprKind=EXPR_KIND_GROUP_BY, useSQL99=0 '\000')
    at parse_clause.c:2487
2487		List	   *result = NIL;
(gdb) 
2489		List	   *gsets = NIL;
(gdb) 
2491		bool		hasGroupingSets = false;
(gdb) 
2492		Bitmapset  *seen_local = NULL;
(gdb) 
2499		flat_grouplist = (List *) flatten_grouping_sets((Node *) grouplist,
(gdb) 
2509		if (flat_grouplist == NIL && hasGroupingSets)
(gdb) 
2516		foreach(gl, flat_grouplist)
(gdb) 
2566		if (groupingSets)
(gdb) 
2567			*groupingSets = gsets;
(gdb) p gsets
$61 = (List *) 0x0
(gdb) n
2569		return result;
(gdb) 
2570	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1248
1248		if (stmt->distinctClause == NIL)
(gdb) p qry->groupClause
$62 = (List *) 0x0
(gdb) n
1250			qry->distinctClause = NIL;
(gdb) 
1251			qry->hasDistinctOn = false;
(gdb) 
1273		qry->limitOffset = transformLimitClause(pstate, stmt->limitOffset,
(gdb) 
1275		qry->limitCount = transformLimitClause(pstate, stmt->limitCount,
(gdb) 
1279		qry->windowClause = transformWindowDefinitions(pstate,
(gdb) 
1284		if (pstate->p_resolve_unknowns)
(gdb) p qry
$63 = (Query *) 0x17a4bd8
(gdb) p *qry
$64 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 0 '\000', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x0, jointree = 0x0, targetList = 0x179f428, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, groupClause = 0x0, 
  groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, setOperations = 0x0, 
  constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 0}
(gdb) n
1285			resolveTargetListUnknowns(pstate, qry->targetList);
(gdb) p qry->targetList
$65 = (List *) 0x179f428
(gdb) p *qry->targetList
$66 = {type = T_List, length = 2, head = 0x179f408, tail = 0x179f4c0}
(gdb) n
1287		qry->rtable = pstate->p_rtable;
(gdb) 
1288		qry->jointree = makeFromExpr(pstate->p_joinlist, qual);
(gdb) p qry->rtable
$67 = (List *) 0x179f110
(gdb) p *qry->rtable
$68 = {type = T_List, length = 1, head = 0x179f0f0, tail = 0x179f0f0}
(gdb) s
makeFromExpr (fromlist=0x179f1e8, quals=0x179f5b0) at makefuncs.c:284
284		FromExpr   *f = makeNode(FromExpr);
(gdb) n
286		f->fromlist = fromlist;
(gdb) 
287		f->quals = quals;
(gdb) 
288		return f;
(gdb) p *f
$69 = {type = T_FromExpr, fromlist = 0x179f1e8, quals = 0x179f5b0}
(gdb) p fromlist
$70 = (List *) 0x179f1e8
(gdb) p *fromlist
$71 = {type = T_List, length = 1, head = 0x179f1c8, tail = 0x179f1c8}
(gdb) p *fromlist->head
$72 = {data = {ptr_value = 0x179f1b0, int_value = 24768944, oid_value = 24768944}, next = 0x0}
(gdb) n
289	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1290
1290		qry->hasSubLinks = pstate->p_hasSubLinks;
(gdb) 
1291		qry->hasWindowFuncs = pstate->p_hasWindowFuncs;
(gdb) 
1292		qry->hasTargetSRFs = pstate->p_hasTargetSRFs;
(gdb) 
1293		qry->hasAggs = pstate->p_hasAggs;
(gdb) 
1294		if (pstate->p_hasAggs || qry->groupClause || qry->groupingSets || qry->havingQual)
(gdb) 
1297		foreach(l, stmt->lockingClause)
(gdb) p stmt
$73 = (SelectStmt *) 0x17a4540
(gdb) p stmt->lockingClause 
$74 = (List *) 0x0
(gdb) n
1303		assign_query_collations(pstate, qry);
(gdb) s
assign_query_collations (pstate=0x17a4ac8, query=0x17a4bd8) at parse_collate.c:109
109		(void) query_tree_walker(query,
(gdb) s
query_tree_walker (query=0x17a4bd8, walker=0x5ad4b3 <assign_query_collations_walker>, context=0x17a4ac8, flags=10) at nodeFuncs.c:2253
2253		if (walker((Node *) query->targetList, context))
(gdb) s
assign_query_collations_walker (node=0x179f428, pstate=0x17a4ac8) at parse_collate.c:129
129		if (node == NULL)
(gdb) n
136		if (IsA(node, SetOperationStmt))
(gdb) p node->type
$75 = T_List
(gdb) n
139		if (IsA(node, List))
(gdb) 
140			assign_list_collations(pstate, (List *) node);
(gdb) s
assign_list_collations (pstate=0x17a4ac8, exprs=0x179f428) at parse_collate.c:159
159		foreach(lc, exprs)
(gdb) n
161			Node	   *node = (Node *) lfirst(lc);
(gdb) 
163			assign_expr_collations(pstate, node);
(gdb) p node->type
$76 = T_TargetEntry
(gdb) p (T_TargetEntry*)node
A syntax error in expression, near `)node'.
(gdb) p (T_TargetEntry)node
A syntax error in expression, near `node'.
(gdb) p (TargetEntry)node
$77 = {xpr = {type = 24769464}, expr = 0x179f408, resno = -4672, resname = 0x5ad505 <assign_query_collations_walker+82> "\353\023H\213U\370H\213E\360H\211\326H\211\307\350\\", 
  ressortgroupref = 24791752, resorigtbl = 0, resorigcol = -3032, resjunk = 121 'y'}
(gdb) p (TargetEntry*)node
$78 = (TargetEntry *) 0x179f3b8
(gdb) p *(TargetEntry*)node
$79 = {xpr = {type = T_TargetEntry}, expr = 0x17a4df8, resno = 1, resname = 0x179f218 "id", ressortgroupref = 0, resorigtbl = 41849, resorigcol = 1, resjunk = 0 '\000'}
(gdb) s
assign_expr_collations (pstate=0x17a4ac8, expr=0x179f3b8) at parse_collate.c:182
182		context.pstate = pstate;
(gdb) n
183		context.collation = InvalidOid;
(gdb) 
184		context.strength = COLLATE_NONE;
(gdb) 
185		context.location = -1;
(gdb) 
188		(void) assign_collations_walker(expr, &context);
(gdb) s
assign_collations_walker (node=0x179f3b8, context=0x7ffe485ced50) at parse_collate.c:263
263		if (node == NULL)
(gdb) n
271		loccontext.pstate = context->pstate;
(gdb) 
272		loccontext.collation = InvalidOid;
(gdb) 
273		loccontext.strength = COLLATE_NONE;
(gdb) 
274		loccontext.location = -1;
(gdb) 
276		loccontext.collation2 = InvalidOid;
(gdb) 
277		loccontext.location2 = -1;
(gdb) 
285		switch (nodeTag(node))
(gdb) 
445				(void) expression_tree_walker(node,
(gdb) s
expression_tree_walker (node=0x179f3b8, walker=0x5ad6c1 <assign_collations_walker>, context=0x7ffe485cec40) at nodeFuncs.c:1857
1857		if (node == NULL)
(gdb) n
1861		check_stack_depth();
(gdb) 
1863		switch (nodeTag(node))
(gdb) 
2088				return walker(((TargetEntry *) node)->expr, context);
(gdb) s
assign_collations_walker (node=0x17a4df8, context=0x7ffe485cec40) at parse_collate.c:263
263		if (node == NULL)
(gdb) n
271		loccontext.pstate = context->pstate;
(gdb) 
272		loccontext.collation = InvalidOid;
(gdb) 
273		loccontext.strength = COLLATE_NONE;
(gdb) 
274		loccontext.location = -1;
(gdb) 
276		loccontext.collation2 = InvalidOid;
(gdb) 
277		loccontext.location2 = -1;
(gdb) 
285		switch (nodeTag(node))
(gdb) 
555				collation = exprCollation(node);
(gdb) p node->type
$80 = T_Var
(gdb) p *(Var*)node
$81 = {xpr = {type = T_Var}, varno = 1, varattno = 1, vartype = 23, vartypmod = -1, varcollid = 0, varlevelsup = 0, varnoold = 1, varoattno = 1, location = 22}
(gdb) s
exprCollation (expr=0x17a4df8) at nodeFuncs.c:724
724		if (!expr)
(gdb) n
727		switch (nodeTag(expr))
(gdb) 
730				coll = ((const Var *) expr)->varcollid;
(gdb) 
731				break;
(gdb) p coll
$82 = 0
(gdb) n
911		return coll;
(gdb) 
912	}
(gdb) 
assign_collations_walker (node=0x17a4df8, context=0x7ffe485cec40) at parse_collate.c:566
566				if (OidIsValid(collation))
(gdb) 
569					strength = COLLATE_NONE;
(gdb) 
570				location = exprLocation(node);
(gdb) 
571				break;
(gdb) p location
$83 = 22
(gdb) n
742		merge_collation_state(collation,
(gdb) 
749		return false;
(gdb) p collation
$84 = 0
(gdb) s
750	}
(gdb) n
expression_tree_walker (node=0x179f3b8, walker=0x5ad6c1 <assign_collations_walker>, context=0x7ffe485cec40) at nodeFuncs.c:2228
2228	}
(gdb) 
assign_collations_walker (node=0x179f3b8, context=0x7ffe485ced50) at parse_collate.c:454
454				collation = loccontext.collation;
(gdb) 
455				strength = loccontext.strength;
(gdb) 
456				location = loccontext.location;
(gdb) 
471				if (strength == COLLATE_CONFLICT &&
(gdb) 
481				break;
(gdb) p strength
$85 = COLLATE_NONE
(gdb) n
742		merge_collation_state(collation,
(gdb) 
749		return false;
(gdb) 
750	}
(gdb) 
assign_expr_collations (pstate=0x17a4ac8, expr=0x179f3b8) at parse_collate.c:189
189	}
(gdb) 
assign_list_collations (pstate=0x17a4ac8, exprs=0x179f428) at parse_collate.c:159
159		foreach(lc, exprs)
(gdb) 
161			Node	   *node = (Node *) lfirst(lc);
(gdb) 
163			assign_expr_collations(pstate, node);
(gdb) p node->type
$86 = T_TargetEntry
(gdb) s
assign_expr_collations (pstate=0x17a4ac8, expr=0x179f470) at parse_collate.c:182
182		context.pstate = pstate;
(gdb) n
183		context.collation = InvalidOid;
(gdb) 
184		context.strength = COLLATE_NONE;
(gdb) 
185		context.location = -1;
(gdb) 
188		(void) assign_collations_walker(expr, &context);
(gdb) s
assign_collations_walker (node=0x179f470, context=0x7ffe485ced50) at parse_collate.c:263
263		if (node == NULL)
(gdb) n
271		loccontext.pstate = context->pstate;
(gdb) 
272		loccontext.collation = InvalidOid;
(gdb) 
273		loccontext.strength = COLLATE_NONE;
(gdb) 
274		loccontext.location = -1;
(gdb) 
276		loccontext.collation2 = InvalidOid;
(gdb) 
277		loccontext.location2 = -1;
(gdb) 
285		switch (nodeTag(node))
(gdb) 
445				(void) expression_tree_walker(node,
(gdb) s
expression_tree_walker (node=0x179f470, walker=0x5ad6c1 <assign_collations_walker>, context=0x7ffe485cec40) at nodeFuncs.c:1857
1857		if (node == NULL)
(gdb) n
1861		check_stack_depth();
(gdb) 
1863		switch (nodeTag(node))
(gdb) 
2088				return walker(((TargetEntry *) node)->expr, context);
(gdb) s
assign_collations_walker (node=0x179f348, context=0x7ffe485cec40) at parse_collate.c:263
263		if (node == NULL)
(gdb) n
271		loccontext.pstate = context->pstate;
(gdb) 
272		loccontext.collation = InvalidOid;
(gdb) 
273		loccontext.strength = COLLATE_NONE;
(gdb) 
274		loccontext.location = -1;
(gdb) 
276		loccontext.collation2 = InvalidOid;
(gdb) 
277		loccontext.location2 = -1;
(gdb) 
285		switch (nodeTag(node))
(gdb) 
555				collation = exprCollation(node);
(gdb) p node->type
$87 = T_Var
(gdb) n
566				if (OidIsValid(collation))
(gdb) 
569					strength = COLLATE_NONE;
(gdb) p collation
$88 = 0
(gdb) n
570				location = exprLocation(node);
(gdb) 
571				break;
(gdb) p collation
$89 = 0
(gdb) n
742		merge_collation_state(collation,
(gdb) 
749		return false;
(gdb) 
750	}
(gdb) 
expression_tree_walker (node=0x179f470, walker=0x5ad6c1 <assign_collations_walker>, context=0x7ffe485cec40) at nodeFuncs.c:2228
2228	}
(gdb) 
assign_collations_walker (node=0x179f470, context=0x7ffe485ced50) at parse_collate.c:454
454				collation = loccontext.collation;
(gdb) 
455				strength = loccontext.strength;
(gdb) 
456				location = loccontext.location;
(gdb) 
471				if (strength == COLLATE_CONFLICT &&
(gdb) 
481				break;
(gdb) 
742		merge_collation_state(collation,
(gdb) 
749		return false;
(gdb) 
750	}
(gdb) 
assign_expr_collations (pstate=0x17a4ac8, expr=0x179f470) at parse_collate.c:189
189	}
(gdb) 
assign_list_collations (pstate=0x17a4ac8, exprs=0x179f428) at parse_collate.c:159
159		foreach(lc, exprs)
(gdb) 
165	}
(gdb) 
assign_query_collations_walker (node=0x179f428, pstate=0x17a4ac8) at parse_collate.c:144
144		return false;
(gdb) p exprs
No symbol "exprs" in current context.
(gdb) p node
$90 = (Node *) 0x179f428
(gdb) p node->head
There is no member named head.
(gdb) p *node->head
There is no member named head.
(gdb) n
145	}
(gdb) 
query_tree_walker (query=0x17a4bd8, walker=0x5ad4b3 <assign_query_collations_walker>, context=0x17a4ac8, flags=10) at nodeFuncs.c:2255
2255		if (walker((Node *) query->withCheckOptions, context))
(gdb) 
2257		if (walker((Node *) query->onConflict, context))
(gdb) 
2259		if (walker((Node *) query->returningList, context))
(gdb) p query
$91 = (Query *) 0x17a4bd8
(gdb) p *query
$92 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 0 '\000', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f110, jointree = 0x179f770, targetList = 0x179f428, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 0}
(gdb) n
2261		if (walker((Node *) query->jointree, context))
(gdb) s
assign_query_collations_walker (node=0x179f770, pstate=0x17a4ac8) at parse_collate.c:129
129		if (node == NULL)
(gdb) n
136		if (IsA(node, SetOperationStmt))
(gdb) 
139		if (IsA(node, List))
(gdb) 
142			assign_expr_collations(pstate, node);
(gdb) s
assign_expr_collations (pstate=0x17a4ac8, expr=0x179f770) at parse_collate.c:182
182		context.pstate = pstate;
(gdb) n
183		context.collation = InvalidOid;
(gdb) 
184		context.strength = COLLATE_NONE;
(gdb) 
185		context.location = -1;
(gdb) 
188		(void) assign_collations_walker(expr, &context);
(gdb) 
189	}
(gdb) 
assign_query_collations_walker (node=0x179f770, pstate=0x17a4ac8) at parse_collate.c:144
144		return false;
(gdb) 
145	}
(gdb) 
query_tree_walker (query=0x17a4bd8, walker=0x5ad4b3 <assign_query_collations_walker>, context=0x17a4ac8, flags=10) at nodeFuncs.c:2263
2263		if (walker(query->setOperations, context))
(gdb) 
2265		if (walker(query->havingQual, context))
(gdb) 
2267		if (walker(query->limitOffset, context))
(gdb) 
2269		if (walker(query->limitCount, context))
(gdb) 
2271		if (!(flags & QTW_IGNORE_CTE_SUBQUERIES))
(gdb) 
2276		if (!(flags & QTW_IGNORE_RANGE_TABLE))
(gdb) 
2281		return false;
(gdb) 
2282	}
(gdb) 
assign_query_collations (pstate=0x17a4ac8, query=0x17a4bd8) at parse_collate.c:114
114	}
(gdb) 
transformSelectStmt (pstate=0x17a4ac8, stmt=0x17a4540) at analyze.c:1305
1305		return qry;
(gdb) 
1306	}
(gdb) 
transformStmt (pstate=0x17a4ac8, parseTree=0x17a4540) at analyze.c:334
334		result->querySource = QSRC_ORIGINAL;
(gdb) 
335		result->canSetTag = true;
(gdb) 
337		return result;
(gdb) p result
$93 = (Query *) 0x17a4bd8
(gdb) p *result
$94 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f110, jointree = 0x179f770, targetList = 0x179f428, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 0}
(gdb) n
338	}
(gdb) 
parse_sub_analyze (parseTree=0x17a4540, parentParseState=0x17a48a8, parentCTE=0x0, locked_from_parent=0 '\000', resolve_unknowns=1 '\001') at analyze.c:174
174		free_parsestate(pstate);
(gdb) bt
#0  parse_sub_analyze (parseTree=0x17a4540, parentParseState=0x17a48a8, parentCTE=0x0, locked_from_parent=0 '\000', resolve_unknowns=1 '\001') at analyze.c:174
#1  0x00000000005a49e8 in transformRangeSubselect (pstate=0x17a48a8, r=0x17a4698) at parse_clause.c:471
#2  0x00000000005a6279 in transformFromClauseItem (pstate=0x17a48a8, n=0x17a4698, top_rte=0x7ffe485cf168, top_rti=0x7ffe485cf164, namespace=0x7ffe485cf158) at parse_clause.c:1133
#3  0x00000000005a42d1 in transformFromClause (pstate=0x17a48a8, frmList=0x17a46e8) at parse_clause.c:132
#4  0x000000000056fd9b in transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1211
#5  0x000000000056e4d4 in transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:297
#6  0x000000000056e402 in transformOptionalSelectInto (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:242
#7  0x000000000056e2fd in transformTopLevelStmt (pstate=0x17a48a8, parseTree=0x17a4828) at analyze.c:192
#8  0x000000000056e175 in parse_analyze (parseTree=0x17a4828, sourceText=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0)
    at analyze.c:112
#9  0x0000000000813402 in pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, 
    queryEnv=0x0) at postgres.c:653
#10 0x00000000008139d2 in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1024
#11 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#12 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#13 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#14 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#15 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#16 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
176		return query;
(gdb) 
177	}
(gdb) 
transformRangeSubselect (pstate=0x17a48a8, r=0x17a4698) at parse_clause.c:476
476		pstate->p_lateral_active = false;
(gdb) 
477		pstate->p_expr_kind = EXPR_KIND_NONE;
(gdb) 
483		if (!IsA(query, Query) ||
(gdb) p query->type
$95 = T_Query
(gdb) n
484			query->commandType != CMD_SELECT)
(gdb) 
483		if (!IsA(query, Query) ||
(gdb) 
493											r->lateral,
(gdb) 
490		rte = addRangeTableEntryForSubquery(pstate,
(gdb) s
addRangeTableEntryForSubquery (pstate=0x17a48a8, subquery=0x17a4bd8, alias=0x17a4668, lateral=0 '\000', inFromCl=1 '\001') at parse_relation.c:1328
1328		RangeTblEntry *rte = makeNode(RangeTblEntry);
(gdb) n
1329		char	   *refname = alias->aliasname;
(gdb) 
1337		rte->rtekind = RTE_SUBQUERY;
(gdb) p refname
$96 = 0x17a4650 "temp1"
(gdb) n
1338		rte->relid = InvalidOid;
(gdb) 
1339		rte->subquery = subquery;
(gdb) 
1340		rte->alias = alias;
(gdb) 
1342		eref = copyObject(alias);
(gdb) 
1343		numaliases = list_length(eref->colnames);
(gdb) 
1346		varattno = 0;
(gdb) 
1347		foreach(tlistitem, subquery->targetList)
(gdb) 
1349			TargetEntry *te = (TargetEntry *) lfirst(tlistitem);
(gdb) 
1351			if (te->resjunk)
(gdb) p te
$97 = (TargetEntry *) 0x179f3b8
(gdb) p *te
$98 = {xpr = {type = T_TargetEntry}, expr = 0x17a4df8, resno = 1, resname = 0x179f218 "id", ressortgroupref = 0, resorigtbl = 41849, resorigcol = 1, resjunk = 0 '\000'}
(gdb) n
1353			varattno++;
(gdb) 
1355			if (varattno > numaliases)
(gdb) 
1359				attrname = pstrdup(te->resname);
(gdb) 
1360				eref->colnames = lappend(eref->colnames, makeString(attrname));
(gdb) p attrname
$99 = 0x179f7e8 "id"
(gdb) n
1347		foreach(tlistitem, subquery->targetList)
(gdb) 
1349			TargetEntry *te = (TargetEntry *) lfirst(tlistitem);
(gdb) 
1351			if (te->resjunk)
(gdb) p *te
$100 = {xpr = {type = T_TargetEntry}, expr = 0x179f348, resno = 2, resname = 0x179f2f0 "name", ressortgroupref = 0, resorigtbl = 41849, resorigcol = 2, resjunk = 0 '\000'}
(gdb) n
1353			varattno++;
(gdb) 
1355			if (varattno > numaliases)
(gdb) 
1359				attrname = pstrdup(te->resname);
(gdb) 
1360				eref->colnames = lappend(eref->colnames, makeString(attrname));
(gdb) 
1347		foreach(tlistitem, subquery->targetList)
(gdb) 
1363		if (varattno < numaliases)
(gdb) 
1369		rte->eref = eref;
(gdb) 
1376		rte->lateral = lateral;
(gdb) 
1377		rte->inh = false;			/* never true for subqueries */
(gdb) 
1378		rte->inFromCl = inFromCl;
(gdb) 
1380		rte->requiredPerms = 0;
(gdb) p inFromCl
$101 = 1 '\001'
(gdb) n
1381		rte->checkAsUser = InvalidOid;
(gdb) 
1382		rte->selectedCols = NULL;
(gdb) 
1383		rte->insertedCols = NULL;
(gdb) 
1384		rte->updatedCols = NULL;
(gdb) 
1390		pstate->p_rtable = lappend(pstate->p_rtable, rte);
(gdb) p pstate->p_rtable
$102 = (List *) 0x0
(gdb) p *rte
$103 = {type = T_RangeTblEntry, rtekind = RTE_SUBQUERY, relid = 0, relkind = 0 '\000', tablesample = 0x0, subquery = 0x17a4bd8, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x17a4668, eref = 0x179f7a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 0, 
  checkAsUser = 0, selectedCols = 0x0, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
1392		return rte;
(gdb) 
1393	}
(gdb) 
transformRangeSubselect (pstate=0x17a48a8, r=0x17a4698) at parse_clause.c:496
496		return rte;
(gdb) bt
#0  transformRangeSubselect (pstate=0x17a48a8, r=0x17a4698) at parse_clause.c:496
#1  0x00000000005a6279 in transformFromClauseItem (pstate=0x17a48a8, n=0x17a4698, top_rte=0x7ffe485cf168, top_rti=0x7ffe485cf164, namespace=0x7ffe485cf158) at parse_clause.c:1133
#2  0x00000000005a42d1 in transformFromClause (pstate=0x17a48a8, frmList=0x17a46e8) at parse_clause.c:132
#3  0x000000000056fd9b in transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1211
#4  0x000000000056e4d4 in transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:297
#5  0x000000000056e402 in transformOptionalSelectInto (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:242
#6  0x000000000056e2fd in transformTopLevelStmt (pstate=0x17a48a8, parseTree=0x17a4828) at analyze.c:192
#7  0x000000000056e175 in parse_analyze (parseTree=0x17a4828, sourceText=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0)
    at analyze.c:112
#8  0x0000000000813402 in pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, 
    queryEnv=0x0) at postgres.c:653
#9  0x00000000008139d2 in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1024
#10 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#11 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#12 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#13 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#14 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#15 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
497	}
(gdb) 
transformFromClauseItem (pstate=0x17a48a8, n=0x17a4698, top_rte=0x7ffe485cf168, top_rti=0x7ffe485cf164, namespace=0x7ffe485cf158) at parse_clause.c:1135
1135			rtindex = list_length(pstate->p_rtable);
(gdb) 
1137			*top_rte = rte;
(gdb) 
1138			*top_rti = rtindex;
(gdb) 
1139			*namespace = list_make1(makeDefaultNSItem(rte));
(gdb) 
1140			rtr = makeNode(RangeTblRef);
(gdb) 
1141			rtr->rtindex = rtindex;
(gdb) 
1142			return (Node *) rtr;
(gdb) p &rtr
$104 = (RangeTblRef **) 0x7ffe485cf068
(gdb) p *rtr
$105 = {type = T_RangeTblRef, rtindex = 1}
(gdb) n
1531	}
(gdb) 
transformFromClause (pstate=0x17a48a8, frmList=0x17a46e8) at parse_clause.c:137
137			checkNameSpaceConflicts(pstate, pstate->p_namespace, namespace);
(gdb) 
140			setNamespaceLateralState(namespace, true, true);
(gdb) 
142			pstate->p_joinlist = lappend(pstate->p_joinlist, n);
(gdb) 
143			pstate->p_namespace = list_concat(pstate->p_namespace, namespace);
(gdb) p *n
$106 = {type = T_RangeTblRef}
(gdb) p *(const RangeTblRef*)n
$107 = {type = T_RangeTblRef, rtindex = 1}
(gdb) n
125		foreach(fl, frmList)
(gdb) 
152		setNamespaceLateralState(pstate->p_namespace, false, true);
(gdb) 
153	}
(gdb) 
transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1214
1214		qry->targetList = transformTargetList(pstate, stmt->targetList,
(gdb) s

Breakpoint 8, transformTargetList (pstate=0x17a48a8, targetlist=0x17a4178, exprKind=EXPR_KIND_SELECT_TARGET) at parse_target.c:134
134		List	   *p_target = NIL;
(gdb) n
142		expand_star = (exprKind != EXPR_KIND_UPDATE_SOURCE);
(gdb) 
144		foreach(o_target, targetlist)
(gdb) 
146			ResTarget  *res = (ResTarget *) lfirst(o_target);
(gdb) 
153			if (expand_star)
(gdb) p *res
$108 = {type = T_ResTarget, name = 0x0, indirection = 0x0, val = 0x17a4070, location = 7}
(gdb) n
155				if (IsA(res->val, ColumnRef))
(gdb) p *res->val->type
Attempt to take contents of a non-pointer value.
(gdb) p res->val->type
$109 = T_ColumnRef
(gdb) n
157					ColumnRef  *cref = (ColumnRef *) res->val;
(gdb) 
159					if (IsA(llast(cref->fields), A_Star))
(gdb) p *cref
$110 = {type = T_ColumnRef, fields = 0x17a40d8, location = 7}
(gdb) p *cref->fields
$111 = {type = T_List, length = 1, head = 0x17a40b8, tail = 0x17a40b8}
(gdb) p *cref->fields->head
$112 = {data = {ptr_value = 0x17a40a0, int_value = 24789152, oid_value = 24789152}, next = 0x0}
(gdb) p *cref->fields->head->type
There is no member named type.
(gdb) p cref->fields->head->type
There is no member named type.
(gdb) p (const Node*)(cref->fields->head)->type
There is no member named type.
(gdb) p ((const Node*)(cref->fields->head))->type
$113 = 24789152
(gdb) n
162						p_target = list_concat(p_target,
(gdb) s
ExpandColumnRefStar (pstate=0x17a48a8, cref=0x17a4070, make_target_entry=1 '\001') at parse_target.c:1058
1058		List	   *fields = cref->fields;
(gdb) n
1059		int			numnames = list_length(fields);
(gdb) 
1061		if (numnames == 1)
(gdb) p numnames
$114 = 1
(gdb) n
1072			return ExpandAllTables(pstate, cref->location);
(gdb) s
ExpandAllTables (pstate=0x17a48a8, location=7) at parse_target.c:1227
1227		List	   *target = NIL;
(gdb) n
1228		bool		found_table = false;
(gdb) 
1231		foreach(l, pstate->p_namespace)
(gdb) 
1233			ParseNamespaceItem *nsitem = (ParseNamespaceItem *) lfirst(l);
(gdb) 
1234			RangeTblEntry *rte = nsitem->p_rte;
(gdb) p*nsitem
$115 = {p_rte = 0x17a4ac8, p_rel_visible = 1 '\001', p_cols_visible = 1 '\001', p_lateral_only = 0 '\000', p_lateral_ok = 1 '\001'}
(gdb) n
1237			if (!nsitem->p_cols_visible)
(gdb) p *rte
$116 = {type = T_RangeTblEntry, rtekind = RTE_SUBQUERY, relid = 0, relkind = 0 '\000', tablesample = 0x0, subquery = 0x17a4bd8, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x17a4668, eref = 0x179f7a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 0, 
  checkAsUser = 0, selectedCols = 0x0, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
1242			found_table = true;
(gdb) 
1244			target = list_concat(target,
(gdb) s
RTERangeTablePosn (pstate=0x17a48a8, rte=0x17a4ac8, sublevels_up=0x0) at parse_relation.c:468
468		if (sublevels_up)
(gdb) n
473			index = 1;
(gdb) 
474			foreach(l, pstate->p_rtable)
(gdb) 
476				if (rte == (RangeTblEntry *) lfirst(l))
(gdb) p l
$117 = (ListCell *) 0x179f8c8
(gdb) p (RangeTalEntry*)l
No symbol "RangeTalEntry" in current context.
(gdb) p (RangeTblEntry *) l
$118 = (RangeTblEntry *) 0x179f8c8
(gdb) p *(RangeTblEntry *) l
$119 = {type = 24791752, rtekind = RTE_RELATION, relid = 0, relkind = 0 '\000', tablesample = 0x20, subquery = 0x16f6dc8, security_barrier = -39 '\331', jointype = JOIN_LEFT, 
  joinaliasvars = 0x179f8c8, functions = 0x179f8c8, funcordinality = 0 '\000', tablefunc = 0x10, values_lists = 0x16f6dc8, ctename = 0x17a4ac8 "g\001", ctelevelsup = 16777473, 
  self_reference = 0 '\000', coltypes = 0x10, coltypmods = 0x16f6dc8, colcollations = 0x179f918, enrname = 0x0, enrtuples = 1.5810100666919889e-322, alias = 0x16f6dc8, eref = 0x1000000d9, 
  lateral = 56 '8', inh = -7 '\371', inFromCl = 121 'y', requiredPerms = 0, checkAsUser = 24770872, selectedCols = 0x0, insertedCols = 0x8, updatedCols = 0x16f6dc8, 
  securityQuals = 0x10000008e}
(gdb) n
477					return index;
(gdb) bt
#0  RTERangeTablePosn (pstate=0x17a48a8, rte=0x17a4ac8, sublevels_up=0x0) at parse_relation.c:477
#1  0x00000000005c5c2d in ExpandAllTables (pstate=0x17a48a8, location=7) at parse_target.c:1244
#2  0x00000000005c5797 in ExpandColumnRefStar (pstate=0x17a48a8, cref=0x17a4070, make_target_entry=1 '\001') at parse_target.c:1072
#3  0x00000000005c4049 in transformTargetList (pstate=0x17a48a8, targetlist=0x17a4178, exprKind=EXPR_KIND_SELECT_TARGET) at parse_target.c:162
#4  0x000000000056fdb7 in transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1214
#5  0x000000000056e4d4 in transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:297
#6  0x000000000056e402 in transformOptionalSelectInto (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:242
#7  0x000000000056e2fd in transformTopLevelStmt (pstate=0x17a48a8, parseTree=0x17a4828) at analyze.c:192
#8  0x000000000056e175 in parse_analyze (parseTree=0x17a4828, sourceText=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0)
    at analyze.c:112
#9  0x0000000000813402 in pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, 
    queryEnv=0x0) at postgres.c:653
#10 0x00000000008139d2 in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1024
#11 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#12 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#13 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#14 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#15 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#16 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) p *ret
No symbol "ret" in current context.
(gdb) p *rte
$120 = {type = T_RangeTblEntry, rtekind = RTE_SUBQUERY, relid = 0, relkind = 0 '\000', tablesample = 0x0, subquery = 0x17a4bd8, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x17a4668, eref = 0x179f7a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 0, 
  checkAsUser = 0, selectedCols = 0x0, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
489	}
(gdb) 
ExpandAllTables (pstate=0x17a48a8, location=7) at parse_target.c:1231
1231		foreach(l, pstate->p_namespace)
(gdb) 
1258		if (!found_table)
(gdb) p pstate->p_rtable
$121 = (List *) 0x179f8e8
(gdb) p *pstate->p_rtable
$122 = {type = T_List, length = 1, head = 0x179f8c8, tail = 0x179f8c8}
(gdb) p *(RangeTblEntry*)(pstate->p_rtable->head)
$123 = {type = 24791752, rtekind = RTE_RELATION, relid = 0, relkind = 0 '\000', tablesample = 0x20, subquery = 0x16f6dc8, security_barrier = -39 '\331', jointype = JOIN_LEFT, 
  joinaliasvars = 0x179f8c8, functions = 0x179f8c8, funcordinality = 0 '\000', tablefunc = 0x10, values_lists = 0x16f6dc8, ctename = 0x17a4ac8 "g\001", ctelevelsup = 16777473, 
  self_reference = 0 '\000', coltypes = 0x10, coltypmods = 0x16f6dc8, colcollations = 0x179f918, enrname = 0x0, enrtuples = 1.5810100666919889e-322, alias = 0x16f6dc8, eref = 0x1000000d9, 
  lateral = 56 '8', inh = -7 '\371', inFromCl = 121 'y', requiredPerms = 0, checkAsUser = 24770872, selectedCols = 0x0, insertedCols = 0x8, updatedCols = 0x16f6dc8, 
  securityQuals = 0x10000008e}
(gdb) n
1264		return target;
(gdb) p *(TargetEntry*)(target->head)
$124 = {xpr = {type = 24771472}, expr = 0x179fc80, resno = 32, resname = 0x16f6dc8 <incomplete sequence \321>, ressortgroupref = 217, resorigtbl = 2, resorigcol = -1056, resjunk = 121 'y'}
(gdb) p target
$125 = (List *) 0x179fc00
(gdb) p *target
$126 = {type = T_List, length = 2, head = 0x179fbe0, tail = 0x179fc80}
(gdb) n
1265	}
(gdb) 
ExpandColumnRefStar (pstate=0x17a48a8, cref=0x17a4070, make_target_entry=1 '\001') at parse_target.c:1211
1211	}
(gdb) 
transformTargetList (pstate=0x17a48a8, targetlist=0x17a4178, exprKind=EXPR_KIND_SELECT_TARGET) at parse_target.c:166
166						continue;
(gdb) n
144		foreach(o_target, targetlist)
(gdb) 
205		if (pstate->p_multiassign_exprs)
(gdb) 
212		return p_target;
(gdb) 
213	}
(gdb) 
transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1218
1218		markTargetListOrigins(pstate, qry->targetList);
(gdb) 
1221		qual = transformWhereClause(pstate, stmt->whereClause,
(gdb) 

Breakpoint 9, transformWhereClause (pstate=0x17a48a8, clause=0x0, exprKind=EXPR_KIND_WHERE, constructName=0x9e8358 "WHERE") at parse_clause.c:1720
1720		if (clause == NULL)
(gdb) 
1721			return NULL;
(gdb) 
1728	}
(gdb) 
transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1225
1225		qry->havingQual = transformWhereClause(pstate, stmt->havingClause,
(gdb) 

Breakpoint 9, transformWhereClause (pstate=0x17a48a8, clause=0x0, exprKind=EXPR_KIND_HAVING, constructName=0x9e8544 "HAVING") at parse_clause.c:1720
1720		if (clause == NULL)
(gdb) 
1721			return NULL;
(gdb) 
1728	}
(gdb) 
transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1234
1234		qry->sortClause = transformSortClause(pstate,
(gdb) 

Breakpoint 10, transformSortClause (pstate=0x17a48a8, orderlist=0x0, targetlist=0x17a4a00, exprKind=EXPR_KIND_ORDER_BY, useSQL99=0 '\000') at parse_clause.c:2589
2589		List	   *sortlist = NIL;
(gdb) 
2592		foreach(olitem, orderlist)
(gdb) 
2608		return sortlist;
(gdb) 
2609	}
(gdb) 
transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1240
1240		qry->groupClause = transformGroupClause(pstate,
(gdb) 

Breakpoint 11, transformGroupClause (pstate=0x17a48a8, grouplist=0x0, groupingSets=0x17a4a28, targetlist=0x17a4a00, sortClause=0x0, exprKind=EXPR_KIND_GROUP_BY, useSQL99=0 '\000')
    at parse_clause.c:2487
2487		List	   *result = NIL;
(gdb) 
2489		List	   *gsets = NIL;
(gdb) 
2491		bool		hasGroupingSets = false;
(gdb) 
2492		Bitmapset  *seen_local = NULL;
(gdb) 
2499		flat_grouplist = (List *) flatten_grouping_sets((Node *) grouplist,
(gdb) 
2509		if (flat_grouplist == NIL && hasGroupingSets)
(gdb) 
2516		foreach(gl, flat_grouplist)
(gdb) 
2566		if (groupingSets)
(gdb) 
2567			*groupingSets = gsets;
(gdb) 
2569		return result;
(gdb) 
2570	}
(gdb) 
transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1248
1248		if (stmt->distinctClause == NIL)
(gdb) 
1250			qry->distinctClause = NIL;
(gdb) 
1251			qry->hasDistinctOn = false;
(gdb) 
1273		qry->limitOffset = transformLimitClause(pstate, stmt->limitOffset,
(gdb) 
1275		qry->limitCount = transformLimitClause(pstate, stmt->limitCount,
(gdb) 
1279		qry->windowClause = transformWindowDefinitions(pstate,
(gdb) 
1284		if (pstate->p_resolve_unknowns)
(gdb) 
1285			resolveTargetListUnknowns(pstate, qry->targetList);
(gdb) 
1287		qry->rtable = pstate->p_rtable;
(gdb) 
1288		qry->jointree = makeFromExpr(pstate->p_joinlist, qual);
(gdb) 
1290		qry->hasSubLinks = pstate->p_hasSubLinks;
(gdb) p qry
$127 = (Query *) 0x17a49b8
(gdb) p *qry
$128 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 0 '\000', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f8e8, jointree = 0x179fca0, targetList = 0x179fc00, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 0}
(gdb) p qry->rtable
$129 = (List *) 0x179f8e8
(gdb) p qry->rtable->head
$130 = (ListCell *) 0x179f8c8
(gdb) p *qry->rtable->head
$131 = {data = {ptr_value = 0x17a4ac8, int_value = 24791752, oid_value = 24791752}, next = 0x0}
(gdb) p *(RangeTblEntry *)(qry->rtable->head)
$132 = {type = 24791752, rtekind = RTE_RELATION, relid = 0, relkind = 0 '\000', tablesample = 0x20, subquery = 0x16f6dc8, security_barrier = -39 '\331', jointype = JOIN_LEFT, 
  joinaliasvars = 0x179f8c8, functions = 0x179f8c8, funcordinality = 0 '\000', tablefunc = 0x10, values_lists = 0x16f6dc8, ctename = 0x17a4ac8 "g\001", ctelevelsup = 16777473, 
  self_reference = 0 '\000', coltypes = 0x10, coltypmods = 0x16f6dc8, colcollations = 0x179f918, enrname = 0x0, enrtuples = 1.5810100666919889e-322, alias = 0x16f6dc8, eref = 0x1000000d9, 
  lateral = 56 '8', inh = -7 '\371', inFromCl = 121 'y', requiredPerms = 0, checkAsUser = 24770872, selectedCols = 0x0, insertedCols = 0x8, updatedCols = 0x16f6dc8, 
  securityQuals = 0x10000008e}
(gdb) p qry->jointree
$133 = (FromExpr *) 0x179fca0
(gdb) p *qry->jointree
$134 = {type = T_FromExpr, fromlist = 0x179f9c0, quals = 0x0}
(gdb) p *qry->jointree->fromlist
$135 = {type = T_List, length = 1, head = 0x179f9a0, tail = 0x179f9a0}
(gdb) p *qry->jointree->fromlist>head
No symbol "head" in current context.
(gdb) p *qry->jointree->fromlist->head
$136 = {data = {ptr_value = 0x179f988, int_value = 24770952, oid_value = 24770952}, next = 0x0}
(gdb) n
1291		qry->hasWindowFuncs = pstate->p_hasWindowFuncs;
(gdb) 
1292		qry->hasTargetSRFs = pstate->p_hasTargetSRFs;
(gdb) 
1293		qry->hasAggs = pstate->p_hasAggs;
(gdb) 
1294		if (pstate->p_hasAggs || qry->groupClause || qry->groupingSets || qry->havingQual)
(gdb) n
1297		foreach(l, stmt->lockingClause)
(gdb) 
1303		assign_query_collations(pstate, qry);
(gdb) p *qry
$137 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 0 '\000', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f8e8, jointree = 0x179fca0, targetList = 0x179fc00, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 0}
(gdb) s
assign_query_collations (pstate=0x17a48a8, query=0x17a49b8) at parse_collate.c:109
109		(void) query_tree_walker(query,
(gdb) n
114	}
(gdb) 
transformSelectStmt (pstate=0x17a48a8, stmt=0x17a4718) at analyze.c:1305
1305		return qry;
(gdb) 
1306	}
(gdb) 
transformStmt (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:334
334		result->querySource = QSRC_ORIGINAL;
(gdb) 
335		result->canSetTag = true;
(gdb) 
337		return result;
(gdb) 
338	}
(gdb) 
transformOptionalSelectInto (pstate=0x17a48a8, parseTree=0x17a4718) at analyze.c:243
243	}
(gdb) 
transformTopLevelStmt (pstate=0x17a48a8, parseTree=0x17a4828) at analyze.c:194
194		result->stmt_location = parseTree->stmt_location;
(gdb) n
195		result->stmt_len = parseTree->stmt_len;
(gdb) 
197		return result;
(gdb) 
198	}
(gdb) 
parse_analyze (parseTree=0x17a4828, sourceText=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at analyze.c:114
114		if (post_parse_analyze_hook)
(gdb) 
117		free_parsestate(pstate);
(gdb) n
119		return query;
(gdb) 
120	}
(gdb) 
pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at postgres.c:656
656		if (log_parser_stats)
(gdb) 
662		querytree_list = pg_rewrite_query(query);
(gdb) s
pg_rewrite_query (query=0x17a49b8) at postgres.c:731
731		if (Debug_print_parse)
(gdb) n
735		if (log_parser_stats)
(gdb) n
738		if (query->commandType == CMD_UTILITY)
(gdb) 
746			querytree_list = QueryRewrite(query);
(gdb) p *quuery
No symbol "quuery" in current context.
(gdb) p *query
$138 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f8e8, jointree = 0x179fca0, targetList = 0x179fc00, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n
749		if (log_parser_stats)
(gdb) n
766		if (Debug_print_rewritten)
(gdb) 
770		return querytree_list;
(gdb) p querytree_list
$139 = (List *) 0x179fd70
(gdb) p *querytree_list
$140 = {type = T_List, length = 1, head = 0x179fda0, tail = 0x179fda0}
(gdb) p *querytree_list->head
$141 = {data = {ptr_value = 0x17a49b8, int_value = 24791480, oid_value = 24791480}, next = 0x0}
(gdb) p *((Query *)(querytree_list->head))
$142 = {type = 24791480, commandType = CMD_UNKNOWN, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 125 '}', utilityStmt = 0xa87, resultRelation = 24776840, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = -88 '\250', hasRecursive = -3 '\375', hasModifyingCTE = 121 'y', hasForUpdate = 1 '\001', 
  hasRowSecurity = 0 '\000', cteList = 0x22d6074d, rtable = 0x4ed, jointree = 0x17a1010, targetList = 0x179fdc8, 
  override = (OVERRIDING_USER_VALUE | OVERRIDING_SYSTEM_VALUE | unknown: 1887417380), onConflict = 0xa62, returningList = 0x17a0f98, groupClause = 0x179fde8, groupingSets = 0x10cefad, 
  havingQual = 0xa5d, windowClause = 0x17a0f20, distinctClause = 0x179fe08, sortClause = 0x952250bf, limitOffset = 0xa5e, limitCount = 0x17a0ea8, rowMarks = 0x0, setOperations = 0x2fa663e1, 
  constraintDeps = 0xa67, withCheckOptions = 0x17a0e30, stmt_location = 0, stmt_len = 0}
(gdb) p *((Query *)(querytree_list))
$143 = {type = T_List, commandType = CMD_SELECT, querySource = 24772000, queryId = 0, canSetTag = -96 '\240', utilityStmt = 0x179fd68, resultRelation = 16, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = -56 '\310', hasRecursive = 109 'm', hasModifyingCTE = 111 'o', hasForUpdate = 1 '\001', 
  hasRowSecurity = 0 '\000', cteList = 0x17a49b8, rtable = 0x0, jointree = 0x70b5057d, targetList = 0xa87, override = (unknown: 24776840), onConflict = 0x179fda8, 
  returningList = 0x22d6074d, groupClause = 0x4ed, groupingSets = 0x17a1010, havingQual = 0x179fdc8, windowClause = 0x707fb427, distinctClause = 0xa62, sortClause = 0x17a0f98, 
  limitOffset = 0x179fde8, limitCount = 0x10cefad, rowMarks = 0xa5d, setOperations = 0x17a0f20, constraintDeps = 0x179fe08, withCheckOptions = 0x952250bf, stmt_location = 2654, stmt_len = 0}
(gdb) n
771	}
(gdb) 
pg_analyze_and_rewrite (parsetree=0x17a4828, query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;", paramTypes=0x0, numParams=0, queryEnv=0x0) at postgres.c:666
666		return querytree_list;
(gdb) 
667	}
(gdb) 
exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
1027			plantree_list = pg_plan_queries(querytree_list,
(gdb) 

Breakpoint 16, pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:842
842		List	   *stmt_list = NIL;
(gdb) n
845		foreach(query_list, querytrees)
(gdb) 
847			Query	   *query = lfirst_node(Query, query_list);
(gdb) p query_list
$144 = (ListCell *) 0x179fda0
(gdb) p *query_list
$145 = {data = {ptr_value = 0x17a49b8, int_value = 24791480, oid_value = 24791480}, next = 0x0}
(gdb) n
850			if (query->commandType == CMD_UTILITY)
(gdb) p query
$146 = (Query *) 0x17a49b8
(gdb) p *query
$147 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f8e8, jointree = 0x179fca0, targetList = 0x179fc00, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n
862				stmt = pg_plan_query(query, cursorOptions, boundParams);
(gdb) s

Breakpoint 17, pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:784
784		if (querytree->commandType == CMD_UTILITY)
(gdb) n
792		if (log_planner_stats)
(gdb) 
796		plan = planner(querytree, cursorOptions, boundParams);
(gdb) s
planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:207
207		if (planner_hook)
(gdb) n
208			result = (*planner_hook) (parse, cursorOptions, boundParams);
(gdb) s

Breakpoint 18, distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:94
94		PlannedStmt *result = NULL;
(gdb) n
95		bool needsDistributedPlanning = NeedsDistributedPlanning(parse);
(gdb) s
NeedsDistributedPlanning (query=0x17a49b8) at planner/distributed_planner.c:207
207		CmdType commandType = query->commandType;
(gdb) n
208		if (commandType != CMD_SELECT && commandType != CMD_INSERT &&
(gdb) 
214		if (!CitusHasBeenLoaded())
(gdb) 
219		if (!NeedsDistributedPlanningWalker((Node *) query, NULL))
(gdb) s
NeedsDistributedPlanningWalker (node=0x17a49b8, context=0x0) at planner/distributed_planner.c:235
235		if (node == NULL)
(gdb) n
240		if (IsA(node, Query))
(gdb) 
242			Query *query = (Query *) node;
(gdb) 
243			ListCell *rangeTableCell = NULL;
(gdb) p *query
$148 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f8e8, jointree = 0x179fca0, targetList = 0x179fc00, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n
245			foreach(rangeTableCell, query->rtable)
(gdb) p query->rtable
$149 = (List *) 0x179f8e8
(gdb) p *query->rtable
$150 = {type = T_List, length = 1, head = 0x179f8c8, tail = 0x179f8c8}
(gdb) n
247				RangeTblEntry *rangeTableEntry = (RangeTblEntry *) lfirst(rangeTableCell);
(gdb) 
249				Oid relationId = rangeTableEntry->relid;
(gdb) p rangeTableEntry
$151 = (RangeTblEntry *) 0x17a4ac8
(gdb) p *rangeTableEntry
$152 = {type = T_RangeTblEntry, rtekind = RTE_SUBQUERY, relid = 0, relkind = 0 '\000', tablesample = 0x0, subquery = 0x17a4bd8, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x17a4668, eref = 0x179f7a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x0, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
250				if (IsDistributedTable(relationId))
(gdb) s
IsDistributedTable (relationId=0) at utils/metadata_cache.c:258
258		DistTableCacheEntry *cacheEntry = NULL;
(gdb) n
260		cacheEntry = LookupDistTableCacheEntry(relationId);
(gdb) 
266		if (!cacheEntry)
(gdb) 
271		return cacheEntry->isDistributedTable;
(gdb) p cacheEntry
$153 = (DistTableCacheEntry *) 0x1827468
(gdb) p *cacheEntry
$154 = {relationId = 0, isValid = 1 '\001', isDistributedTable = 0 '\000', hasUninitializedShardInterval = 0 '\000', hasUniformHashDistribution = 0 '\000', 
  hasOverlappingShardInterval = 0 '\000', partitionKeyString = 0x0, partitionColumn = 0x0, partitionMethod = 0 '\000', colocationId = 0, replicationModel = 0 '\000', 
  shardIntervalArrayLength = 0, sortedShardIntervalArray = 0x0, shardColumnCompareFunction = 0x0, shardIntervalCompareFunction = 0x0, hashFunction = 0x0, 
  referencedRelationsViaForeignKey = 0x0, referencingRelationsViaForeignKey = 0x0, arrayOfPlacementArrays = 0x0, arrayOfPlacementArrayLengths = 0x0}
(gdb) n
272	}
(gdb) 
NeedsDistributedPlanningWalker (node=0x17a49b8, context=0x0) at planner/distributed_planner.c:245
245			foreach(rangeTableCell, query->rtable)
(gdb) 
256			return query_tree_walker(query, NeedsDistributedPlanningWalker, NULL, 0);
(gdb) s
query_tree_walker (query=0x17a49b8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2253
2253		if (walker((Node *) query->targetList, context))
(gdb) s
NeedsDistributedPlanningWalker (node=0x179fc00, context=0x0) at planner/distributed_planner.c:235
235		if (node == NULL)
(gdb) n
240		if (IsA(node, Query))
(gdb) 
260			return expression_tree_walker(node, NeedsDistributedPlanningWalker, NULL);
(gdb) bt
#0  NeedsDistributedPlanningWalker (node=0x179fc00, context=0x0) at planner/distributed_planner.c:260
#1  0x00000000006d289f in query_tree_walker (query=0x17a49b8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2253
#2  0x00007f274935ad40 in NeedsDistributedPlanningWalker (node=0x17a49b8, context=0x0) at planner/distributed_planner.c:256
#3  0x00007f274935ac7c in NeedsDistributedPlanning (query=0x17a49b8) at planner/distributed_planner.c:219
#4  0x00007f274935a984 in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:95
#5  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#6  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#7  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#8  0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#9  0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#10 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#11 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#12 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#13 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#14 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) p node->type
$155 = T_List
(gdb) s
expression_tree_walker (node=0x179fc00, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0) at nodeFuncs.c:1857
1857		if (node == NULL)
(gdb) n
1861		check_stack_depth();
(gdb) 
1863		switch (nodeTag(node))
(gdb) 
2118				foreach(temp, (List *) node)
(gdb) p temp
$156 = (ListCell *) 0x0
(gdb) n
2120					if (walker((Node *) lfirst(temp), context))
(gdb) p temp
$157 = (ListCell *) 0x179fbe0
(gdb) p *temp
$158 = {data = {ptr_value = 0x179fb90, int_value = 24771472, oid_value = 24771472}, next = 0x179fc80}
(gdb) s
NeedsDistributedPlanningWalker (node=0x179fb90, context=0x0) at planner/distributed_planner.c:235
235		if (node == NULL)
(gdb) n
240		if (IsA(node, Query))
(gdb) p node->type
$159 = T_TargetEntry
(gdb) n
260			return expression_tree_walker(node, NeedsDistributedPlanningWalker, NULL);
(gdb) s
expression_tree_walker (node=0x179fb90, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0) at nodeFuncs.c:1857
1857		if (node == NULL)
(gdb) n
1861		check_stack_depth();
(gdb) 
1863		switch (nodeTag(node))
(gdb) 
2088				return walker(((TargetEntry *) node)->expr, context);
(gdb) s
NeedsDistributedPlanningWalker (node=0x179f720, context=0x0) at planner/distributed_planner.c:235
235		if (node == NULL)
(gdb) n
240		if (IsA(node, Query))
(gdb) bt
#0  NeedsDistributedPlanningWalker (node=0x179f720, context=0x0) at planner/distributed_planner.c:240
#1  0x00000000006d217e in expression_tree_walker (node=0x179fb90, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0) at nodeFuncs.c:2088
#2  0x00007f274935ad5a in NeedsDistributedPlanningWalker (node=0x179fb90, context=0x0) at planner/distributed_planner.c:260
#3  0x00000000006d22d6 in expression_tree_walker (node=0x179fc00, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0) at nodeFuncs.c:2120
#4  0x00007f274935ad5a in NeedsDistributedPlanningWalker (node=0x179fc00, context=0x0) at planner/distributed_planner.c:260
#5  0x00000000006d289f in query_tree_walker (query=0x17a49b8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2253
#6  0x00007f274935ad40 in NeedsDistributedPlanningWalker (node=0x17a49b8, context=0x0) at planner/distributed_planner.c:256
#7  0x00007f274935ac7c in NeedsDistributedPlanning (query=0x17a49b8) at planner/distributed_planner.c:219
#8  0x00007f274935a984 in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:95
#9  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#10 0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#11 0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#12 0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#13 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#14 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#15 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#16 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#17 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#18 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) p node->type
$160 = T_Var
(gdb) n
260			return expression_tree_walker(node, NeedsDistributedPlanningWalker, NULL);
(gdb) s
expression_tree_walker (node=0x179f720, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0) at nodeFuncs.c:1857
1857		if (node == NULL)
(gdb) n
1861		check_stack_depth();
(gdb) 
1863		switch (nodeTag(node))
(gdb) 
1877				break;
(gdb) p node->type
$161 = T_Var
(gdb) n
2227		return false;
(gdb) 
2228	}
(gdb) 
NeedsDistributedPlanningWalker (node=0x179f720, context=0x0) at planner/distributed_planner.c:262
262	}
(gdb) 
expression_tree_walker (node=0x179fb90, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0) at nodeFuncs.c:2228
2228	}
(gdb) 
NeedsDistributedPlanningWalker (node=0x179fb90, context=0x0) at planner/distributed_planner.c:262
262	}
(gdb) 
expression_tree_walker (node=0x179fc00, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0) at nodeFuncs.c:2118
2118				foreach(temp, (List *) node)
(gdb) 
2120					if (walker((Node *) lfirst(temp), context))
(gdb) 
2118				foreach(temp, (List *) node)
(gdb) 
2123				break;
(gdb) 
2227		return false;
(gdb) 
2228	}
(gdb) 
NeedsDistributedPlanningWalker (node=0x179fc00, context=0x0) at planner/distributed_planner.c:262
262	}
(gdb) 
query_tree_walker (query=0x17a49b8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2255
2255		if (walker((Node *) query->withCheckOptions, context))
(gdb) 
2257		if (walker((Node *) query->onConflict, context))
(gdb) 
2259		if (walker((Node *) query->returningList, context))
(gdb) 
2261		if (walker((Node *) query->jointree, context))
(gdb) 
2263		if (walker(query->setOperations, context))
(gdb) 
2265		if (walker(query->havingQual, context))
(gdb) 
2267		if (walker(query->limitOffset, context))
(gdb) 
2269		if (walker(query->limitCount, context))
(gdb) 
2271		if (!(flags & QTW_IGNORE_CTE_SUBQUERIES))
(gdb) 
2273			if (walker((Node *) query->cteList, context))
(gdb) s
NeedsDistributedPlanningWalker (node=0x0, context=0x0) at planner/distributed_planner.c:235
235		if (node == NULL)
(gdb) n
237			return false;
(gdb) 
262	}
(gdb) 
query_tree_walker (query=0x17a49b8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2276
2276		if (!(flags & QTW_IGNORE_RANGE_TABLE))
(gdb) 
2278			if (range_table_walker(query->rtable, walker, context, flags))
(gdb) s
range_table_walker (rtable=0x179f8e8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2297
2297		foreach(rt, rtable)
(gdb) n
2299			RangeTblEntry *rte = (RangeTblEntry *) lfirst(rt);
(gdb) 
2302			if (flags & QTW_EXAMINE_RTES)
(gdb) p *rte
$162 = {type = T_RangeTblEntry, rtekind = RTE_SUBQUERY, relid = 0, relkind = 0 '\000', tablesample = 0x0, subquery = 0x17a4bd8, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x17a4668, eref = 0x179f7a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x0, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
2306			switch (rte->rtekind)
(gdb) 
2317					if (!(flags & QTW_IGNORE_RT_SUBQUERIES))
(gdb) 
2318						if (walker(rte->subquery, context))
(gdb) s
NeedsDistributedPlanningWalker (node=0x17a4bd8, context=0x0) at planner/distributed_planner.c:235
235		if (node == NULL)
(gdb) n
240		if (IsA(node, Query))
(gdb) p node->type
$163 = T_Query
(gdb) n
242			Query *query = (Query *) node;
(gdb) 
243			ListCell *rangeTableCell = NULL;
(gdb) 
245			foreach(rangeTableCell, query->rtable)
(gdb) 
247				RangeTblEntry *rangeTableEntry = (RangeTblEntry *) lfirst(rangeTableCell);
(gdb) 
249				Oid relationId = rangeTableEntry->relid;
(gdb) p rangeTableEntry
$164 = (RangeTblEntry *) 0x17a4ce8
(gdb) p *rangeTableEntry
$165 = {type = T_RangeTblEntry, rtekind = RTE_RELATION, relid = 41849, relkind = 114 'r', tablesample = 0x0, subquery = 0x0, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x0, eref = 0x17a55e8, lateral = 0 '\000', inh = 1 '\001', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x179f458, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
250				if (IsDistributedTable(relationId))
(gdb) s
IsDistributedTable (relationId=41849) at utils/metadata_cache.c:258
258		DistTableCacheEntry *cacheEntry = NULL;
(gdb) n
260		cacheEntry = LookupDistTableCacheEntry(relationId);
(gdb) 
266		if (!cacheEntry)
(gdb) p cacheEntry
$166 = (DistTableCacheEntry *) 0x18273e8
(gdb) p *cacheEntry
$167 = {relationId = 41849, isValid = 1 '\001', isDistributedTable = 1 '\001', hasUninitializedShardInterval = 0 '\000', hasUniformHashDistribution = 1 '\001', 
  hasOverlappingShardInterval = 0 '\000', 
  partitionKeyString = 0x7f2750a1cea8 "{VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location -1}", 
  partitionColumn = 0x7f2750a1cf38, partitionMethod = 104 'h', colocationId = 0, replicationModel = 99 'c', shardIntervalArrayLength = 3, sortedShardIntervalArray = 0x7f2750a1df38, 
  shardColumnCompareFunction = 0x7f2750a1e418, shardIntervalCompareFunction = 0x7f2750a1e468, hashFunction = 0x7f275095fd38, referencedRelationsViaForeignKey = 0x0, 
  referencingRelationsViaForeignKey = 0x0, arrayOfPlacementArrays = 0x7f2750a1e218, arrayOfPlacementArrayLengths = 0x7f2750a1e248}
(gdb) n
271		return cacheEntry->isDistributedTable;
(gdb) 
272	}
(gdb) 
NeedsDistributedPlanningWalker (node=0x17a4bd8, context=0x0) at planner/distributed_planner.c:252
252					return true;
(gdb) 
262	}
(gdb) 
range_table_walker (rtable=0x179f8e8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2319
2319							return true;
(gdb) 
2344	}
(gdb) 
query_tree_walker (query=0x17a49b8, walker=0x7f274935ac8e <NeedsDistributedPlanningWalker>, context=0x0, flags=0) at nodeFuncs.c:2279
2279				return true;
(gdb) 
2282	}
(gdb) n
NeedsDistributedPlanningWalker (node=0x17a49b8, context=0x0) at planner/distributed_planner.c:262
262	}
(gdb) 
NeedsDistributedPlanning (query=0x17a49b8) at planner/distributed_planner.c:224
224		return true;
(gdb) 
225	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:96
96		Query *originalQuery = NULL;
(gdb) n
97		PlannerRestrictionContext *plannerRestrictionContext = NULL;
(gdb) n
98		bool setPartitionedTablesInherited = false;
(gdb) 
100		if (cursorOptions & CURSOR_OPT_FORCE_DISTRIBUTED)
(gdb) 
105		if (needsDistributedPlanning)
(gdb) 
113			if (InsertSelectIntoLocalTable(parse))
(gdb) s
InsertSelectIntoLocalTable (query=0x17a49b8) at planner/insert_select_planner.c:107
107		bool insertSelectQuery = CheckInsertSelectQuery(query);
(gdb) s
CheckInsertSelectQuery (query=0x17a49b8) at planner/insert_select_planner.c:132
132		CmdType commandType = query->commandType;
(gdb) n
133		List *fromList = NULL;
(gdb) 
134		RangeTblRef *rangeTableReference = NULL;
(gdb) 
135		RangeTblEntry *subqueryRte = NULL;
(gdb) 
137		if (commandType != CMD_INSERT)
(gdb) 
139			return false;
(gdb) 
169	}
(gdb) 
InsertSelectIntoLocalTable (query=0x17a49b8) at planner/insert_select_planner.c:109
109		if (insertSelectQuery)
(gdb) n
118		return false;
(gdb) 
119	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:129
129			AssignRTEIdentities(parse);
(gdb) s
AssignRTEIdentities (queryTree=0x17a49b8) at planner/distributed_planner.c:276
276		List *rangeTableList = NIL;
(gdb) n
277		ListCell *rangeTableCell = NULL;
(gdb) 
278		int rteIdentifier = 1;
(gdb) 
281		ExtractRangeTableEntryWalker((Node *) queryTree, &rangeTableList);
(gdb) s
283		foreach(rangeTableCell, rangeTableList)
(gdb) n
285			RangeTblEntry *rangeTableEntry = (RangeTblEntry *) lfirst(rangeTableCell);
(gdb) 
296			if (rangeTableEntry->rtekind == RTE_RELATION)
(gdb) n
283		foreach(rangeTableCell, rangeTableList)
(gdb) 
285			RangeTblEntry *rangeTableEntry = (RangeTblEntry *) lfirst(rangeTableCell);
(gdb) n
296			if (rangeTableEntry->rtekind == RTE_RELATION)
(gdb) 
298				AssignRTEIdentity(rangeTableEntry, rteIdentifier++);
(gdb) s
AssignRTEIdentity (rangeTableEntry=0x17a4ce8, rteIdentifier=1) at planner/distributed_planner.c:371
371		rangeTableEntry->values_lists = list_make1_int(rteIdentifier);
(gdb) n
372	}
(gdb) n
AssignRTEIdentities (queryTree=0x17a49b8) at planner/distributed_planner.c:283
283		foreach(rangeTableCell, rangeTableList)
(gdb) 
301	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:130
130			originalQuery = copyObject(parse);
(gdb) n
132			setPartitionedTablesInherited = false;
(gdb) p originalQuery
$168 = (Query *) 0x17a4f58
(gdb) p parse
$169 = (Query *) 0x17a49b8
(gdb) p *originalQuery
$170 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x1830808, jointree = 0x1830e60, targetList = 0x1830ef8, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n
133			AdjustPartitioningForDistributedPlanning(parse, setPartitionedTablesInherited);
(gdb) s
AdjustPartitioningForDistributedPlanning (queryTree=0x17a49b8, setPartitionedTablesInherited=0 '\000') at planner/distributed_planner.c:319
319		List *rangeTableList = NIL;
(gdb) n
320		ListCell *rangeTableCell = NULL;
(gdb) 
323		ExtractRangeTableEntryWalker((Node *) queryTree, &rangeTableList);
(gdb) s
325		foreach(rangeTableCell, rangeTableList)
(gdb) n
327			RangeTblEntry *rangeTableEntry = (RangeTblEntry *) lfirst(rangeTableCell);
(gdb) 
335			if (IsDistributedTable(rangeTableEntry->relid) &&
(gdb) p *rangeTableEntry
$171 = {type = T_RangeTblEntry, rtekind = RTE_SUBQUERY, relid = 0, relkind = 0 '\000', tablesample = 0x0, subquery = 0x17a4bd8, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x17a4668, eref = 0x179f7a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x0, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) list
330			 * We want Postgres to behave partitioned tables as regular relations
331			 * (i.e. we do not want to expand them to their partitions). To do this
332			 * we set each distributed partitioned table's inh flag to appropriate
333			 * value before and after dropping to the standart_planner.
334			 */
335			if (IsDistributedTable(rangeTableEntry->relid) &&
336				PartitionedTable(rangeTableEntry->relid))
337			{
338				rangeTableEntry->inh = setPartitionedTablesInherited;
339	
(gdb) n
325		foreach(rangeTableCell, rangeTableList)
(gdb) 
327			RangeTblEntry *rangeTableEntry = (RangeTblEntry *) lfirst(rangeTableCell);
(gdb) 
335			if (IsDistributedTable(rangeTableEntry->relid) &&
(gdb) s
IsDistributedTable (relationId=41849) at utils/metadata_cache.c:258
258		DistTableCacheEntry *cacheEntry = NULL;
(gdb) n
260		cacheEntry = LookupDistTableCacheEntry(relationId);
(gdb) 
266		if (!cacheEntry)
(gdb) 
271		return cacheEntry->isDistributedTable;
(gdb) p cacheEntry
$172 = (DistTableCacheEntry *) 0x18273e8
(gdb) p *cacheEntry
$173 = {relationId = 41849, isValid = 1 '\001', isDistributedTable = 1 '\001', hasUninitializedShardInterval = 0 '\000', hasUniformHashDistribution = 1 '\001', 
  hasOverlappingShardInterval = 0 '\000', 
  partitionKeyString = 0x7f2750a1cea8 "{VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location -1}", 
  partitionColumn = 0x7f2750a1cf38, partitionMethod = 104 'h', colocationId = 0, replicationModel = 99 'c', shardIntervalArrayLength = 3, sortedShardIntervalArray = 0x7f2750a1df38, 
  shardColumnCompareFunction = 0x7f2750a1e418, shardIntervalCompareFunction = 0x7f2750a1e468, hashFunction = 0x7f275095fd38, referencedRelationsViaForeignKey = 0x0, 
  referencingRelationsViaForeignKey = 0x0, arrayOfPlacementArrays = 0x7f2750a1e218, arrayOfPlacementArrayLengths = 0x7f2750a1e248}
(gdb) n
272	}
(gdb) 
AdjustPartitioningForDistributedPlanning (queryTree=0x17a49b8, setPartitionedTablesInherited=0 '\000') at planner/distributed_planner.c:336
336				PartitionedTable(rangeTableEntry->relid))
(gdb) s
PartitionedTable (relationId=41849) at utils/multi_partitioning_utils.c:47
47		Relation rel = heap_open(relationId, AccessShareLock);
(gdb) n
48		bool partitionedTable = false;
(gdb) 
51		if (rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)
(gdb) p rel->rd_rel->relkind
$174 = 114 'r'
(gdb) n
58		heap_close(rel, NoLock);
(gdb) n
60		return partitionedTable;
(gdb) p partitionedTable
$175 = 0 '\000'
(gdb) n
61	}
(gdb) 
AdjustPartitioningForDistributedPlanning (queryTree=0x17a49b8, setPartitionedTablesInherited=0 '\000') at planner/distributed_planner.c:335
335			if (IsDistributedTable(rangeTableEntry->relid) &&
(gdb) 
325		foreach(rangeTableCell, rangeTableList)
(gdb) 
352	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:140
140		ReplaceTableVisibleFunction((Node *) parse);
(gdb) 
143		plannerRestrictionContext = CreateAndPushPlannerRestrictionContext();
(gdb) 
145		PG_TRY();
(gdb) 
152			result = standard_planner(parse, cursorOptions, boundParams);
(gdb) s

Breakpoint 19, standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:233
233		glob = makeNode(PlannerGlobal);
(gdb) n
235		glob->boundParams = boundParams;
(gdb) 
236		glob->subplans = NIL;
(gdb) bt
#0  standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:236
#1  0x00007f274935aade in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:152
#2  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#3  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#4  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#5  0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#6  0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#7  0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#8  0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#9  0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#10 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#11 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
237		glob->subroots = NIL;
(gdb) 
238		glob->rewindPlanIDs = NULL;
(gdb) 
239		glob->finalrtable = NIL;
(gdb) 
240		glob->finalrowmarks = NIL;
(gdb) 
241		glob->resultRelations = NIL;
(gdb) 
242		glob->nonleafResultRelations = NIL;
(gdb) 
243		glob->rootResultRelations = NIL;
(gdb) 
244		glob->relationOids = NIL;
(gdb) 
245		glob->invalItems = NIL;
(gdb) 
246		glob->nParamExec = 0;
(gdb) 
247		glob->lastPHId = 0;
(gdb) 
248		glob->lastRowMarkId = 0;
(gdb) 
249		glob->lastPlanNodeId = 0;
(gdb) 
250		glob->transientPlan = false;
(gdb) 
251		glob->dependsOnRole = false;
(gdb) 
273		if ((cursorOptions & CURSOR_OPT_PARALLEL_OK) != 0 &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
274			IsUnderPostmaster &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
280			!IsolationIsSerializable())
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
283			glob->maxParallelHazard = max_parallel_hazard(parse);
(gdb) 
284			glob->parallelModeOK = (glob->maxParallelHazard != PROPARALLEL_UNSAFE);
(gdb) n
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
303			(force_parallel_mode != FORCE_PARALLEL_OFF);
(gdb) 
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
306		if (cursorOptions & CURSOR_OPT_FAST_PLAN)
(gdb) 
330			tuple_fraction = 0.0;
(gdb) n
334		root = subquery_planner(glob, parse, NULL,
(gdb) s
subquery_planner (glob=0x17a0608, parse=0x17a49b8, parent_root=0x0, hasRecursion=0 '\000', tuple_fraction=0) at planner.c:502
502		root = makeNode(PlannerInfo);
(gdb) n
503		root->parse = parse;
(gdb) list
498		RelOptInfo *final_rel;
499		ListCell   *l;
500	
501		/* Create a PlannerInfo data structure for this subquery */
502		root = makeNode(PlannerInfo);
503		root->parse = parse;
504		root->glob = glob;
505		root->query_level = parent_root ? parent_root->query_level + 1 : 1;
506		root->parent_root = parent_root;
507		root->plan_params = NIL;
(gdb) n
504		root->glob = glob;
(gdb) 
505		root->query_level = parent_root ? parent_root->query_level + 1 : 1;
(gdb) 
506		root->parent_root = parent_root;
(gdb) 
507		root->plan_params = NIL;
(gdb) 
508		root->outer_params = NULL;
(gdb) 
509		root->planner_cxt = CurrentMemoryContext;
(gdb) 
510		root->init_plans = NIL;
(gdb) 
511		root->cte_plan_ids = NIL;
(gdb) 
512		root->multiexpr_params = NIL;
(gdb) 
513		root->eq_classes = NIL;
(gdb) 
514		root->append_rel_list = NIL;
(gdb) 
515		root->pcinfo_list = NIL;
(gdb) 
516		root->rowMarks = NIL;
(gdb) 
517		memset(root->upper_rels, 0, sizeof(root->upper_rels));
(gdb) 
518		memset(root->upper_targets, 0, sizeof(root->upper_targets));
(gdb) 
519		root->processed_tlist = NIL;
(gdb) 
520		root->grouping_map = NULL;
(gdb) 
521		root->minmax_aggs = NIL;
(gdb) 
522		root->qual_security_level = 0;
(gdb) 
523		root->hasInheritedTarget = false;
(gdb) 
524		root->hasRecursion = hasRecursion;
(gdb) 
525		if (hasRecursion)
(gdb) 
528			root->wt_param_id = -1;
(gdb) 
529		root->non_recursive_path = NULL;
(gdb) 
535		if (parse->cteList)
(gdb) 
544		if (parse->hasSubLinks)
(gdb) 
552		inline_set_returning_functions(root);
(gdb) p root
$176 = (PlannerInfo *) 0x17a51a8
(gdb) p *root
$177 = {type = T_PlannerInfo, parse = 0x17a49b8, glob = 0x17a0608, query_level = 1, parent_root = 0x0, plan_params = 0x0, outer_params = 0x0, simple_rel_array = 0x0, 
  simple_rel_array_size = 0, simple_rte_array = 0x0, all_baserels = 0x0, nullable_baserels = 0x0, join_rel_list = 0x0, join_rel_hash = 0x0, join_rel_level = 0x0, join_cur_level = 0, 
  init_plans = 0x0, cte_plan_ids = 0x0, multiexpr_params = 0x0, eq_classes = 0x0, canon_pathkeys = 0x0, left_join_clauses = 0x0, right_join_clauses = 0x0, full_join_clauses = 0x0, 
  join_info_list = 0x0, append_rel_list = 0x0, pcinfo_list = 0x0, rowMarks = 0x0, placeholder_list = 0x0, fkey_list = 0x0, query_pathkeys = 0x0, group_pathkeys = 0x0, window_pathkeys = 0x0, 
  distinct_pathkeys = 0x0, sort_pathkeys = 0x0, initial_rels = 0x0, upper_rels = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, upper_targets = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, processed_tlist = 0x0, 
  grouping_map = 0x0, minmax_aggs = 0x0, planner_cxt = 0x16f6dc8, total_table_pages = 0, tuple_fraction = 0, limit_tuples = 0, qual_security_level = 0, hasInheritedTarget = 0 '\000', 
  hasJoinRTEs = 0 '\000', hasLateralRTEs = 0 '\000', hasDeletedRTEs = 0 '\000', hasHavingQual = 0 '\000', hasPseudoConstantQuals = 0 '\000', hasRecursion = 0 '\000', wt_param_id = -1, 
  non_recursive_path = 0x0, curOuterRels = 0x0, curOuterParams = 0x0, join_search_private = 0x0}
(gdb) n
558		pull_up_subqueries(root);
(gdb) s
pull_up_subqueries (root=0x17a51a8) at prepjointree.c:612
612		root->hasDeletedRTEs = false;
(gdb) n
614		root->parse->jointree = (FromExpr *)
(gdb) s
615			pull_up_subqueries_recurse(root, (Node *) root->parse->jointree,
(gdb) s
pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179fca0, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=0 '\000') at prepjointree.c:680
680		if (IsA(jtnode, RangeTblRef))
(gdb) p jtnode->type
$178 = T_FromExpr
(gdb) n
730		else if (IsA(jtnode, FromExpr))
(gdb) 
732			FromExpr   *f = (FromExpr *) jtnode;
(gdb) 
733			bool		have_undeleted_child = false;
(gdb) p *f
$179 = {type = T_FromExpr, fromlist = 0x179f9c0, quals = 0x0}
(gdb) n
742			if (f->quals)
(gdb) 
745			foreach(l, f->fromlist)
(gdb) 
760											   lnext(l) != NULL ||
(gdb) p *l
$180 = {data = {ptr_value = 0x179f988, int_value = 24770952, oid_value = 24770952}, next = 0x0}
(gdb) n
758				bool		sub_deletion_ok = (deletion_ok ||
(gdb) 
760											   lnext(l) != NULL ||
(gdb) n
759											   have_undeleted_child ||
(gdb) 
761											   f == root->parse->jointree);
(gdb) 
760											   lnext(l) != NULL ||
(gdb) p sub_deletion_ok
$181 = -49 '\317'
(gdb) n
758				bool		sub_deletion_ok = (deletion_ok ||
(gdb) 
763				lfirst(l) = pull_up_subqueries_recurse(root, lfirst(l),
(gdb) p sub_deletion_ok
$182 = 1 '\001'
(gdb) s
pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179f988, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001') at prepjointree.c:680
680		if (IsA(jtnode, RangeTblRef))
(gdb) n
682			int			varno = ((RangeTblRef *) jtnode)->rtindex;
(gdb) p jtnode->type
$183 = T_RangeTblRef
(gdb) n
683			RangeTblEntry *rte = rt_fetch(varno, root->parse->rtable);
(gdb) p varno
$184 = 1
(gdb) n
692			if (rte->rtekind == RTE_SUBQUERY &&
(gdb) p *rte
$185 = {type = T_RangeTblEntry, rtekind = RTE_SUBQUERY, relid = 0, relkind = 0 '\000', tablesample = 0x0, subquery = 0x17a4bd8, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x0, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x17a4668, eref = 0x179f7a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x0, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
693				is_simple_subquery(rte->subquery, rte,
(gdb) s
is_simple_subquery (subquery=0x17a4bd8, rte=0x17a4ac8, lowest_outer_join=0x0, deletion_ok=1 '\001') at prepjointree.c:1414
1414		if (!IsA(subquery, Query) ||
(gdb) n
1415			subquery->commandType != CMD_SELECT)
(gdb) 
1414		if (!IsA(subquery, Query) ||
(gdb) 
1423		if (subquery->setOperations)
(gdb) 
1436		if (subquery->hasAggs ||
(gdb) 
1437			subquery->hasWindowFuncs ||
(gdb) 
1436		if (subquery->hasAggs ||
(gdb) 
1438			subquery->hasTargetSRFs ||
(gdb) 
1437			subquery->hasWindowFuncs ||
(gdb) 
1439			subquery->groupClause ||
(gdb) 
1438			subquery->hasTargetSRFs ||
(gdb) 
1440			subquery->groupingSets ||
(gdb) 
1439			subquery->groupClause ||
(gdb) 
1441			subquery->havingQual ||
(gdb) 
1440			subquery->groupingSets ||
(gdb) 
1442			subquery->sortClause ||
(gdb) 
1441			subquery->havingQual ||
(gdb) 
1443			subquery->distinctClause ||
(gdb) 
1442			subquery->sortClause ||
(gdb) 
1444			subquery->limitOffset ||
(gdb) 
1443			subquery->distinctClause ||
(gdb) 
1445			subquery->limitCount ||
(gdb) 
1444			subquery->limitOffset ||
(gdb) 
1446			subquery->hasForUpdate ||
(gdb) 
1445			subquery->limitCount ||
(gdb) 
1447			subquery->cteList)
(gdb) 
1446			subquery->hasForUpdate ||
(gdb) 
1455		if (rte->security_barrier)
(gdb) 
1490		if (subquery->jointree->fromlist == NIL &&
(gdb) n
1499		if (rte->lateral)
(gdb) 
1559		if (contain_volatile_functions((Node *) subquery->targetList))
(gdb) 
1562		return true;
(gdb) 
1563	}
(gdb) 
pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179f988, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001') at prepjointree.c:692
692			if (rte->rtekind == RTE_SUBQUERY &&
(gdb) 
694								   lowest_outer_join, deletion_ok) &&
(gdb) 
697				return pull_up_simple_subquery(root, jtnode, rte,
(gdb) bt
#0  pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179f988, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001') at prepjointree.c:697
#1  0x0000000000754f2f in pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179fca0, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=0 '\000')
    at prepjointree.c:763
#2  0x0000000000754cea in pull_up_subqueries (root=0x17a51a8) at prepjointree.c:615
#3  0x0000000000743297 in subquery_planner (glob=0x17a0608, parse=0x17a49b8, parent_root=0x0, hasRecursion=0 '\000', tuple_fraction=0) at planner.c:558
#4  0x0000000000742b54 in standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:334
#5  0x00007f274935aade in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:152
#6  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#7  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#8  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#9  0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#10 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#11 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#12 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#13 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#14 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#15 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) s
pull_up_simple_subquery (root=0x17a51a8, jtnode=0x179f988, rte=0x17a4ac8, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001')
    at prepjointree.c:874
874		Query	   *parse = root->parse;
(gdb) n
875		int			varno = ((RangeTblRef *) jtnode)->rtindex;
(gdb) 
888		subquery = copyObject(rte->subquery);
(gdb) 
897		subroot = makeNode(PlannerInfo);
(gdb) 
898		subroot->parse = subquery;
(gdb) 
899		subroot->glob = root->glob;
(gdb) 
900		subroot->query_level = root->query_level;
(gdb) 
901		subroot->parent_root = root->parent_root;
(gdb) 
902		subroot->plan_params = NIL;
(gdb) 
903		subroot->outer_params = NULL;
(gdb) 
904		subroot->planner_cxt = CurrentMemoryContext;
(gdb) 
905		subroot->init_plans = NIL;
(gdb) 
906		subroot->cte_plan_ids = NIL;
(gdb) 
907		subroot->multiexpr_params = NIL;
(gdb) 
908		subroot->eq_classes = NIL;
(gdb) 
909		subroot->append_rel_list = NIL;
(gdb) 
910		subroot->rowMarks = NIL;
(gdb) 
911		memset(subroot->upper_rels, 0, sizeof(subroot->upper_rels));
(gdb) 
912		memset(subroot->upper_targets, 0, sizeof(subroot->upper_targets));
(gdb) 
913		subroot->processed_tlist = NIL;
(gdb) 
914		subroot->grouping_map = NULL;
(gdb) 
915		subroot->minmax_aggs = NIL;
(gdb) 
916		subroot->qual_security_level = 0;
(gdb) 
917		subroot->hasInheritedTarget = false;
(gdb) 
918		subroot->hasRecursion = false;
(gdb) 
919		subroot->wt_param_id = -1;
(gdb) 
920		subroot->non_recursive_path = NULL;
(gdb) 
929		if (subquery->hasSubLinks)
(gdb) 
935		inline_set_returning_functions(subroot);
(gdb) 
947		pull_up_subqueries(subroot);
(gdb) p subroot
$186 = (PlannerInfo *) 0x1830568
(gdb) p *subroot
$187 = {type = T_PlannerInfo, parse = 0x17a4e48, glob = 0x17a0608, query_level = 1, parent_root = 0x0, plan_params = 0x0, outer_params = 0x0, simple_rel_array = 0x0, 
  simple_rel_array_size = 0, simple_rte_array = 0x0, all_baserels = 0x0, nullable_baserels = 0x0, join_rel_list = 0x0, join_rel_hash = 0x0, join_rel_level = 0x0, join_cur_level = 0, 
  init_plans = 0x0, cte_plan_ids = 0x0, multiexpr_params = 0x0, eq_classes = 0x0, canon_pathkeys = 0x0, left_join_clauses = 0x0, right_join_clauses = 0x0, full_join_clauses = 0x0, 
  join_info_list = 0x0, append_rel_list = 0x0, pcinfo_list = 0x0, rowMarks = 0x0, placeholder_list = 0x0, fkey_list = 0x0, query_pathkeys = 0x0, group_pathkeys = 0x0, window_pathkeys = 0x0, 
  distinct_pathkeys = 0x0, sort_pathkeys = 0x0, initial_rels = 0x0, upper_rels = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, upper_targets = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, processed_tlist = 0x0, 
  grouping_map = 0x0, minmax_aggs = 0x0, planner_cxt = 0x16f6dc8, total_table_pages = 0, tuple_fraction = 0, limit_tuples = 0, qual_security_level = 0, hasInheritedTarget = 0 '\000', 
  hasJoinRTEs = 0 '\000', hasLateralRTEs = 0 '\000', hasDeletedRTEs = 0 '\000', hasHavingQual = 0 '\000', hasPseudoConstantQuals = 0 '\000', hasRecursion = 0 '\000', wt_param_id = -1, 
  non_recursive_path = 0x0, curOuterRels = 0x0, curOuterParams = 0x0, join_search_private = 0x0}
(gdb) s
pull_up_subqueries (root=0x1830568) at prepjointree.c:612
612		root->hasDeletedRTEs = false;
(gdb) n
614		root->parse->jointree = (FromExpr *)
(gdb) s
615			pull_up_subqueries_recurse(root, (Node *) root->parse->jointree,
(gdb) s
pull_up_subqueries_recurse (root=0x1830568, jtnode=0x18313e0, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=0 '\000') at prepjointree.c:680
680		if (IsA(jtnode, RangeTblRef))
(gdb) p jtnode->type
$188 = T_FromExpr
(gdb) n
730		else if (IsA(jtnode, FromExpr))
(gdb) 
732			FromExpr   *f = (FromExpr *) jtnode;
(gdb) 
733			bool		have_undeleted_child = false;
(gdb) p *f
$189 = {type = T_FromExpr, fromlist = 0x1831410, quals = 0x1831478}
(gdb) n
742			if (f->quals)
(gdb) 
743				deletion_ok = false;
(gdb) 
745			foreach(l, f->fromlist)
(gdb) 
760											   lnext(l) != NULL ||
(gdb) n
758				bool		sub_deletion_ok = (deletion_ok ||
(gdb) 
760											   lnext(l) != NULL ||
(gdb) 
759											   have_undeleted_child ||
(gdb) 
761											   f == root->parse->jointree);
(gdb) 
760											   lnext(l) != NULL ||
(gdb) 
758				bool		sub_deletion_ok = (deletion_ok ||
(gdb) 
763				lfirst(l) = pull_up_subqueries_recurse(root, lfirst(l),
(gdb) p sub_deletion_ok
$190 = 1 '\001'
(gdb) s
pull_up_subqueries_recurse (root=0x1830568, jtnode=0x1831460, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001') at prepjointree.c:680
680		if (IsA(jtnode, RangeTblRef))
(gdb) n
682			int			varno = ((RangeTblRef *) jtnode)->rtindex;
(gdb) p *(RangeTblEntry*)(jtnode)
$191 = {type = T_RangeTblRef, rtekind = RTE_SUBQUERY, relid = 64, relkind = 0 '\000', tablesample = 0x16f6dc8, subquery = 0x2090000006c, security_barrier = -109 '\223', jointype = 16, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = -56 '\310', tablefunc = 0x2c, values_lists = 0x0, ctename = 0x0, ctelevelsup = 32, self_reference = 0 '\000', coltypes = 0x16f6dc8, 
  coltypmods = 0x2000000d9, colcollations = 0x18314f8, enrname = 0x1831568 "\210\025\203\001", enrtuples = 0, alias = 0x10, eref = 0x16f6dc8, lateral = 24 '\030', inh = 21 '\025', 
  inFromCl = -125 '\203', requiredPerms = 0, checkAsUser = 25367912, selectedCols = 0x40, insertedCols = 0x16f6dc8, updatedCols = 0x100000063, securityQuals = 0x1700000001}
(gdb) n
683			RangeTblEntry *rte = rt_fetch(varno, root->parse->rtable);
(gdb) 
692			if (rte->rtekind == RTE_SUBQUERY &&
(gdb) p *rte
$192 = {type = T_RangeTblEntry, rtekind = RTE_RELATION, relid = 41849, relkind = 114 'r', tablesample = 0x0, subquery = 0x0, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x1831270, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x0, eref = 0x18312a0, lateral = 0 '\000', inh = 1 '\001', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x18313c8, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
712			if (rte->rtekind == RTE_SUBQUERY &&
(gdb) 
722			if (rte->rtekind == RTE_VALUES &&
(gdb) 
852		return jtnode;
(gdb) n
853	}
(gdb) 
768				if (lfirst(l) != NULL)
(gdb) 
769					have_undeleted_child = true;
(gdb) 
745			foreach(l, f->fromlist)
(gdb) 
772			if (deletion_ok && !have_undeleted_child)
(gdb) p deletion_ok
$193 = 0 '\000'
(gdb) p have_undeleted_child
$194 = 1 '\001'
(gdb) n
852		return jtnode;
(gdb) 
853	}
(gdb) 
pull_up_subqueries (root=0x1830568) at prepjointree.c:614
614		root->parse->jointree = (FromExpr *)
(gdb) 
618		if (root->hasDeletedRTEs)
(gdb) 
622	}
(gdb) 
pull_up_simple_subquery (root=0x17a51a8, jtnode=0x179f988, rte=0x17a4ac8, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001')
    at prepjointree.c:957
957		if (is_simple_subquery(subquery, rte,
(gdb) bt
#0  pull_up_simple_subquery (root=0x17a51a8, jtnode=0x179f988, rte=0x17a4ac8, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001')
    at prepjointree.c:957
#1  0x0000000000754def in pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179f988, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001')
    at prepjointree.c:697
#2  0x0000000000754f2f in pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179fca0, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=0 '\000')
    at prepjointree.c:763
#3  0x0000000000754cea in pull_up_subqueries (root=0x17a51a8) at prepjointree.c:615
#4  0x0000000000743297 in subquery_planner (glob=0x17a0608, parse=0x17a49b8, parent_root=0x0, hasRecursion=0 '\000', tuple_fraction=0) at planner.c:558
#5  0x0000000000742b54 in standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:334
#6  0x00007f274935aade in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:152
#7  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#8  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#9  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#10 0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#11 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#12 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#13 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#14 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#15 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#16 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
958							   lowest_outer_join, deletion_ok) &&
(gdb) 
957		if (is_simple_subquery(subquery, rte,
(gdb) 
986			flatten_join_alias_vars(subroot, (Node *) subquery->targetList);
(gdb) 
985		subquery->targetList = (List *)
(gdb) 
993		rtoffset = list_length(parse->rtable);
(gdb) p subquery
$195 = (Query *) 0x17a4e48
(gdb) p *subquery
$196 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x1831200, jointree = 0x18313e0, targetList = 0x1831828, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 0}
(gdb) n
994		OffsetVarNodes((Node *) subquery, rtoffset, 0);
(gdb) n
995		OffsetVarNodes((Node *) subroot->append_rel_list, rtoffset, 0);
(gdb) 
1001		IncrementVarSublevelsUp((Node *) subquery, -1, 1);
(gdb) 
1002		IncrementVarSublevelsUp((Node *) subroot->append_rel_list, -1, 1);
(gdb) 
1012		rvcontext.root = root;
(gdb) 
1013		rvcontext.targetlist = subquery->targetList;
(gdb) p root
$197 = (PlannerInfo *) 0x17a51a8
(gdb) p *root
$198 = {type = T_PlannerInfo, parse = 0x17a49b8, glob = 0x17a0608, query_level = 1, parent_root = 0x0, plan_params = 0x0, outer_params = 0x0, simple_rel_array = 0x0, 
  simple_rel_array_size = 0, simple_rte_array = 0x0, all_baserels = 0x0, nullable_baserels = 0x0, join_rel_list = 0x0, join_rel_hash = 0x0, join_rel_level = 0x0, join_cur_level = 0, 
  init_plans = 0x0, cte_plan_ids = 0x0, multiexpr_params = 0x0, eq_classes = 0x0, canon_pathkeys = 0x0, left_join_clauses = 0x0, right_join_clauses = 0x0, full_join_clauses = 0x0, 
  join_info_list = 0x0, append_rel_list = 0x0, pcinfo_list = 0x0, rowMarks = 0x0, placeholder_list = 0x0, fkey_list = 0x0, query_pathkeys = 0x0, group_pathkeys = 0x0, window_pathkeys = 0x0, 
  distinct_pathkeys = 0x0, sort_pathkeys = 0x0, initial_rels = 0x0, upper_rels = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, upper_targets = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, processed_tlist = 0x0, 
  grouping_map = 0x0, minmax_aggs = 0x0, planner_cxt = 0x16f6dc8, total_table_pages = 0, tuple_fraction = 0, limit_tuples = 0, qual_security_level = 0, hasInheritedTarget = 0 '\000', 
  hasJoinRTEs = 0 '\000', hasLateralRTEs = 0 '\000', hasDeletedRTEs = 0 '\000', hasHavingQual = 0 '\000', hasPseudoConstantQuals = 0 '\000', hasRecursion = 0 '\000', wt_param_id = -1, 
  non_recursive_path = 0x0, curOuterRels = 0x0, curOuterParams = 0x0, join_search_private = 0x0}
(gdb) n
1014		rvcontext.target_rte = rte;
(gdb) 
1015		if (rte->lateral)
(gdb) 
1019			rvcontext.relids = NULL;
(gdb) 
1020		rvcontext.outer_hasSubLinks = &parse->hasSubLinks;
(gdb) 
1021		rvcontext.varno = varno;
(gdb) 
1022		rvcontext.need_phvs = (lowest_nulling_outer_join != NULL ||
(gdb) 
1024		rvcontext.wrap_non_vars = (containing_appendrel != NULL);
(gdb) 
1026		rvcontext.rv_cache = palloc0((list_length(subquery->targetList) + 1) *
(gdb) 
1039			pullup_replace_vars((Node *) parse->targetList, &rvcontext);
(gdb) 
1038		parse->targetList = (List *)
(gdb) 
1041			pullup_replace_vars((Node *) parse->returningList, &rvcontext);
(gdb) 
1040		parse->returningList = (List *)
(gdb) 
1042		if (parse->onConflict)
(gdb) 
1056		replace_vars_in_jointree((Node *) parse->jointree, &rvcontext,
(gdb) 
1059		parse->havingQual = pullup_replace_vars(parse->havingQual, &rvcontext);
(gdb) n
1068		foreach(lc, root->append_rel_list)
(gdb) 
1089		foreach(lc, parse->rtable)
(gdb) 
1091			RangeTblEntry *otherrte = (RangeTblEntry *) lfirst(lc);
(gdb) 
1093			if (otherrte->rtekind == RTE_JOIN)
(gdb) 
1089		foreach(lc, parse->rtable)
(gdb) 
1106		if (rte->lateral)
(gdb) 
1138		parse->rtable = list_concat(parse->rtable, subquery->rtable);
(gdb) 
1144		parse->rowMarks = list_concat(parse->rowMarks, subquery->rowMarks);
(gdb) 
1157		if (parse->hasSubLinks || root->glob->lastPHId != 0 ||
(gdb) 
1158			root->append_rel_list)
(gdb) 
1157		if (parse->hasSubLinks || root->glob->lastPHId != 0 ||
(gdb) 
1170		root->append_rel_list = list_concat(root->append_rel_list,
(gdb) n
1191		parse->hasSubLinks |= subquery->hasSubLinks;
(gdb) 
1194		parse->hasRowSecurity |= subquery->hasRowSecurity;
(gdb) 
1207		if (subquery->jointree->fromlist == NIL)
(gdb) 
1215		return (Node *) subquery->jointree;
(gdb) 
1216	}
(gdb) 
pull_up_subqueries_recurse (root=0x17a51a8, jtnode=0x179f988, lowest_outer_join=0x0, lowest_nulling_outer_join=0x0, containing_appendrel=0x0, deletion_ok=1 '\001') at prepjointree.c:853
853	}
(gdb) 
768				if (lfirst(l) != NULL)
(gdb) 
769					have_undeleted_child = true;
(gdb) 
745			foreach(l, f->fromlist)
(gdb) 
772			if (deletion_ok && !have_undeleted_child)
(gdb) 
852		return jtnode;
(gdb) 
853	}
(gdb) 
pull_up_subqueries (root=0x17a51a8) at prepjointree.c:614
614		root->parse->jointree = (FromExpr *)
(gdb) 
618		if (root->hasDeletedRTEs)
(gdb) 
622	}
(gdb) 
subquery_planner (glob=0x17a0608, parse=0x17a49b8, parent_root=0x0, hasRecursion=0 '\000', tuple_fraction=0) at planner.c:566
566		if (parse->setOperations)
(gdb) n
576		root->hasJoinRTEs = false;
(gdb) 
577		root->hasLateralRTEs = false;
(gdb) 
578		hasOuterJoins = false;
(gdb) 
579		foreach(l, parse->rtable)
(gdb) 
581			RangeTblEntry *rte = (RangeTblEntry *) lfirst(l);
(gdb) 
583			if (rte->rtekind == RTE_JOIN)
(gdb) 
589			if (rte->lateral)
(gdb) 
579		foreach(l, parse->rtable)
(gdb) 
581			RangeTblEntry *rte = (RangeTblEntry *) lfirst(l);
(gdb) 
583			if (rte->rtekind == RTE_JOIN)
(gdb) 
589			if (rte->lateral)
(gdb) 
579		foreach(l, parse->rtable)
(gdb) 
599		preprocess_rowmarks(root);
(gdb) 
609		expand_inherited_tables(root);
(gdb) 
616		root->hasHavingQual = (parse->havingQual != NULL);
(gdb) 

619		root->hasPseudoConstantQuals = false;
(gdb) 
628			preprocess_expression(root, (Node *) parse->targetList,
(gdb) 

627		parse->targetList = (List *)
(gdb) 

632		if (parse->hasTargetSRFs)
(gdb) 
635		newWithCheckOptions = NIL;
(gdb) 
636		foreach(l, parse->withCheckOptions)
(gdb) 

645		parse->withCheckOptions = newWithCheckOptions;
(gdb) 
648			preprocess_expression(root, (Node *) parse->returningList,
(gdb) 
647		parse->returningList = (List *)
(gdb) 
651		preprocess_qual_conditions(root, (Node *) parse->jointree);
(gdb) 

653		parse->havingQual = preprocess_expression(root, parse->havingQual,
(gdb) 


656		foreach(l, parse->windowClause)
(gdb) 

667		parse->limitOffset = preprocess_expression(root, parse->limitOffset,
(gdb) 
669		parse->limitCount = preprocess_expression(root, parse->limitCount,
(gdb) 
672		if (parse->onConflict)
(gdb) 
694			preprocess_expression(root, (Node *) root->append_rel_list,
(gdb) 
693		root->append_rel_list = (List *)
(gdb) 
698		foreach(l, parse->rtable)
(gdb) 
700			RangeTblEntry *rte = (RangeTblEntry *) lfirst(l);
(gdb) 
704			if (rte->rtekind == RTE_RELATION)
(gdb) 
712			else if (rte->rtekind == RTE_SUBQUERY)
(gdb) 
721				if (rte->lateral && root->hasJoinRTEs)
(gdb) 
753			foreach(lcsq, rte->securityQuals)
(gdb) 
698		foreach(l, parse->rtable)
(gdb) 
700			RangeTblEntry *rte = (RangeTblEntry *) lfirst(l);
(gdb) 
704			if (rte->rtekind == RTE_RELATION)
(gdb) 
706				if (rte->tablesample)
(gdb) 
753			foreach(lcsq, rte->securityQuals)
(gdb) 
698		foreach(l, parse->rtable)
(gdb) 
772		if (root->hasJoinRTEs)
(gdb) 
813		newHaving = NIL;
(gdb) 
814		foreach(l, (List *) parse->havingQual)
(gdb) 
841		parse->havingQual = (Node *) newHaving;
(gdb) 
844		remove_useless_groupby_columns(root);
(gdb) 
851		if (hasOuterJoins)
(gdb) 
858		if (parse->resultRelation &&
(gdb) 
862			grouping_planner(root, false, tuple_fraction);
(gdb) 
868		SS_identify_outer_params(root);
(gdb) 
876		final_rel = fetch_upper_rel(root, UPPERREL_FINAL, NULL);
(gdb) 
877		SS_charge_for_initplans(root, final_rel);
(gdb) 
884		set_cheapest(final_rel);
(gdb) 
886		return root;
(gdb) 
887	}
(gdb) 
standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:338
338		final_rel = fetch_upper_rel(root, UPPERREL_FINAL, NULL);
(gdb) 
339		best_path = get_cheapest_fractional_path(final_rel, tuple_fraction);
(gdb) p final_rel
$199 = (RelOptInfo *) 0x18332c0
(gdb) p *final_rel
$200 = {type = T_RelOptInfo, reloptkind = RELOPT_UPPER_REL, relids = 0x0, rows = 0, consider_startup = 0 '\000', consider_param_startup = 0 '\000', consider_parallel = 1 '\001', 
  reltarget = 0x18334d0, pathlist = 0x1833590, ppilist = 0x0, partial_pathlist = 0x0, cheapest_startup_path = 0x17a00b0, cheapest_total_path = 0x17a00b0, cheapest_unique_path = 0x0, 
  cheapest_parameterized_paths = 0x18335e0, direct_lateral_relids = 0x0, lateral_relids = 0x0, relid = 0, reltablespace = 0, rtekind = RTE_RELATION, min_attr = 0, max_attr = 0, 
  attr_needed = 0x0, attr_widths = 0x0, lateral_vars = 0x0, lateral_referencers = 0x0, indexlist = 0x0, statlist = 0x0, pages = 0, tuples = 0, allvisfrac = 0, subroot = 0x0, 
  subplan_params = 0x0, rel_parallel_workers = 0, serverid = 0, userid = 0, useridiscurrent = 0 '\000', fdwroutine = 0x0, fdw_private = 0x0, unique_for_rels = 0x0, 
  non_unique_for_rels = 0x0, baserestrictinfo = 0x0, baserestrictcost = {startup = 0, per_tuple = 0}, baserestrict_min_security = 0, joininfo = 0x0, has_eclass_joins = 0 '\000', 
  top_parent_relids = 0x0}
(gdb) s
get_cheapest_fractional_path (rel=0x18332c0, tuple_fraction=0) at planner.c:5808
5808		Path	   *best_path = rel->cheapest_total_path;
(gdb) n
5812		if (tuple_fraction <= 0.0)
(gdb) p *best_path
$201 = {type = T_BitmapHeapPath, pathtype = T_BitmapHeapScan, parent = 0x1831e68, pathtarget = 0x1833200, param_info = 0x0, parallel_aware = 0 '\000', parallel_safe = 1 '\001', 
  parallel_workers = 0, rows = 753, startup_cost = 9.9907500000000002, total_cost = 29.40325, pathkeys = 0x0}
(gdb) n
5813			return best_path;
(gdb) 
5831	}
(gdb) 
standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:341
341		top_plan = create_plan(root, best_path);
(gdb) s
create_plan (root=0x17a51a8, best_path=0x17a00b0) at createplan.c:311
311		root->curOuterRels = NULL;
(gdb) n
312		root->curOuterParams = NIL;
(gdb) 
315		plan = create_plan_recurse(root, best_path, CP_EXACT_TLIST);
(gdb) 
324		if (!IsA(plan, ModifyTable))
(gdb) p plan
$202 = (Plan *) 0x17a53b8
(gdb) p *plan
$203 = {type = T_BitmapHeapScan, startup_cost = 9.9907500000000002, total_cost = 29.40325, plan_rows = 753, plan_width = 8, parallel_aware = 0 '\000', parallel_safe = 1 '\001', 
  plan_node_id = 0, targetlist = 0x1833680, qual = 0x0, lefttree = 0x1832778, righttree = 0x0, initPlan = 0x0, extParam = 0x0, allParam = 0x0}
(gdb) n
325			apply_tlist_labeling(plan->targetlist, root->processed_tlist);
(gdb) n
334		SS_attach_initplans(root, plan);
(gdb) s
SS_attach_initplans (root=0x17a51a8, plan=0x17a53b8) at subselect.c:2205
2205		plan->initPlan = root->init_plans;
(gdb) n
2206	}
(gdb) 
create_plan (root=0x17a51a8, best_path=0x17a00b0) at createplan.c:337
337		if (root->curOuterParams != NIL)
(gdb) 
344		root->plan_params = NIL;
(gdb) 
346		return plan;
(gdb) p *plan
$204 = {type = T_BitmapHeapScan, startup_cost = 9.9907500000000002, total_cost = 29.40325, plan_rows = 753, plan_width = 8, parallel_aware = 0 '\000', parallel_safe = 1 '\001', 
  plan_node_id = 0, targetlist = 0x1833680, qual = 0x0, lefttree = 0x1832778, righttree = 0x0, initPlan = 0x0, extParam = 0x0, allParam = 0x0}
(gdb) p *plan->targetlist
$205 = {type = T_List, length = 2, head = 0x1833660, tail = 0x1833700}
(gdb) p *plan->targetlist->head
$206 = {data = {ptr_value = 0x1833610, int_value = 25376272, oid_value = 25376272}, next = 0x1833700}
(gdb) p *(TargetEntry*)plan->targetlist->head
$207 = {xpr = {type = 25376272}, expr = 0x1833700, resno = 32, resname = 0x16f6dc8 <incomplete sequence \321>, ressortgroupref = 217, resorigtbl = 2, resorigcol = 13920, 
  resjunk = -125 '\203'}
(gdb) p *(TargetEntry*)(plan->targetlist->head)
$208 = {xpr = {type = 25376272}, expr = 0x1833700, resno = 32, resname = 0x16f6dc8 <incomplete sequence \321>, ressortgroupref = 217, resorigtbl = 2, resorigcol = 13920, 
  resjunk = -125 '\203'}
(gdb) p *(TargetEntry*)(plan->targetlist->tail)
$209 = {xpr = {type = 25376432}, expr = 0x0, resno = 16, resname = 0x16f6dc8 <incomplete sequence \321>, ressortgroupref = 25369960, resorigtbl = 0, resorigcol = 0, resjunk = 0 '\000'}
(gdb) p *(TargetEntry*)(plan->targetlist->head->next)
$210 = {xpr = {type = 25376432}, expr = 0x0, resno = 16, resname = 0x16f6dc8 <incomplete sequence \321>, ressortgroupref = 25369960, resorigtbl = 0, resorigcol = 0, resjunk = 0 '\000'}
(gdb) p *(TargetEntry*)(plan->targetlist->head.data.ptr_value)
$211 = {xpr = {type = T_TargetEntry}, expr = 0x1831af8, resno = 1, resname = 0x179f9f0 "id", ressortgroupref = 0, resorigtbl = 41849, resorigcol = 1, resjunk = 0 '\000'}
(gdb) p *(TargetEntry*)(plan->targetlist->head->next.data.ptr_value)
$212 = {xpr = {type = T_TargetEntry}, expr = 0x1831be8, resno = 2, resname = 0x179fac8 "name", ressortgroupref = 0, resorigtbl = 41849, resorigcol = 2, resjunk = 0 '\000'}
(gdb) n
347	}
(gdb) 
standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:347
347		if (cursorOptions & CURSOR_OPT_SCROLL)
(gdb) 
357		if (force_parallel_mode != FORCE_PARALLEL_OFF && top_plan->parallel_safe)
(gdb) 
400		if (glob->nParamExec > 0)
(gdb) 
419		top_plan = set_plan_references(root, top_plan);
(gdb) p force_parallel_mode
$213 = 0
(gdb) p top_plan->parallel_safe
$214 = 1 '\001'
(gdb) s
set_plan_references (root=0x17a51a8, plan=0x17a53b8) at setrefs.c:211
211		PlannerGlobal *glob = root->glob;
(gdb) n
212		int			rtoffset = list_length(glob->finalrtable);
(gdb) p global
$215 = (struct resolv_conf_global *) 0x1739090
(gdb) p glob
$216 = (PlannerGlobal *) 0x17a0608
(gdb) p *glob
$217 = {type = T_PlannerGlobal, boundParams = 0x0, subplans = 0x0, subroots = 0x0, rewindPlanIDs = 0x0, finalrtable = 0x0, finalrowmarks = 0x0, resultRelations = 0x0, 
  nonleafResultRelations = 0x0, rootResultRelations = 0x0, relationOids = 0x0, invalItems = 0x0, nParamExec = 0, lastPHId = 0, lastRowMarkId = 0, lastPlanNodeId = 0, 
  transientPlan = 0 '\000', dependsOnRole = 0 '\000', parallelModeOK = 1 '\001', parallelModeNeeded = 0 '\000', maxParallelHazard = 115 's'}
(gdb) n
220		add_rtes_to_flat_rtable(root, false);
(gdb) 
225		foreach(lc, root->rowMarks)
(gdb) 
242		return set_plan_refs(root, plan, rtoffset);
(gdb) s
set_plan_refs (root=0x17a51a8, plan=0x17a53b8, rtoffset=0) at setrefs.c:438
438		if (plan == NULL)
(gdb) n
442		plan->plan_node_id = root->glob->lastPlanNodeId++;
(gdb) 
447		switch (nodeTag(plan))
(gdb) 
515					BitmapHeapScan *splan = (BitmapHeapScan *) plan;
(gdb) 
517					splan->scan.scanrelid += rtoffset;
(gdb) 
519						fix_scan_list(root, splan->scan.plan.targetlist, rtoffset);
(gdb) 
518					splan->scan.plan.targetlist =
(gdb) 
521						fix_scan_list(root, splan->scan.plan.qual, rtoffset);
(gdb) 
520					splan->scan.plan.qual =
(gdb) 
523						fix_scan_list(root, splan->bitmapqualorig, rtoffset);
(gdb) p plan->type
$218 = T_BitmapHeapScan
(gdb) n
522					splan->bitmapqualorig =
(gdb) 
525				break;
(gdb) 
997		plan->lefttree = set_plan_refs(root, plan->lefttree, rtoffset);
(gdb) 
998		plan->righttree = set_plan_refs(root, plan->righttree, rtoffset);
(gdb) 
1000		return plan;
(gdb) 
1001	}
(gdb) 
set_plan_references (root=0x17a51a8, plan=0x17a53b8) at setrefs.c:243
243	}
(gdb) 
standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:422
422		forboth(lp, glob->subplans, lr, glob->subroots)
(gdb) 
431		result = makeNode(PlannedStmt);
(gdb) 
433		result->commandType = parse->commandType;
(gdb) 
434		result->queryId = parse->queryId;
(gdb) 
435		result->hasReturning = (parse->returningList != NIL);
(gdb) 
436		result->hasModifyingCTE = parse->hasModifyingCTE;
(gdb) 
437		result->canSetTag = parse->canSetTag;
(gdb) 
438		result->transientPlan = glob->transientPlan;
(gdb) 
439		result->dependsOnRole = glob->dependsOnRole;
(gdb) 
440		result->parallelModeNeeded = glob->parallelModeNeeded;
(gdb) 
441		result->planTree = top_plan;
(gdb) 
442		result->rtable = glob->finalrtable;
(gdb) 
443		result->resultRelations = glob->resultRelations;
(gdb) 
444		result->nonleafResultRelations = glob->nonleafResultRelations;
(gdb) 
445		result->rootResultRelations = glob->rootResultRelations;
(gdb) 
446		result->subplans = glob->subplans;
(gdb) 
447		result->rewindPlanIDs = glob->rewindPlanIDs;
(gdb) 
448		result->rowMarks = glob->finalrowmarks;
(gdb) 
449		result->relationOids = glob->relationOids;
(gdb) 
450		result->invalItems = glob->invalItems;
(gdb) 
451		result->nParamExec = glob->nParamExec;
(gdb) 
453		result->utilityStmt = parse->utilityStmt;
(gdb) 
454		result->stmt_location = parse->stmt_location;
(gdb) 
455		result->stmt_len = parse->stmt_len;
(gdb) 
457		return result;
(gdb) p result
$219 = (PlannedStmt *) 0x18324e0
(gdb) p *result
$220 = {type = T_PlannedStmt, commandType = CMD_SELECT, queryId = 0, hasReturning = 0 '\000', hasModifyingCTE = 0 '\000', canSetTag = 1 '\001', transientPlan = 0 '\000', 
  dependsOnRole = 0 '\000', parallelModeNeeded = 0 '\000', planTree = 0x17a53b8, rtable = 0x1833b40, resultRelations = 0x0, nonleafResultRelations = 0x0, rootResultRelations = 0x0, 
  subplans = 0x0, rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x1833cc0, invalItems = 0x0, nParamExec = 0, utilityStmt = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n
458	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:154
154			if (needsDistributedPlanning)
(gdb) 
156				uint64 planId = NextPlanId++;
(gdb) 
158				result = CreateDistributedPlannedStmt(planId, result, originalQuery, parse,
(gdb) s
CreateDistributedPlannedStmt (planId=1, localPlan=0x18324e0, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:484
484		DistributedPlan *distributedPlan = NULL;
(gdb) n
485		PlannedStmt *resultPlan = NULL;
(gdb) 
486		bool hasUnresolvedParams = false;
(gdb) 
487		JoinRestrictionContext *joinRestrictionContext =
(gdb) 
490		if (HasUnresolvedExternParamsWalker((Node *) originalQuery, boundParams))
(gdb) 
496			RemoveDuplicateJoinRestrictions(joinRestrictionContext);
(gdb) list
491		{
492			hasUnresolvedParams = true;
493		}
494	
495		plannerRestrictionContext->joinRestrictionContext =
496			RemoveDuplicateJoinRestrictions(joinRestrictionContext);
497	
498		distributedPlan =
499			CreateDistributedPlan(planId, originalQuery, query, boundParams,
500								  hasUnresolvedParams, plannerRestrictionContext);
(gdb) n
495		plannerRestrictionContext->joinRestrictionContext =
(gdb) 
499			CreateDistributedPlan(planId, originalQuery, query, boundParams,
(gdb) s
498		distributedPlan =
(gdb) n

Breakpoint 20, CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:580
580		DistributedPlan *distributedPlan = NULL;
(gdb) n
581		MultiTreeRoot *logicalPlan = NULL;
(gdb) 
582		List *subPlanList = NIL;
(gdb) n
583		bool hasCtes = originalQuery->cteList != NIL;
(gdb) 
585		if (IsModifyCommand(originalQuery))
(gdb) p hasCtes
$221 = 0 '\000'
(gdb) n
636			distributedPlan = CreateRouterPlan(originalQuery, query,
(gdb) s
CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:171
171		if (MultiRouterPlannableQuery(query,
(gdb) s
MultiRouterPlannableQuery (query=0x17a49b8, restrictionContext=0x1831178) at planner/multi_router_planner.c:2844
2844		CmdType commandType = query->commandType;
(gdb) n
2845		ListCell *relationRestrictionContextCell = NULL;
(gdb) 
2847		if (commandType == CMD_INSERT || commandType == CMD_UPDATE ||
(gdb) p comma
comma                                commands/drop_distributed_table.c    commands/index.c                     commands/schema.c                    commands/transmit.c
commandType                          commands/extension.c                 commands/multi_copy.c                commands/sequence.c                  commands/truncate.c
commands/cluster.c                   commands/foreign_constraint.c        commands/policy.c                    commands/subscription.c              commands/utility_hook.c
commands/create_distributed_table.c  commands/grant.c                     commands/rename.c                    commands/table.c                     commands/vacuum.c
(gdb) p comma
comma                                commands/drop_distributed_table.c    commands/index.c                     commands/schema.c                    commands/transmit.c
commandType                          commands/extension.c                 commands/multi_copy.c                commands/sequence.c                  commands/truncate.c
commands/cluster.c                   commands/foreign_constraint.c        commands/policy.c                    commands/subscription.c              commands/utility_hook.c
commands/create_distributed_table.c  commands/grant.c                     commands/rename.c                    commands/table.c                     commands/vacuum.c
(gdb) p commandType 
$222 = CMD_SELECT
(gdb) n
2855		if (!EnableRouterExecution)
(gdb) p EnableRouterExecution
$223 = 1 '\001'
(gdb) n
2860		foreach(relationRestrictionContextCell, restrictionContext->relationRestrictionList)
(gdb) 
2862			RelationRestriction *relationRestriction =
(gdb) 
2864			RangeTblEntry *rte = relationRestriction->rte;
(gdb) 
2865			if (rte->rtekind == RTE_RELATION)
(gdb) p *rte
$224 = {type = T_RangeTblEntry, rtekind = RTE_RELATION, relid = 41849, relkind = 114 'r', tablesample = 0x0, subquery = 0x0, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x1831270, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x0, eref = 0x18312a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x18313c8, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
2868				Oid distributedTableId = rte->relid;
(gdb) 
2869				char partitionMethod = 0;
(gdb) 
2871				if (!IsDistributedTable(distributedTableId))
(gdb) n
2877				partitionMethod = PartitionMethod(distributedTableId);
(gdb) s
PartitionMethod (relationId=41849) at planner/multi_join_order.c:1414
1414		DistTableCacheEntry *partitionEntry = DistributedTableCacheEntry(relationId);
(gdb) n
1416		char partitionMethod = partitionEntry->partitionMethod;
(gdb) 
1418		return partitionMethod;
(gdb) p *partitionEntry
$225 = {relationId = 41849, isValid = 1 '\001', isDistributedTable = 1 '\001', hasUninitializedShardInterval = 0 '\000', hasUniformHashDistribution = 1 '\001', 
  hasOverlappingShardInterval = 0 '\000', 
  partitionKeyString = 0x7f2750a1cea8 "{VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location -1}", 
  partitionColumn = 0x7f2750a1cf38, partitionMethod = 104 'h', colocationId = 0, replicationModel = 99 'c', shardIntervalArrayLength = 3, sortedShardIntervalArray = 0x7f2750a1df38, 
  shardColumnCompareFunction = 0x7f2750a1e418, shardIntervalCompareFunction = 0x7f2750a1e468, hashFunction = 0x7f275095fd38, referencedRelationsViaForeignKey = 0x0, 
  referencingRelationsViaForeignKey = 0x0, arrayOfPlacementArrays = 0x7f2750a1e218, arrayOfPlacementArrayLengths = 0x7f2750a1e248}
(gdb) n
1419	}
(gdb) 
MultiRouterPlannableQuery (query=0x17a49b8, restrictionContext=0x1831178) at planner/multi_router_planner.c:2878
2878				if (!(partitionMethod == DISTRIBUTE_BY_HASH || partitionMethod ==
(gdb) n
2889				if (query->hasForUpdate)
(gdb) 
2860		foreach(relationRestrictionContextCell, restrictionContext->relationRestrictionList)
(gdb) 
2902		return true;
(gdb) 
2903	}
(gdb) 
CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:174
174			return CreateSingleTaskRouterPlan(originalQuery, query,
(gdb) s
CreateSingleTaskRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:251
251		Job *job = NULL;
(gdb) n
252		DistributedPlan *distributedPlan = CitusMakeNode(DistributedPlan);
(gdb) 
254		distributedPlan->operation = query->commandType;
(gdb) 
257		distributedPlan->planningError = ErrorIfQueryHasModifyingCTE(query);
(gdb) 
258		if (distributedPlan->planningError)
(gdb) 
264		job = RouterJob(originalQuery, plannerRestrictionContext,
(gdb) s
RouterJob (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, planningError=0x1832ba0) at planner/multi_router_planner.c:1586
1586		Job *job = NULL;
(gdb) n
1587		uint64 shardId = INVALID_SHARD_ID;
(gdb) bt
#0  RouterJob (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, planningError=0x1832ba0) at planner/multi_router_planner.c:1587
#1  0x00007f2749375e96 in CreateSingleTaskRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:264
#2  0x00007f2749375c2a in CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:174
#3  0x00007f274935b2c5 in CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:636
#4  0x00007f274935b07f in CreateDistributedPlannedStmt (planId=1, localPlan=0x18324e0, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:498
#5  0x00007f274935ab2e in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:158
#6  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#7  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#8  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#9  0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#10 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1741868, dbname=0x1741748 "postgres", username=0x1741728 "cituscluster") at postgres.c:4088
#11 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#12 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#13 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#14 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#15 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) 
Socket error Event: 32 Error: 10053.
Connection closing...Socket close.

Connection closed by foreign host.

Disconnected from remote host(citus1) at 18:20:01.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Fri Mar 15 23:51:02 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ ps -ef | grep gdb
cituscl+   8393   8028  0 20:00 pts/4    00:00:29 gdb attach 8346
cituscl+  22144  22065  0 23:51 pts/3    00:00:00 grep --color=auto gdb
[cituscluster@gtm1 ~]$ kill -9 8393
[cituscluster@gtm1 ~]$ ps -ef | grep postgre
cituscl+  22179  72929  0 23:51 ?        00:00:00 postgres: checkpointer process  
cituscl+  22180  72929  0 23:51 ?        00:00:00 postgres: writer process   
cituscl+  22181  72929  0 23:51 ?        00:00:00 postgres: wal writer process  
cituscl+  22182  72929  0 23:51 ?        00:00:00 postgres: autovacuum launcher process  
cituscl+  22183  72929  0 23:51 ?        00:00:00 postgres: stats collector process  
cituscl+  22185  72929  0 23:51 ?        00:00:00 postgres: bgworker: task tracker  
cituscl+  22186  72929  0 23:51 ?        00:00:00 postgres: bgworker: logical replication launcher  
cituscl+  22192  22065  0 23:51 pts/3    00:00:00 grep --color=auto postgre
cituscl+  72929      1  0 01:51 ?        00:00:02 /opt/pgsql-10.1/bin/postgres
[cituscluster@gtm1 ~]$ ps -ef | grep postgres
cituscl+  22179  72929  0 23:51 ?        00:00:00 postgres: checkpointer process  
cituscl+  22180  72929  0 23:51 ?        00:00:00 postgres: writer process   
cituscl+  22181  72929  0 23:51 ?        00:00:00 postgres: wal writer process  
cituscl+  22182  72929  0 23:51 ?        00:00:00 postgres: autovacuum launcher process  
cituscl+  22183  72929  0 23:51 ?        00:00:00 postgres: stats collector process  
cituscl+  22185  72929  0 23:51 ?        00:00:00 postgres: bgworker: task tracker  
cituscl+  22186  72929  0 23:51 ?        00:00:00 postgres: bgworker: logical replication launcher  
cituscl+  22212  22065  0 23:51 pts/3    00:00:00 grep --color=auto postgres
cituscl+  72929      1  0 01:51 ?        00:00:02 /opt/pgsql-10.1/bin/postgres
[cituscluster@gtm1 ~]$ gdb attach 22229
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 22229
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007f274fc22163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) 
(gdb) b pg_plan_queries
Breakpoint 1 at 0x813679: file postgres.c, line 842.
(gdb) b pg_plan_query
Breakpoint 2 at 0x8135e2: file postgres.c, line 784.
(gdb) b distributed_planner
Breakpoint 3 at 0x7f274935a96d: file planner/distributed_planner.c, line 94.
(gdb) b standard_planner
Breakpoint 4 at 0x742910: file planner.c, line 233.
(gdb) b CreateDistributedPlan
Breakpoint 5 at 0x7f274935b1c7: file planner/distributed_planner.c, line 580.
(gdb) 
Note: breakpoint 5 also set at pc 0x7f274935b1c7.
Breakpoint 6 at 0x7f274935b1c7: file planner/distributed_planner.c, line 580.
(gdb) b PrepareMasterJobDirectory
Breakpoint 7 at 0x7f274934653b: file executor/multi_real_time_executor.c, line 1069.
(gdb) b ExecuteSubPlans
Breakpoint 8 at 0x7f274934d56e: file executor/subplan_execution.c, line 35.
(gdb) b PortalStart
Breakpoint 9 at 0x818eac: file pquery.c, line 461.
(gdb) b PortalRun
Breakpoint 10 at 0x819407: file pquery.c, line 707.
(gdb) b MultiRealTimeExecute
Breakpoint 11 at 0x7f2749344c5f: file executor/multi_real_time_executor.c, line 88.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) 
WaitEventSetWaitBlock (set=0x16f8728, cur_timeout=-1, occurred_events=0x7ffe485cf350, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x16f8728, timeout=-1, occurred_events=0x7ffe485cf350, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
984				occurred_events->fd = PGINVALID_SOCKET;
(gdb) 
985				occurred_events->pos = set->latch_pos;
(gdb) 
987					set->events[set->latch_pos].user_data;
(gdb) 
986				occurred_events->user_data =
(gdb) 
988				occurred_events->events = WL_LATCH_SET;
(gdb) 
989				occurred_events++;
(gdb) 
990				returned_events++;
(gdb) 
992				break;
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x173b3d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
194				ResetLatch(MyLatch);
(gdb) 
195				ProcessClientReadInterrupt(true);
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffe485cf560) at postgres.c:330
330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 
359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffe485cf560) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x1741d78, dbname=0x1741c58 "postgres", username=0x1741c38 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) 
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 1, pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:842
842		List	   *stmt_list = NIL;
(gdb) 
845		foreach(query_list, querytrees)
(gdb) 
847			Query	   *query = lfirst_node(Query, query_list);
(gdb) 
850			if (query->commandType == CMD_UTILITY)
(gdb) p *query
$1 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x179f8e8, jointree = 0x179fca0, targetList = 0x179fc00, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n
862				stmt = pg_plan_query(query, cursorOptions, boundParams);
(gdb) 

Breakpoint 2, pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:784
784		if (querytree->commandType == CMD_UTILITY)
(gdb) 
792		if (log_planner_stats)
(gdb) 
796		plan = planner(querytree, cursorOptions, boundParams);
(gdb) 

Breakpoint 3, distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:94
94		PlannedStmt *result = NULL;
(gdb) 
95		bool needsDistributedPlanning = NeedsDistributedPlanning(parse);
(gdb) 
96		Query *originalQuery = NULL;
(gdb) 
97		PlannerRestrictionContext *plannerRestrictionContext = NULL;
(gdb) 
98		bool setPartitionedTablesInherited = false;
(gdb) 
100		if (cursorOptions & CURSOR_OPT_FORCE_DISTRIBUTED)
(gdb) 
105		if (needsDistributedPlanning)
(gdb) 
113			if (InsertSelectIntoLocalTable(parse))
(gdb) 
129			AssignRTEIdentities(parse);
(gdb) 
130			originalQuery = copyObject(parse);
(gdb) list
125			 * set, which doesn't break our goals, but, prevents us keeping an extra copy
126			 * of the query tree. Note that we copy the query tree once we're sure it's a
127			 * distributed query.
128			 */
129			AssignRTEIdentities(parse);
130			originalQuery = copyObject(parse);
131	
132			setPartitionedTablesInherited = false;
133			AdjustPartitioningForDistributedPlanning(parse, setPartitionedTablesInherited);
134		}
(gdb) n
132			setPartitionedTablesInherited = false;
(gdb) 
133			AdjustPartitioningForDistributedPlanning(parse, setPartitionedTablesInherited);
(gdb) 
140		ReplaceTableVisibleFunction((Node *) parse);
(gdb) 
143		plannerRestrictionContext = CreateAndPushPlannerRestrictionContext();
(gdb) 
145		PG_TRY();
(gdb) 
152			result = standard_planner(parse, cursorOptions, boundParams);
(gdb) 

Breakpoint 4, standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:233
233		glob = makeNode(PlannerGlobal);
(gdb) 
235		glob->boundParams = boundParams;
(gdb) 
236		glob->subplans = NIL;
(gdb) 
237		glob->subroots = NIL;
(gdb) 
238		glob->rewindPlanIDs = NULL;
(gdb) 
239		glob->finalrtable = NIL;
(gdb) 
240		glob->finalrowmarks = NIL;
(gdb) 
241		glob->resultRelations = NIL;
(gdb) 
242		glob->nonleafResultRelations = NIL;
(gdb) 
243		glob->rootResultRelations = NIL;
(gdb) 
244		glob->relationOids = NIL;
(gdb) 
245		glob->invalItems = NIL;
(gdb) 
246		glob->nParamExec = 0;
(gdb) 
247		glob->lastPHId = 0;
(gdb) 
248		glob->lastRowMarkId = 0;
(gdb) 
249		glob->lastPlanNodeId = 0;
(gdb) 
250		glob->transientPlan = false;
(gdb) 
251		glob->dependsOnRole = false;
(gdb) 
273		if ((cursorOptions & CURSOR_OPT_PARALLEL_OK) != 0 &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
274			IsUnderPostmaster &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
280			!IsolationIsSerializable())
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
283			glob->maxParallelHazard = max_parallel_hazard(parse);
(gdb) 
284			glob->parallelModeOK = (glob->maxParallelHazard != PROPARALLEL_UNSAFE);
(gdb) 
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
303			(force_parallel_mode != FORCE_PARALLEL_OFF);
(gdb) 
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
306		if (cursorOptions & CURSOR_OPT_FAST_PLAN)
(gdb) 
330			tuple_fraction = 0.0;
(gdb) 
334		root = subquery_planner(glob, parse, NULL,
(gdb) 
338		final_rel = fetch_upper_rel(root, UPPERREL_FINAL, NULL);
(gdb) 
339		best_path = get_cheapest_fractional_path(final_rel, tuple_fraction);
(gdb) 
341		top_plan = create_plan(root, best_path);
(gdb) p best_path
$2 = (Path *) 0x17a00b0
(gdb) p *best_path
$3 = {type = T_BitmapHeapPath, pathtype = T_BitmapHeapScan, parent = 0x1831e68, pathtarget = 0x1833200, param_info = 0x0, parallel_aware = 0 '\000', parallel_safe = 1 '\001', 
  parallel_workers = 0, rows = 753, startup_cost = 9.9907500000000002, total_cost = 29.40325, pathkeys = 0x0}
(gdb) n
347		if (cursorOptions & CURSOR_OPT_SCROLL)
(gdb) p *top_plan
$4 = {type = T_BitmapHeapScan, startup_cost = 9.9907500000000002, total_cost = 29.40325, plan_rows = 753, plan_width = 8, parallel_aware = 0 '\000', parallel_safe = 1 '\001', 
  plan_node_id = 0, targetlist = 0x1833680, qual = 0x0, lefttree = 0x1832778, righttree = 0x0, initPlan = 0x0, extParam = 0x0, allParam = 0x0}
(gdb) n
357		if (force_parallel_mode != FORCE_PARALLEL_OFF && top_plan->parallel_safe)
(gdb) 
400		if (glob->nParamExec > 0)
(gdb) 
419		top_plan = set_plan_references(root, top_plan);
(gdb) 
422		forboth(lp, glob->subplans, lr, glob->subroots)
(gdb) 
431		result = makeNode(PlannedStmt);
(gdb) 
433		result->commandType = parse->commandType;
(gdb) 
434		result->queryId = parse->queryId;
(gdb) 
435		result->hasReturning = (parse->returningList != NIL);
(gdb) 
436		result->hasModifyingCTE = parse->hasModifyingCTE;
(gdb) 
437		result->canSetTag = parse->canSetTag;
(gdb) 
438		result->transientPlan = glob->transientPlan;
(gdb) 
439		result->dependsOnRole = glob->dependsOnRole;
(gdb) 
440		result->parallelModeNeeded = glob->parallelModeNeeded;
(gdb) 
441		result->planTree = top_plan;
(gdb) 
442		result->rtable = glob->finalrtable;
(gdb) 
443		result->resultRelations = glob->resultRelations;
(gdb) 
444		result->nonleafResultRelations = glob->nonleafResultRelations;
(gdb) 
445		result->rootResultRelations = glob->rootResultRelations;
(gdb) 
446		result->subplans = glob->subplans;
(gdb) 
447		result->rewindPlanIDs = glob->rewindPlanIDs;
(gdb) 
448		result->rowMarks = glob->finalrowmarks;
(gdb) 
449		result->relationOids = glob->relationOids;
(gdb) 
450		result->invalItems = glob->invalItems;
(gdb) 
451		result->nParamExec = glob->nParamExec;
(gdb) 
453		result->utilityStmt = parse->utilityStmt;
(gdb) 
454		result->stmt_location = parse->stmt_location;
(gdb) 
455		result->stmt_len = parse->stmt_len;
(gdb) 
457		return result;
(gdb) p result
$5 = (PlannedStmt *) 0x18324e0
(gdb) p *result
$6 = {type = T_PlannedStmt, commandType = CMD_SELECT, queryId = 0, hasReturning = 0 '\000', hasModifyingCTE = 0 '\000', canSetTag = 1 '\001', transientPlan = 0 '\000', 
  dependsOnRole = 0 '\000', parallelModeNeeded = 0 '\000', planTree = 0x17a53b8, rtable = 0x1833b40, resultRelations = 0x0, nonleafResultRelations = 0x0, rootResultRelations = 0x0, 
  subplans = 0x0, rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x1833cc0, invalItems = 0x0, nParamExec = 0, utilityStmt = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n
458	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:154
154			if (needsDistributedPlanning)
(gdb) 
156				uint64 planId = NextPlanId++;
(gdb) 
158				result = CreateDistributedPlannedStmt(planId, result, originalQuery, parse,
(gdb) 

Breakpoint 5, CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:580
580		DistributedPlan *distributedPlan = NULL;
(gdb) 
581		MultiTreeRoot *logicalPlan = NULL;
(gdb) 
582		List *subPlanList = NIL;
(gdb) 
583		bool hasCtes = originalQuery->cteList != NIL;
(gdb) 
585		if (IsModifyCommand(originalQuery))
(gdb) 
636			distributedPlan = CreateRouterPlan(originalQuery, query,
(gdb) s
CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:171
171		if (MultiRouterPlannableQuery(query,
(gdb) 
MultiRouterPlannableQuery (query=0x17a49b8, restrictionContext=0x1831178) at planner/multi_router_planner.c:2844
2844		CmdType commandType = query->commandType;
(gdb) n
2845		ListCell *relationRestrictionContextCell = NULL;
(gdb) 
2847		if (commandType == CMD_INSERT || commandType == CMD_UPDATE ||
(gdb) 
2855		if (!EnableRouterExecution)
(gdb) 
2860		foreach(relationRestrictionContextCell, restrictionContext->relationRestrictionList)
(gdb) 
2862			RelationRestriction *relationRestriction =
(gdb) 
2864			RangeTblEntry *rte = relationRestriction->rte;
(gdb) 
2865			if (rte->rtekind == RTE_RELATION)
(gdb) 
2868				Oid distributedTableId = rte->relid;
(gdb) 
2869				char partitionMethod = 0;
(gdb) p distributedTableId
$7 = 41849
(gdb) n
2871				if (!IsDistributedTable(distributedTableId))
(gdb) 
2877				partitionMethod = PartitionMethod(distributedTableId);
(gdb) 
2878				if (!(partitionMethod == DISTRIBUTE_BY_HASH || partitionMethod ==
(gdb) 
2889				if (query->hasForUpdate)
(gdb) 
2860		foreach(relationRestrictionContextCell, restrictionContext->relationRestrictionList)
(gdb) 
2902		return true;
(gdb) 
2903	}
(gdb) 
CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:174
174			return CreateSingleTaskRouterPlan(originalQuery, query,
(gdb) s
CreateSingleTaskRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:251
251		Job *job = NULL;
(gdb) n
252		DistributedPlan *distributedPlan = CitusMakeNode(DistributedPlan);
(gdb) 
254		distributedPlan->operation = query->commandType;
(gdb) 
257		distributedPlan->planningError = ErrorIfQueryHasModifyingCTE(query);
(gdb) 
258		if (distributedPlan->planningError)
(gdb) 
264		job = RouterJob(originalQuery, plannerRestrictionContext,
(gdb) s
RouterJob (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, planningError=0x1832ba0) at planner/multi_router_planner.c:1586
1586		Job *job = NULL;
(gdb) n
1587		uint64 shardId = INVALID_SHARD_ID;
(gdb) 
1588		List *placementList = NIL;
(gdb) 
1589		List *relationShardList = NIL;
(gdb) 
1590		bool replacePrunedQueryWithDummy = false;
(gdb) 
1591		bool requiresMasterEvaluation = false;
(gdb) 
Socket error Event: 32 Error: 10053.
Connection closing...Socket close.

Connection closed by foreign host.

Disconnected from remote host(citus1) at 15:23:48.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Fri Mar 15 23:51:02 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ ps -ef | grep postgres
cituscl+  22179  72929  0 Mar15 ?        00:00:00 postgres: checkpointer process  
cituscl+  22180  72929  0 Mar15 ?        00:00:00 postgres: writer process   
cituscl+  22181  72929  0 Mar15 ?        00:00:00 postgres: wal writer process  
cituscl+  22182  72929  0 Mar15 ?        00:00:00 postgres: autovacuum launcher process  
cituscl+  22183  72929  0 Mar15 ?        00:00:00 postgres: stats collector process  
cituscl+  22185  72929  0 Mar15 ?        00:00:00 postgres: bgworker: task tracker  
cituscl+  22186  72929  0 Mar15 ?        00:00:00 postgres: bgworker: logical replication launcher  
cituscl+  22228  22052  0 Mar15 pts/1    00:00:00 psql -d postgres
cituscl+  22229  72929  0 Mar15 ?        00:00:00 postgres: cituscluster postgres [local] SELECT
cituscl+  22250  72929  0 Mar15 ?        00:00:01 postgres: bgworker: Citus Maintenance Daemon: 13212/16814  
cituscl+  24235  24119  0 00:30 pts/2    00:00:00 grep --color=auto postgres
cituscl+  24237  24118  0 00:30 pts/4    00:00:00 grep --color=auto postgres
cituscl+  72929      1  0 Mar15 ?        00:00:02 /opt/pgsql-10.1/bin/postgres
[cituscluster@gtm1 ~]$ ps -ef | grep gdb
cituscl+  22259  22065  0 Mar15 pts/3    00:00:02 gdb attach 22229
cituscl+  24259  24119  0 00:30 pts/2    00:00:00 grep --color=auto gdb
[cituscluster@gtm1 ~]$ gdb attach 24337
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 24337
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007f274fc22163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) 
(gdb) b pg_plan_queries
Breakpoint 1 at 0x813679: file postgres.c, line 842.
(gdb) b pg_plan_query
Breakpoint 2 at 0x8135e2: file postgres.c, line 784.
(gdb) b distributed_planner
Breakpoint 3 at 0x7f274935a96d: file planner/distributed_planner.c, line 94.
(gdb) b standard_planner
Breakpoint 4 at 0x742910: file planner.c, line 233.
(gdb) b CreateDistributedPlan
Breakpoint 5 at 0x7f274935b1c7: file planner/distributed_planner.c, line 580.
(gdb) b CreateRouterPlan
Breakpoint 6 at 0x7f2749375bf9: file planner/multi_router_planner.c, line 171.
(gdb) b CreateSingleTaskRouterPlan
Breakpoint 7 at 0x7f2749375ded: file planner/multi_router_planner.c, line 251.
(gdb) b RouterJob
Breakpoint 8 at 0x7f2749377c75: file planner/multi_router_planner.c, line 1586.
(gdb) 
Note: breakpoint 8 also set at pc 0x7f2749377c75.
Breakpoint 9 at 0x7f2749377c75: file planner/multi_router_planner.c, line 1586.
(gdb) b PrepareMasterJobDirectory
Breakpoint 10 at 0x7f274934653b: file executor/multi_real_time_executor.c, line 1069.
(gdb) b ExecuteSubPlans
Breakpoint 11 at 0x7f274934d56e: file executor/subplan_execution.c, line 35.
(gdb) b PortalStart
Breakpoint 12 at 0x818eac: file pquery.c, line 461.
(gdb) b PortalRun
Breakpoint 13 at 0x819407: file pquery.c, line 707.
(gdb) b MultiRealTimeExecute
Breakpoint 14 at 0x7f2749344c5f: file executor/multi_real_time_executor.c, line 88.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) 
WaitEventSetWaitBlock (set=0x16f8728, cur_timeout=-1, occurred_events=0x7ffe485cf350, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x16f8728, timeout=-1, occurred_events=0x7ffe485cf350, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
1000			rc = WaitEventSetWaitBlock(set, cur_timeout,
(gdb) 
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x173b3d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffe485cf560) at postgres.c:330
330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 
359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffe485cf560) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x1742288, dbname=0x1742168 "postgres", username=0x1742148 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) 
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 1, pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:842
842		List	   *stmt_list = NIL;
(gdb) 
845		foreach(query_list, querytrees)
(gdb) 
847			Query	   *query = lfirst_node(Query, query_list);
(gdb) 
850			if (query->commandType == CMD_UTILITY)
(gdb) 
862				stmt = pg_plan_query(query, cursorOptions, boundParams);
(gdb) 

Breakpoint 2, pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:784
784		if (querytree->commandType == CMD_UTILITY)
(gdb) 
792		if (log_planner_stats)
(gdb) 
796		plan = planner(querytree, cursorOptions, boundParams);
(gdb) 

Breakpoint 3, distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:94
94		PlannedStmt *result = NULL;
(gdb) 
95		bool needsDistributedPlanning = NeedsDistributedPlanning(parse);
(gdb) 
96		Query *originalQuery = NULL;
(gdb) 
97		PlannerRestrictionContext *plannerRestrictionContext = NULL;
(gdb) 
98		bool setPartitionedTablesInherited = false;
(gdb) 
100		if (cursorOptions & CURSOR_OPT_FORCE_DISTRIBUTED)
(gdb) 
105		if (needsDistributedPlanning)
(gdb) 
113			if (InsertSelectIntoLocalTable(parse))
(gdb) 
129			AssignRTEIdentities(parse);
(gdb) 
130			originalQuery = copyObject(parse);
(gdb) 
132			setPartitionedTablesInherited = false;
(gdb) 
133			AdjustPartitioningForDistributedPlanning(parse, setPartitionedTablesInherited);
(gdb) 
140		ReplaceTableVisibleFunction((Node *) parse);
(gdb) 
143		plannerRestrictionContext = CreateAndPushPlannerRestrictionContext();
(gdb) 
145		PG_TRY();
(gdb) 
152			result = standard_planner(parse, cursorOptions, boundParams);
(gdb) 

Breakpoint 4, standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:233
233		glob = makeNode(PlannerGlobal);
(gdb) 
235		glob->boundParams = boundParams;
(gdb) 
236		glob->subplans = NIL;
(gdb) 
237		glob->subroots = NIL;
(gdb) 
238		glob->rewindPlanIDs = NULL;
(gdb) 
239		glob->finalrtable = NIL;
(gdb) 
240		glob->finalrowmarks = NIL;
(gdb) 
241		glob->resultRelations = NIL;
(gdb) 
242		glob->nonleafResultRelations = NIL;
(gdb) 
243		glob->rootResultRelations = NIL;
(gdb) 
244		glob->relationOids = NIL;
(gdb) 
245		glob->invalItems = NIL;
(gdb) 
246		glob->nParamExec = 0;
(gdb) 
247		glob->lastPHId = 0;
(gdb) 
248		glob->lastRowMarkId = 0;
(gdb) 
249		glob->lastPlanNodeId = 0;
(gdb) 
250		glob->transientPlan = false;
(gdb) 
251		glob->dependsOnRole = false;
(gdb) 
273		if ((cursorOptions & CURSOR_OPT_PARALLEL_OK) != 0 &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
274			IsUnderPostmaster &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
280			!IsolationIsSerializable())
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
283			glob->maxParallelHazard = max_parallel_hazard(parse);
(gdb) 
284			glob->parallelModeOK = (glob->maxParallelHazard != PROPARALLEL_UNSAFE);
(gdb) 
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
303			(force_parallel_mode != FORCE_PARALLEL_OFF);
(gdb) 
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
306		if (cursorOptions & CURSOR_OPT_FAST_PLAN)
(gdb) 
330			tuple_fraction = 0.0;
(gdb) 
334		root = subquery_planner(glob, parse, NULL,
(gdb) 
338		final_rel = fetch_upper_rel(root, UPPERREL_FINAL, NULL);
(gdb) 
339		best_path = get_cheapest_fractional_path(final_rel, tuple_fraction);
(gdb) 
341		top_plan = create_plan(root, best_path);
(gdb) 
347		if (cursorOptions & CURSOR_OPT_SCROLL)
(gdb) 
357		if (force_parallel_mode != FORCE_PARALLEL_OFF && top_plan->parallel_safe)
(gdb) 
400		if (glob->nParamExec > 0)
(gdb) 
419		top_plan = set_plan_references(root, top_plan);
(gdb) 
422		forboth(lp, glob->subplans, lr, glob->subroots)
(gdb) 
431		result = makeNode(PlannedStmt);
(gdb) 
433		result->commandType = parse->commandType;
(gdb) 
434		result->queryId = parse->queryId;
(gdb) 
435		result->hasReturning = (parse->returningList != NIL);
(gdb) 
436		result->hasModifyingCTE = parse->hasModifyingCTE;
(gdb) 
437		result->canSetTag = parse->canSetTag;
(gdb) 
438		result->transientPlan = glob->transientPlan;
(gdb) 
439		result->dependsOnRole = glob->dependsOnRole;
(gdb) 
440		result->parallelModeNeeded = glob->parallelModeNeeded;
(gdb) 
441		result->planTree = top_plan;
(gdb) 
442		result->rtable = glob->finalrtable;
(gdb) 
443		result->resultRelations = glob->resultRelations;
(gdb) 
444		result->nonleafResultRelations = glob->nonleafResultRelations;
(gdb) 
445		result->rootResultRelations = glob->rootResultRelations;
(gdb) 
446		result->subplans = glob->subplans;
(gdb) 
447		result->rewindPlanIDs = glob->rewindPlanIDs;
(gdb) 
448		result->rowMarks = glob->finalrowmarks;
(gdb) 
449		result->relationOids = glob->relationOids;
(gdb) 
450		result->invalItems = glob->invalItems;
(gdb) 
451		result->nParamExec = glob->nParamExec;
(gdb) 
453		result->utilityStmt = parse->utilityStmt;
(gdb) 
454		result->stmt_location = parse->stmt_location;
(gdb) 
455		result->stmt_len = parse->stmt_len;
(gdb) 
457		return result;
(gdb) 
458	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:154
154			if (needsDistributedPlanning)
(gdb) 
156				uint64 planId = NextPlanId++;
(gdb) 
158				result = CreateDistributedPlannedStmt(planId, result, originalQuery, parse,
(gdb) p *result
$1 = {type = T_PlannedStmt, commandType = CMD_SELECT, queryId = 0, hasReturning = 0 '\000', hasModifyingCTE = 0 '\000', canSetTag = 1 '\001', transientPlan = 0 '\000', 
  dependsOnRole = 0 '\000', parallelModeNeeded = 0 '\000', planTree = 0x17a53b8, rtable = 0x1833b40, resultRelations = 0x0, nonleafResultRelations = 0x0, rootResultRelations = 0x0, 
  subplans = 0x0, rewindPlanIDs = 0x0, rowMarks = 0x0, relationOids = 0x1833cc0, invalItems = 0x0, nParamExec = 0, utilityStmt = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) n

Breakpoint 5, CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:580
580		DistributedPlan *distributedPlan = NULL;
(gdb) 
581		MultiTreeRoot *logicalPlan = NULL;
(gdb) 
582		List *subPlanList = NIL;
(gdb) 
583		bool hasCtes = originalQuery->cteList != NIL;
(gdb) 
585		if (IsModifyCommand(originalQuery))
(gdb) 
636			distributedPlan = CreateRouterPlan(originalQuery, query,
(gdb) 

Breakpoint 6, CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:171
171		if (MultiRouterPlannableQuery(query,
(gdb) 
174			return CreateSingleTaskRouterPlan(originalQuery, query,
(gdb) 

Breakpoint 7, CreateSingleTaskRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:251
251		Job *job = NULL;
(gdb) n
252		DistributedPlan *distributedPlan = CitusMakeNode(DistributedPlan);
(gdb) 
254		distributedPlan->operation = query->commandType;
(gdb) 
257		distributedPlan->planningError = ErrorIfQueryHasModifyingCTE(query);
(gdb) 
258		if (distributedPlan->planningError)
(gdb) 
264		job = RouterJob(originalQuery, plannerRestrictionContext,
(gdb) 

Breakpoint 8, RouterJob (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, planningError=0x1832ba0) at planner/multi_router_planner.c:1586
1586		Job *job = NULL;
(gdb) n
1587		uint64 shardId = INVALID_SHARD_ID;
(gdb) 
1588		List *placementList = NIL;
(gdb) 
1589		List *relationShardList = NIL;
(gdb) 
1590		bool replacePrunedQueryWithDummy = false;
(gdb) 
1591		bool requiresMasterEvaluation = false;
(gdb) 
1592		RangeTblEntry *updateOrDeleteRTE = NULL;
(gdb) 
1593		bool isMultiShardModifyQuery = false;
(gdb) 
1594		Const *partitionKeyValue = NULL;
(gdb) 
1597		replacePrunedQueryWithDummy = true;
(gdb) 
1600		requiresMasterEvaluation = RequiresMasterEvaluation(originalQuery);
(gdb) s
RequiresMasterEvaluation (query=0x17a4f58) at utils/citus_clauses.c:45
45		return FindNodeCheck((Node *) query, CitusIsMutableFunction);
(gdb) s
46	}
(gdb) n
RouterJob (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, planningError=0x1832ba0) at planner/multi_router_planner.c:1602
1602		(*planningError) = PlanRouterQuery(originalQuery, plannerRestrictionContext,
(gdb) p originalQuery
$2 = (Query *) 0x17a4f58
(gdb) p *originalQuery
$3 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x1830808, jointree = 0x1830e60, targetList = 0x1830ef8, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) s
PlanRouterQuery (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, placementList=0x7ffe485cef68, anchorShardId=0x7ffe485cef70, relationShardList=0x7ffe485cef60, 
    replacePrunedQueryWithDummy=1 '\001', multiShardModifyQuery=0x7ffe485cef5f "", partitionValueConst=0x7ffe485cef50) at planner/multi_router_planner.c:1880
1880		bool isMultiShardQuery = false;
(gdb) bt
#0  PlanRouterQuery (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, placementList=0x7ffe485cef68, anchorShardId=0x7ffe485cef70, relationShardList=0x7ffe485cef60, 
    replacePrunedQueryWithDummy=1 '\001', multiShardModifyQuery=0x7ffe485cef5f "", partitionValueConst=0x7ffe485cef50) at planner/multi_router_planner.c:1880
#1  0x00007f2749377cf6 in RouterJob (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, planningError=0x1832ba0) at planner/multi_router_planner.c:1602
#2  0x00007f2749375e96 in CreateSingleTaskRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:264
#3  0x00007f2749375c2a in CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:174
#4  0x00007f274935b2c5 in CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:636
#5  0x00007f274935b07f in CreateDistributedPlannedStmt (planId=1, localPlan=0x18324e0, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:498
#6  0x00007f274935ab2e in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:158
#7  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#8  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#9  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#10 0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#11 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1742288, dbname=0x1742168 "postgres", username=0x1742148 "cituscluster") at postgres.c:4088
#12 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#13 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#14 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#15 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#16 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
1881		List *prunedRelationShardList = NIL;
(gdb) 
1882		DeferredErrorMessage *planningError = NULL;
(gdb) 
1883		ListCell *prunedRelationShardListCell = NULL;
(gdb) 
1884		List *workerList = NIL;
(gdb) 
1885		bool shardsPresent = false;
(gdb) 
1886		uint64 shardId = INVALID_SHARD_ID;
(gdb) 
1887		CmdType commandType = originalQuery->commandType;
(gdb) 
1889		*placementList = NIL;
(gdb) 
1891		prunedRelationShardList = TargetShardIntervalsForQuery(originalQuery,
(gdb) s
TargetShardIntervalsForQuery (query=0x17a4f58, restrictionContext=0x1831178, multiShardQuery=0x7ffe485cee87 "", partitionValueConst=0x7ffe485cef50) at planner/multi_router_planner.c:2084
2084		List *prunedRelationShardList = NIL;
(gdb) n
2085		ListCell *restrictionCell = NULL;
(gdb) 
2086		bool multiplePartitionValuesExist = false;
(gdb) 
2087		Const *queryPartitionValueConst = NULL;
(gdb) 
2091		foreach(restrictionCell, restrictionContext->relationRestrictionList)
(gdb) 
2093			RelationRestriction *relationRestriction =
(gdb) 
2095			Oid relationId = relationRestriction->relationId;
(gdb) 
2096			Index tableId = relationRestriction->index;
(gdb) 
2097			DistTableCacheEntry *cacheEntry = DistributedTableCacheEntry(relationId);
(gdb) p relationId
$4 = 41849
(gdb) p tableId
$5 = 2
(gdb) n
2098			int shardCount = cacheEntry->shardIntervalArrayLength;
(gdb) p *cacheEntry
$6 = {relationId = 41849, isValid = 1 '\001', isDistributedTable = 1 '\001', hasUninitializedShardInterval = 0 '\000', hasUniformHashDistribution = 1 '\001', 
  hasOverlappingShardInterval = 0 '\000', 
  partitionKeyString = 0x7f2750a1cea8 "{VAR :varno 1 :varattno 1 :vartype 23 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location -1}", 
  partitionColumn = 0x7f2750a1cf38, partitionMethod = 104 'h', colocationId = 0, replicationModel = 99 'c', shardIntervalArrayLength = 3, sortedShardIntervalArray = 0x7f2750a1df38, 
  shardColumnCompareFunction = 0x7f2750a1e418, shardIntervalCompareFunction = 0x7f2750a1e468, hashFunction = 0x7f275095fd38, referencedRelationsViaForeignKey = 0x0, 
  referencingRelationsViaForeignKey = 0x0, arrayOfPlacementArrays = 0x7f2750a1e218, arrayOfPlacementArrayLengths = 0x7f2750a1e248}
(gdb) n
2099			List *baseRestrictionList = relationRestriction->relOptInfo->baserestrictinfo;
(gdb) 
2100			List *restrictClauseList = get_all_actual_clauses(baseRestrictionList);
(gdb) p baseRestrictionList
$7 = (List *) 0x1832a28
(gdb) p *baseRestrictionList
$8 = {type = T_List, length = 1, head = 0x1832570, tail = 0x1832570}
(gdb) p baseRestrictionList->head
$9 = (ListCell *) 0x1832570
(gdb) p *baseRestrictionList->head
$10 = {data = {ptr_value = 0x1832180, int_value = 25371008, oid_value = 25371008}, next = 0x0}
(gdb) p *baseRestrictionList->head->data.ptr
There is no member named ptr.
(gdb) p *baseRestrictionList->head->data.ptr_value
Attempt to dereference a generic pointer.
(gdb) p baseRestrictionList->head->data.ptr_value
$11 = (void *) 0x1832180
(gdb) n
2101			List *prunedShardList = NIL;
(gdb) 
2102			List *joinInfoList = relationRestriction->relOptInfo->joininfo;
(gdb) 
2103			List *pseudoRestrictionList = extract_actual_clauses(joinInfoList, true);
(gdb) 
2104			bool whereFalseQuery = false;
(gdb) p *restrictClauseList
$12 = {type = T_List, length = 1, head = 0x18342c0, tail = 0x18342c0}
(gdb) p *restrictClauseList->head
$13 = {data = {ptr_value = 0x1831d68, int_value = 25369960, oid_value = 25369960}, next = 0x0}
(gdb) p *restrictClauseList->head->data.ptr_value
Attempt to dereference a generic pointer.
(gdb) p restrictClauseList->head->data.ptr_value
$14 = (void *) 0x1831d68
(gdb) n
2106			relationRestriction->prunedShardIntervalList = NIL;
(gdb) 
2114			whereFalseQuery = ContainsFalseClause(pseudoRestrictionList);
(gdb) s
ContainsFalseClause (whereClauseList=0x0) at planner/shard_pruning.c:398
398		bool containsFalseClause = false;
(gdb) n
399		ListCell *clauseCell = NULL;
(gdb) 
401		foreach(clauseCell, whereClauseList)
(gdb) 
416		return containsFalseClause;
(gdb) 
417	}
(gdb) 
TargetShardIntervalsForQuery (query=0x17a4f58, restrictionContext=0x1831178, multiShardQuery=0x7ffe485cee87 "", partitionValueConst=0x7ffe485cef50) at planner/multi_router_planner.c:2115
2115			if (!whereFalseQuery && shardCount > 0)
(gdb) p shardCount
$15 = 3
(gdb) p cacheEntry->sortedShardIntervalArray
$16 = (ShardInterval **) 0x7f2750a1df38
(gdb) p *cacheEntry->sortedShardIntervalArray
$17 = (ShardInterval *) 0x7f2750a1e388
(gdb) p **cacheEntry->sortedShardIntervalArray
$18 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d047e "ShardInterval"}, citus_tag = T_ShardInterval}, relationId = 41849, storageType = 116 't', 
  valueTypeId = 23, valueTypeLen = 4, valueByVal = 1 '\001', minValueExists = 1 '\001', maxValueExists = 1 '\001', minValue = 2147483648, maxValue = 3579139412, shardId = 102687, 
  shardIndex = 0}
(gdb) p **cacheEntry->sortedShardIntervalArray[1]
Structure has no component named operator*.
(gdb) p **cacheEntry->sortedShardIntervalArray[2]
Structure has no component named operator*.
(gdb) p *cacheEntry->sortedShardIntervalArray[2]
$19 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d047e "ShardInterval"}, citus_tag = T_ShardInterval}, relationId = 41849, storageType = 116 't', 
  valueTypeId = 23, valueTypeLen = 4, valueByVal = 1 '\001', minValueExists = 1 '\001', maxValueExists = 1 '\001', minValue = 715827882, maxValue = 2147483647, shardId = 102689, 
  shardIndex = 2}
(gdb) p *cacheEntry->sortedShardIntervalArray[1]
$20 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d047e "ShardInterval"}, citus_tag = T_ShardInterval}, relationId = 41849, storageType = 116 't', 
  valueTypeId = 23, valueTypeLen = 4, valueByVal = 1 '\001', minValueExists = 1 '\001', maxValueExists = 1 '\001', minValue = 3579139413, maxValue = 715827881, shardId = 102688, 
  shardIndex = 1}
(gdb) n
2117				Const *restrictionPartitionValueConst = NULL;
(gdb) 
2118				prunedShardList = PruneShards(relationId, tableId, restrictClauseList,
(gdb) s
PruneShards (relationId=41849, rangeTableId=2, whereClauseList=0x1834290, partitionValueConst=0x7ffe485cedb8) at planner/shard_pruning.c:222
222		DistTableCacheEntry *cacheEntry = DistributedTableCacheEntry(relationId);
(gdb) n
223		int shardCount = cacheEntry->shardIntervalArrayLength;
(gdb) 
224		char partitionMethod = cacheEntry->partitionMethod;
(gdb) 
225		ClauseWalkerContext context = { 0 };
(gdb) 
227		List *prunedList = NIL;
(gdb) 
228		bool foundRestriction = false;
(gdb) 
229		bool foundPartitionColumnValue = false;
(gdb) 
230		Const *singlePartitionValueConst = NULL;
(gdb) 
233		if (shardCount == 0)
(gdb) 
239		if (ContainsFalseClause(whereClauseList))
(gdb) s
ContainsFalseClause (whereClauseList=0x1834290) at planner/shard_pruning.c:398
398		bool containsFalseClause = false;
(gdb) n
399		ListCell *clauseCell = NULL;
(gdb) 
401		foreach(clauseCell, whereClauseList)
(gdb) 
403			Node *clause = (Node *) lfirst(clauseCell);
(gdb) 
405			if (IsA(clause, Const))
(gdb) p clause->type
$21 = T_OpExpr
(gdb) n
401		foreach(clauseCell, whereClauseList)
(gdb) 
416		return containsFalseClause;
(gdb) n
417	}
(gdb) 
PruneShards (relationId=41849, rangeTableId=2, whereClauseList=0x1834290, partitionValueConst=0x7ffe485cedb8) at planner/shard_pruning.c:245
245		if (partitionMethod == DISTRIBUTE_BY_NONE)
(gdb) 
253		context.partitionMethod = partitionMethod;
(gdb) p partitionMethod
$22 = 104 'h'
(gdb) n
254		context.partitionColumn = PartitionColumn(relationId, rangeTableId);
(gdb) 
255		context.currentPruningInstance = palloc0(sizeof(PruningInstance));
(gdb) 
257		if (cacheEntry->shardIntervalCompareFunction)
(gdb) p context
$23 = {partitionColumn = 0x18342e0, partitionMethod = 104 'h', pruningInstances = 0x0, pendingInstances = 0x0, currentPruningInstance = 0x1834150, compareValueFunctionCall = {flinfo = 0x0, 
    context = 0x0, resultinfo = 0x0, fncollation = 0, isnull = 0 '\000', nargs = 0, arg = {0 <repeats 100 times>}, argnull = '\000' <repeats 99 times>}, compareIntervalFunctionCall = {
    flinfo = 0x0, context = 0x0, resultinfo = 0x0, fncollation = 0, isnull = 0 '\000', nargs = 0, arg = {0 <repeats 100 times>}, argnull = '\000' <repeats 99 times>}}
(gdb) p context.partitionColumn
$24 = (Var *) 0x18342e0
(gdb) p *context.partitionColumn
$25 = {xpr = {type = T_Var}, varno = 2, varattno = 1, vartype = 23, vartypmod = -1, varcollid = 0, varlevelsup = 0, varnoold = 2, varoattno = 1, location = -1}
(gdb) n
260			InitFunctionCallInfoData(context.compareIntervalFunctionCall,
(gdb) 
270		if (cacheEntry->shardColumnCompareFunction)
(gdb) 
273			InitFunctionCallInfoData(context.compareValueFunctionCall,
(gdb) n
284		PrunableExpressions((Node *) whereClauseList, &context);
(gdb) 
290		foreach(pruneCell, context.pruningInstances)
(gdb) 
292			PruningInstance *prune = (PruningInstance *) lfirst(pruneCell);
(gdb) 
299			if (prune->isPartial)
(gdb) p *prune
$26 = {hasValidConstraint = 1 '\001', evaluatesToFalse = 0 '\000', lessConsts = 0x0, lessEqualConsts = 0x0, equalConsts = 0x0, greaterEqualConsts = 0x0, greaterConsts = 0x1831cf8, 
  hashedEqualConsts = 0x0, otherRestrictions = 0x0, addedToPruningInstances = 1 '\001', isPartial = 0 '\000'}
(gdb) n
308			if (!prune->hasValidConstraint)
(gdb) 
314			if (context.partitionMethod == DISTRIBUTE_BY_HASH)
(gdb) n
316				if (!prune->evaluatesToFalse && !prune->equalConsts &&
(gdb) 
317					!prune->hashedEqualConsts)
(gdb) 
316				if (!prune->evaluatesToFalse && !prune->equalConsts &&
(gdb) 
320					foundRestriction = false;
(gdb) 
321					break;
(gdb) 
364		if (!foundRestriction)
(gdb) 
366			prunedList = ShardArrayToList(cacheEntry->sortedShardIntervalArray,
(gdb) 
371		if (partitionValueConst != NULL)
(gdb) p prunedList
$27 = (List *) 0x183af18
(gdb) p *prunedList
$28 = {type = T_List, length = 3, head = 0x183aef8, tail = 0x183af68}
(gdb) n
373			if (singlePartitionValueConst != NULL)
(gdb) 
379				*partitionValueConst = NULL;
(gdb) 
387		return DeepCopyShardIntervalList(prunedList);
(gdb) s
DeepCopyShardIntervalList (originalShardIntervalList=0x183af18) at planner/shard_pruning.c:917
917		List *copiedShardIntervalList = NIL;
(gdb) n
918		ListCell *shardIntervalCell = NULL;
(gdb) 
920		foreach(shardIntervalCell, originalShardIntervalList)
(gdb) 
922			ShardInterval *originalShardInterval =
(gdb) 
924			ShardInterval *copiedShardInterval =
(gdb) 
927			CopyShardInterval(originalShardInterval, copiedShardInterval);
(gdb) p *originalShardInterval
$29 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d047e "ShardInterval"}, citus_tag = T_ShardInterval}, relationId = 41849, storageType = 116 't', 
  valueTypeId = 23, valueTypeLen = 4, valueByVal = 1 '\001', minValueExists = 1 '\001', maxValueExists = 1 '\001', minValue = 2147483648, maxValue = 3579139412, shardId = 102687, 
  shardIndex = 0}
(gdb) n
928			copiedShardIntervalList = lappend(copiedShardIntervalList, copiedShardInterval);
(gdb) 
920		foreach(shardIntervalCell, originalShardIntervalList)
(gdb) 
922			ShardInterval *originalShardInterval =
(gdb) 
924			ShardInterval *copiedShardInterval =
(gdb) 
927			CopyShardInterval(originalShardInterval, copiedShardInterval);
(gdb) p *originalShardInterval
$30 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d047e "ShardInterval"}, citus_tag = T_ShardInterval}, relationId = 41849, storageType = 116 't', 
  valueTypeId = 23, valueTypeLen = 4, valueByVal = 1 '\001', minValueExists = 1 '\001', maxValueExists = 1 '\001', minValue = 3579139413, maxValue = 715827881, shardId = 102688, 
  shardIndex = 1}
(gdb) n
928			copiedShardIntervalList = lappend(copiedShardIntervalList, copiedShardInterval);
(gdb) 
920		foreach(shardIntervalCell, originalShardIntervalList)
(gdb) 
922			ShardInterval *originalShardInterval =
(gdb) 
924			ShardInterval *copiedShardInterval =
(gdb) 
927			CopyShardInterval(originalShardInterval, copiedShardInterval);
(gdb) p *originalShardInterval
$31 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d047e "ShardInterval"}, citus_tag = T_ShardInterval}, relationId = 41849, storageType = 116 't', 
  valueTypeId = 23, valueTypeLen = 4, valueByVal = 1 '\001', minValueExists = 1 '\001', maxValueExists = 1 '\001', minValue = 715827882, maxValue = 2147483647, shardId = 102689, 
  shardIndex = 2}
(gdb) n
928			copiedShardIntervalList = lappend(copiedShardIntervalList, copiedShardInterval);
(gdb) 
920		foreach(shardIntervalCell, originalShardIntervalList)
(gdb) 
931		return copiedShardIntervalList;
(gdb) 
932	}
(gdb) 
PruneShards (relationId=41849, rangeTableId=2, whereClauseList=0x1834290, partitionValueConst=0x7ffe485cedb8) at planner/shard_pruning.c:388
388	}
(gdb) 
TargetShardIntervalsForQuery (query=0x17a4f58, restrictionContext=0x1831178, multiShardQuery=0x7ffe485cee87 "", partitionValueConst=0x7ffe485cef50) at planner/multi_router_planner.c:2121
2121				if (list_length(prunedShardList) > 1)
(gdb) 
2123					(*multiShardQuery) = true;
(gdb) 
2125				if (restrictionPartitionValueConst != NULL &&
(gdb) 
2130				else if (restrictionPartitionValueConst != NULL &&
(gdb) 
2137			relationRestriction->prunedShardIntervalList = prunedShardList;
(gdb) 
2138			prunedRelationShardList = lappend(prunedRelationShardList, prunedShardList);
(gdb) 
2091		foreach(restrictionCell, restrictionContext->relationRestrictionList)
(gdb) 
2145		if (multiplePartitionValuesExist)
(gdb) 
2151		if (partitionValueConst != NULL)
(gdb) 
2153			*partitionValueConst = queryPartitionValueConst;
(gdb) 
2156		return prunedRelationShardList;
(gdb) 
2157	}
(gdb) 
PlanRouterQuery (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, placementList=0x7ffe485cef68, anchorShardId=0x7ffe485cef70, relationShardList=0x7ffe485cef60, 
    replacePrunedQueryWithDummy=1 '\001', multiShardModifyQuery=0x7ffe485cef5f "", partitionValueConst=0x7ffe485cef50) at planner/multi_router_planner.c:1897
1897		if (isMultiShardQuery)
(gdb) 
1904			if (commandType == CMD_SELECT)
(gdb) n
1906				planningError = DeferredError(ERRCODE_FEATURE_NOT_SUPPORTED,
(gdb) 
1908				return planningError;
(gdb) p plann
planner                                     planner/multi_join_order.c                  planner/query_pushdown_planning.c           planner_cxt
planner.c                                   planner/multi_logical_optimizer.c           planner/recursive_planning.c                planner_hook
planner.h                                   planner/multi_logical_planner.c             planner/relation_restriction_equivalence.c  planner_hook_type
planner/deparse_shard_query.c               planner/multi_master_planner.c              planner/shard_pruning.c                     planningError
planner/distributed_planner.c               planner/multi_physical_planner.c            planner@plt                                 plannodes.h
planner/extended_op_node_utils.c            planner/multi_router_planner.c              plannerInfo                                 
planner/insert_select_planner.c             planner/postgres_planning_functions.c       plannerRestrictionContext                   
planner/multi_explain.c                     planner/query_colocation_checker.c          plannerRestrictionContextList               
(gdb) p planningError 
$32 = (DeferredErrorMessage *) 0x183b0f8
(gdb) 
$33 = (DeferredErrorMessage *) 0x183b0f8
(gdb) 
$34 = (DeferredErrorMessage *) 0x183b0f8
(gdb) p *planningError 
$35 = {tag = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d04b9 "DeferredErrorMessage"}, citus_tag = T_DeferredErrorMessage}, code = 1088, message = 0x0, detail = 0x0, 
  hint = 0x0, filename = 0x7f27493cb6d8 "planner/multi_router_planner.c", linenumber = 1907, functionname = 0x7f27493cc3d0 <__func__.32363> "PlanRouterQuery"}
(gdb) n
2038	}
(gdb) 
RouterJob (originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148, planningError=0x1832ba0) at planner/multi_router_planner.c:1607
1607		if (*planningError)
(gdb) 
1609			return NULL;
(gdb) 
Socket error Event: 32 Error: 10053.
Connection closing...Socket close.

Connection closed by foreign host.

Disconnected from remote host(citus1) at 16:55:44.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Sat Mar 16 03:02:15 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ ps -ef | grep gdb
cituscl+  24356  24119  0 01:17 pts/2    00:00:13 gdb attach 24337
cituscl+  30659  30538  0 03:02 pts/3    00:00:00 grep --color=auto gdb
[cituscluster@gtm1 ~]$ ps -ef | grep postgres
cituscl+  24320  72929  0 01:16 ?        00:00:00 postgres: checkpointer process  
cituscl+  24321  72929  0 01:16 ?        00:00:00 postgres: writer process   
cituscl+  24322  72929  0 01:16 ?        00:00:00 postgres: wal writer process  
cituscl+  24323  72929  0 01:16 ?        00:00:00 postgres: autovacuum launcher process  
cituscl+  24324  72929  0 01:16 ?        00:00:00 postgres: stats collector process  
cituscl+  24326  72929  0 01:16 ?        00:00:02 postgres: bgworker: task tracker  
cituscl+  24327  72929  0 01:16 ?        00:00:00 postgres: bgworker: logical replication launcher  
cituscl+  24336  24118  0 01:16 pts/4    00:00:00 psql -d postgres
cituscl+  24337  72929  0 01:16 ?        00:00:00 postgres: cituscluster postgres [local] SELECT
cituscl+  24346  72929  0 01:17 ?        00:00:06 postgres: bgworker: Citus Maintenance Daemon: 13212/16814  
cituscl+  30664  30538  0 03:02 pts/3    00:00:00 grep --color=auto postgres
cituscl+  72929      1  0 Mar15 ?        00:00:02 /opt/pgsql-10.1/bin/postgres
[cituscluster@gtm1 ~]$ kill -9 24356
[cituscluster@gtm1 ~]$ ps -ef | grep postgres
cituscl+  30689  72929  0 03:03 ?        00:00:00 postgres: checkpointer process  
cituscl+  30690  72929  0 03:03 ?        00:00:00 postgres: writer process   
cituscl+  30691  72929  0 03:03 ?        00:00:00 postgres: wal writer process  
cituscl+  30692  72929  0 03:03 ?        00:00:00 postgres: autovacuum launcher process  
cituscl+  30693  72929  0 03:03 ?        00:00:00 postgres: stats collector process  
cituscl+  30695  72929  0 03:03 ?        00:00:00 postgres: bgworker: task tracker  
cituscl+  30696  72929  0 03:03 ?        00:00:00 postgres: bgworker: logical replication launcher  
cituscl+  30700  30538  0 03:03 pts/3    00:00:00 grep --color=auto postgres
cituscl+  72929      1  0 Mar15 ?        00:00:02 /opt/pgsql-10.1/bin/postgres
[cituscluster@gtm1 ~]$ gdb attach 30713
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 30713
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007f274fc22163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) b pg_plan_queries
Breakpoint 1 at 0x813679: file postgres.c, line 842.
(gdb) b pg_plan_query
Breakpoint 2 at 0x8135e2: file postgres.c, line 784.
(gdb) b distributed_planner
Breakpoint 3 at 0x7f274935a96d: file planner/distributed_planner.c, line 94.
(gdb) b standard_planner
Breakpoint 4 at 0x742910: file planner.c, line 233.
(gdb) b CreateDistributedPlan
Breakpoint 5 at 0x7f274935b1c7: file planner/distributed_planner.c, line 580.
(gdb) b CreateRouterPlan
Breakpoint 6 at 0x7f2749375bf9: file planner/multi_router_planner.c, line 171.
(gdb) b CreateSingleTaskRouterPlan
Breakpoint 7 at 0x7f2749375ded: file planner/multi_router_planner.c, line 251.
(gdb) 
Note: breakpoint 7 also set at pc 0x7f2749375ded.
Breakpoint 8 at 0x7f2749375ded: file planner/multi_router_planner.c, line 251.
(gdb) b PrepareMasterJobDirectory
Breakpoint 9 at 0x7f274934653b: file executor/multi_real_time_executor.c, line 1069.
(gdb) b ExecuteSubPlans
Breakpoint 10 at 0x7f274934d56e: file executor/subplan_execution.c, line 35.
(gdb) b PortalStart
Breakpoint 11 at 0x818eac: file pquery.c, line 461.
(gdb) b PortalRun
Breakpoint 12 at 0x819407: file pquery.c, line 707.
(gdb) b MultiRealTimeExecute
Breakpoint 13 at 0x7f2749344c5f: file executor/multi_real_time_executor.c, line 88.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) 
WaitEventSetWaitBlock (set=0x16f8728, cur_timeout=-1, occurred_events=0x7ffe485cf350, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 

WaitEventSetWait (set=0x16f8728, timeout=-1, occurred_events=0x7ffe485cf350, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
984				occurred_events->fd = PGINVALID_SOCKET;
(gdb) 
985				occurred_events->pos = set->latch_pos;
(gdb) 
987					set->events[set->latch_pos].user_data;
(gdb) 
986				occurred_events->user_data =
(gdb) 
988				occurred_events->events = WL_LATCH_SET;
(gdb) 
989				occurred_events++;
(gdb) 
990				returned_events++;
(gdb) 
992				break;
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x173b3d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
194				ResetLatch(MyLatch);
(gdb) 
195				ProcessClientReadInterrupt(true);
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffe485cf560) at postgres.c:330
330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 
359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffe485cf560) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x1742798, dbname=0x1742678 "postgres", username=0x1742658 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) 
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 1, pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:842
842		List	   *stmt_list = NIL;
(gdb) 
845		foreach(query_list, querytrees)
(gdb) 
847			Query	   *query = lfirst_node(Query, query_list);
(gdb) 
850			if (query->commandType == CMD_UTILITY)
(gdb) 
862				stmt = pg_plan_query(query, cursorOptions, boundParams);
(gdb) 

Breakpoint 2, pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:784
784		if (querytree->commandType == CMD_UTILITY)
(gdb) 
792		if (log_planner_stats)
(gdb) 
796		plan = planner(querytree, cursorOptions, boundParams);
(gdb) 

Breakpoint 3, distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:94
94		PlannedStmt *result = NULL;
(gdb) 
95		bool needsDistributedPlanning = NeedsDistributedPlanning(parse);
(gdb) 
96		Query *originalQuery = NULL;
(gdb) 
97		PlannerRestrictionContext *plannerRestrictionContext = NULL;
(gdb) 
98		bool setPartitionedTablesInherited = false;
(gdb) 
100		if (cursorOptions & CURSOR_OPT_FORCE_DISTRIBUTED)
(gdb) 
105		if (needsDistributedPlanning)
(gdb) 
113			if (InsertSelectIntoLocalTable(parse))
(gdb) 
129			AssignRTEIdentities(parse);
(gdb) 
130			originalQuery = copyObject(parse);
(gdb) 
132			setPartitionedTablesInherited = false;
(gdb) 
133			AdjustPartitioningForDistributedPlanning(parse, setPartitionedTablesInherited);
(gdb) 
140		ReplaceTableVisibleFunction((Node *) parse);
(gdb) 
143		plannerRestrictionContext = CreateAndPushPlannerRestrictionContext();
(gdb) 
145		PG_TRY();
(gdb) 
152			result = standard_planner(parse, cursorOptions, boundParams);
(gdb) 

Breakpoint 4, standard_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:233
233		glob = makeNode(PlannerGlobal);
(gdb) 
235		glob->boundParams = boundParams;
(gdb) 
236		glob->subplans = NIL;
(gdb) 
237		glob->subroots = NIL;
(gdb) 
238		glob->rewindPlanIDs = NULL;
(gdb) 
239		glob->finalrtable = NIL;
(gdb) 
240		glob->finalrowmarks = NIL;
(gdb) 
241		glob->resultRelations = NIL;
(gdb) 
242		glob->nonleafResultRelations = NIL;
(gdb) 
243		glob->rootResultRelations = NIL;
(gdb) 
244		glob->relationOids = NIL;
(gdb) 
245		glob->invalItems = NIL;
(gdb) 
246		glob->nParamExec = 0;
(gdb) 
247		glob->lastPHId = 0;
(gdb) 
248		glob->lastRowMarkId = 0;
(gdb) 
249		glob->lastPlanNodeId = 0;
(gdb) 
250		glob->transientPlan = false;
(gdb) 
251		glob->dependsOnRole = false;
(gdb) 
273		if ((cursorOptions & CURSOR_OPT_PARALLEL_OK) != 0 &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
274			IsUnderPostmaster &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
275			dynamic_shared_memory_type != DSM_IMPL_NONE &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
276			parse->commandType == CMD_SELECT &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
277			!parse->hasModifyingCTE &&
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
278			max_parallel_workers_per_gather > 0 &&
(gdb) 
280			!IsolationIsSerializable())
(gdb) 
279			!IsParallelWorker() &&
(gdb) 
283			glob->maxParallelHazard = max_parallel_hazard(parse);
(gdb) 
284			glob->parallelModeOK = (glob->maxParallelHazard != PROPARALLEL_UNSAFE);
(gdb) 
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
303			(force_parallel_mode != FORCE_PARALLEL_OFF);
(gdb) 
302		glob->parallelModeNeeded = glob->parallelModeOK &&
(gdb) 
306		if (cursorOptions & CURSOR_OPT_FAST_PLAN)
(gdb) 
330			tuple_fraction = 0.0;
(gdb) 
334		root = subquery_planner(glob, parse, NULL,
(gdb) 
338		final_rel = fetch_upper_rel(root, UPPERREL_FINAL, NULL);
(gdb) 
339		best_path = get_cheapest_fractional_path(final_rel, tuple_fraction);
(gdb) 
341		top_plan = create_plan(root, best_path);
(gdb) 
347		if (cursorOptions & CURSOR_OPT_SCROLL)
(gdb) 
357		if (force_parallel_mode != FORCE_PARALLEL_OFF && top_plan->parallel_safe)
(gdb) 
400		if (glob->nParamExec > 0)
(gdb) 
419		top_plan = set_plan_references(root, top_plan);
(gdb) 
422		forboth(lp, glob->subplans, lr, glob->subroots)
(gdb) 
431		result = makeNode(PlannedStmt);
(gdb) 
433		result->commandType = parse->commandType;
(gdb) 
434		result->queryId = parse->queryId;
(gdb) 
435		result->hasReturning = (parse->returningList != NIL);
(gdb) 
436		result->hasModifyingCTE = parse->hasModifyingCTE;
(gdb) 
437		result->canSetTag = parse->canSetTag;
(gdb) 
438		result->transientPlan = glob->transientPlan;
(gdb) 
439		result->dependsOnRole = glob->dependsOnRole;
(gdb) 
440		result->parallelModeNeeded = glob->parallelModeNeeded;
(gdb) 
441		result->planTree = top_plan;
(gdb) 
442		result->rtable = glob->finalrtable;
(gdb) 
443		result->resultRelations = glob->resultRelations;
(gdb) 
444		result->nonleafResultRelations = glob->nonleafResultRelations;
(gdb) 
445		result->rootResultRelations = glob->rootResultRelations;
(gdb) 
446		result->subplans = glob->subplans;
(gdb) 
447		result->rewindPlanIDs = glob->rewindPlanIDs;
(gdb) 
448		result->rowMarks = glob->finalrowmarks;
(gdb) 
449		result->relationOids = glob->relationOids;
(gdb) 
450		result->invalItems = glob->invalItems;
(gdb) 
451		result->nParamExec = glob->nParamExec;
(gdb) 
453		result->utilityStmt = parse->utilityStmt;
(gdb) 
454		result->stmt_location = parse->stmt_location;
(gdb) 
455		result->stmt_len = parse->stmt_len;
(gdb) 
457		return result;
(gdb) 
458	}
(gdb) 
distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:154
154			if (needsDistributedPlanning)
(gdb) 
156				uint64 planId = NextPlanId++;
(gdb) 
158				result = CreateDistributedPlannedStmt(planId, result, originalQuery, parse,
(gdb) 

Breakpoint 5, CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:580
580		DistributedPlan *distributedPlan = NULL;
(gdb) 
581		MultiTreeRoot *logicalPlan = NULL;
(gdb) 
582		List *subPlanList = NIL;
(gdb) 
583		bool hasCtes = originalQuery->cteList != NIL;
(gdb) 
585		if (IsModifyCommand(originalQuery))
(gdb) 
636			distributedPlan = CreateRouterPlan(originalQuery, query,
(gdb) 

Breakpoint 6, CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:171
171		if (MultiRouterPlannableQuery(query,
(gdb) 
174			return CreateSingleTaskRouterPlan(originalQuery, query,
(gdb) 

Breakpoint 7, CreateSingleTaskRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:251
251		Job *job = NULL;
(gdb) 
252		DistributedPlan *distributedPlan = CitusMakeNode(DistributedPlan);
(gdb) 
254		distributedPlan->operation = query->commandType;
(gdb) 
257		distributedPlan->planningError = ErrorIfQueryHasModifyingCTE(query);
(gdb) 
258		if (distributedPlan->planningError)
(gdb) 
264		job = RouterJob(originalQuery, plannerRestrictionContext,
(gdb) 
267		if (distributedPlan->planningError)
(gdb) p distributedPlan
$1 = (DistributedPlan *) 0x1832b28
(gdb) p* distributedPlan
$2 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d0448 "DistributedPlan"}, citus_tag = T_DistributedPlan}, planId = 0, operation = CMD_SELECT, 
  hasReturning = 0 '\000', workerJob = 0x0, masterQuery = 0x0, routerExecutable = 0 '\000', queryId = 0, relationIdList = 0x0, insertSelectSubquery = 0x0, insertTargetList = 0x0, 
  targetRelationId = 0, intermediateResultIdPrefix = 0x0, subPlanList = 0x0, planningError = 0x183b0f8}
(gdb) n
270			return NULL;
(gdb) 
281	}
(gdb) 
CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:183
183	}
(gdb) 
CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:638
638			if (distributedPlan != NULL)
(gdb) 
656		if (hasUnresolvedParams)
(gdb) 
670		boundParams = copyParamList(boundParams);
(gdb) 
678		originalQuery = (Query *) ResolveExternalParams((Node *) originalQuery,
(gdb) 
685		subPlanList = GenerateSubplansForSubqueriesAndCTEs(planId, originalQuery,
(gdb) p *originalQuery
$3 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x1830808, jointree = 0x1830e60, targetList = 0x1830ef8, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 57}
(gdb) s
GenerateSubplansForSubqueriesAndCTEs (planId=1, originalQuery=0x17a4f58, plannerRestrictionContext=0x1831148) at planner/recursive_planning.c:179
179		DeferredErrorMessage *error = NULL;
(gdb) n
185		context.level = 0;
(gdb) 
186		context.planId = planId;
(gdb) 
187		context.subPlanList = NIL;
(gdb) 
188		context.plannerRestrictionContext = plannerRestrictionContext;
(gdb) 
203			AllDistributionKeysInQueryAreEqual(originalQuery, plannerRestrictionContext);
(gdb) 
202		context.allDistributionKeysInQueryAreEqual =
(gdb) 
205		error = RecursivelyPlanSubqueriesAndCTEs(originalQuery, &context);
(gdb) 
206		if (error != NULL)
(gdb) 
211		if (context.subPlanList && (log_min_messages <= DEBUG1 || client_min_messages <=
(gdb) 
222		return context.subPlanList;
(gdb) p * context.subPlanList
Cannot access memory at address 0x0
(gdb) p  context.subPlanList
$4 = (List *) 0x0
(gdb) n
223	}
(gdb) 
CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:701
701		if (list_length(subPlanList) > 0 || hasCtes)
(gdb) 
744		if (IsModifyCommand(originalQuery))
(gdb) 
754		query->cteList = NIL;
(gdb) 
757		logicalPlan = MultiLogicalPlanCreate(originalQuery, query,
(gdb) s
MultiLogicalPlanCreate (originalQuery=0x17a4f58, queryTree=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_logical_planner.c:131
131		MultiNode *multiQueryNode = NULL;
(gdb) n
132		MultiTreeRoot *rootNode = NULL;
(gdb) 
134		if (ShouldUseSubqueryPushDown(originalQuery, queryTree))
(gdb) 
Socket error Event: 32 Error: 10053.
Connection closing...Socket close.

Connection closed by foreign host.

Disconnected from remote host(citus1) at 18:08:15.

Type `help' to learn how to use Xshell prompt.
[c:\~]$ 

Connecting to 192.168.221.130:22...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.

Last login: Sat Mar 16 03:02:15 2019 from 192.168.221.1
[cituscluster@gtm1 ~]$ p s-ef | grep gdb
bash: p: command not found...
[cituscluster@gtm1 ~]$ ps -ef | grep gdb
cituscl+  30740  30538  0 03:04 pts/3    00:00:02 gdb attach 30713
cituscl+  31150  31050  0 03:09 pts/2    00:00:00 grep --color=auto gdb
[cituscluster@gtm1 ~]$ kill -9 30740
[cituscluster@gtm1 ~]$ ps -ef | grep gdb
cituscl+  31185  31050  0 03:10 pts/2    00:00:00 grep --color=auto gdb
[cituscluster@gtm1 ~]$ 
[cituscluster@gtm1 ~]$ 
[cituscluster@gtm1 ~]$ 
[cituscluster@gtm1 ~]$ gdb attach 31207
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
attach: No such file or directory.
Attaching to process 31207
Reading symbols from /opt/pgsql-10.1/bin/postgres...done.
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
done.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Loaded symbols for /lib64/libpthread.so.0
Reading symbols from /lib64/librt.so.1...Reading symbols from /usr/lib/debug/usr/lib64/librt-2.17.so.debug...done.
done.
Loaded symbols for /lib64/librt.so.1
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libdl.so.2
Reading symbols from /lib64/libm.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libm-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.17.so.debug...done.
done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Reading symbols from /opt/pgsql-10.1/lib/citus.so...done.
Loaded symbols for /opt/pgsql-10.1/lib/citus.so
Reading symbols from /opt/pgsql-10.1/lib/libpq.so.5...done.
Loaded symbols for /opt/pgsql-10.1/lib/libpq.so.5
Reading symbols from /lib64/libnss_files.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_files-2.17.so.debug...done.
done.
Loaded symbols for /lib64/libnss_files.so.2
0x00007f274fc22163 in __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:81
81	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
(gdb) b pg_plan_queries
Breakpoint 1 at 0x813679: file postgres.c, line 842.
(gdb) b pg_plan_query
Breakpoint 2 at 0x8135e2: file postgres.c, line 784.
(gdb) b distributed_planner
Breakpoint 3 at 0x7f274935a96d: file planner/distributed_planner.c, line 94.
(gdb) 
Note: breakpoint 3 also set at pc 0x7f274935a96d.
Breakpoint 4 at 0x7f274935a96d: file planner/distributed_planner.c, line 94.
(gdb) b CreateDistributedPlan
Breakpoint 5 at 0x7f274935b1c7: file planner/distributed_planner.c, line 580.
(gdb) b CreateRouterPlan
Breakpoint 6 at 0x7f2749375bf9: file planner/multi_router_planner.c, line 171.
(gdb) b CreateSingleTaskRouterPlan
Breakpoint 7 at 0x7f2749375ded: file planner/multi_router_planner.c, line 251.
(gdb) 
Note: breakpoint 7 also set at pc 0x7f2749375ded.
Breakpoint 8 at 0x7f2749375ded: file planner/multi_router_planner.c, line 251.
(gdb) b PrepareMasterJobDirectory
Breakpoint 9 at 0x7f274934653b: file executor/multi_real_time_executor.c, line 1069.
(gdb) b ExecuteSubPlans
Breakpoint 10 at 0x7f274934d56e: file executor/subplan_execution.c, line 35.
(gdb) b PortalStart
Breakpoint 11 at 0x818eac: file pquery.c, line 461.
(gdb) b PortalRun
Breakpoint 12 at 0x819407: file pquery.c, line 707.
(gdb) b MultiRealTimeExecute
Breakpoint 13 at 0x7f2749344c5f: file executor/multi_real_time_executor.c, line 88.
(gdb) 
Note: breakpoint 13 also set at pc 0x7f2749344c5f.
Breakpoint 14 at 0x7f2749344c5f: file executor/multi_real_time_executor.c, line 88.
(gdb) n
epoll_wait () at ../sysdeps/unix/syscall-template.S:83
83	T_PSEUDO_END (SYSCALL_SYMBOL)
(gdb) 
WaitEventSetWaitBlock (set=0x16f8728, cur_timeout=-1, occurred_events=0x7ffe485cf350, nevents=1) at latch.c:1052
1052		if (rc < 0)
(gdb) 
1055			if (errno != EINTR)
(gdb) 
1062			return 0;
(gdb) 
1151	}
(gdb) 
WaitEventSetWait (set=0x16f8728, timeout=-1, occurred_events=0x7ffe485cf350, nevents=1, wait_event_info=100663296) at latch.c:1003
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
982			if (set->latch && set->latch->is_set)
(gdb) 
1000			rc = WaitEventSetWaitBlock(set, cur_timeout,
(gdb) 
1003			if (rc == -1)
(gdb) 
1006				returned_events = rc;
(gdb) 
1009			if (returned_events == 0 && timeout >= 0)
(gdb) 
951		while (returned_events == 0)
(gdb) 
1019		waiting = false;
(gdb) 
1022		pgstat_report_wait_end();
(gdb) 
1024		return returned_events;
(gdb) 
1025	}
(gdb) 
secure_read (port=0x173b3d0, ptr=0xe182c0 <PqRecvBuffer>, len=8192) at be-secure.c:186
186			if (event.events & WL_POSTMASTER_DEATH)
(gdb) 
192			if (event.events & WL_LATCH_SET)
(gdb) 
203			goto retry;
(gdb) 
153			n = secure_raw_read(port, ptr, len);
(gdb) 
154			waitfor = WL_SOCKET_READABLE;
(gdb) 
158		if (n < 0 && !port->noblock && (errno == EWOULDBLOCK || errno == EAGAIN))
(gdb) 
211		ProcessClientReadInterrupt(false);
(gdb) 
213		return n;
(gdb) 
214	}
(gdb) 
pq_recvbuf () at pqcomm.c:966
966			if (r < 0)
(gdb) 
981			if (r == 0)
(gdb) 
990			PqRecvLength += r;
(gdb) 
991			return 0;
(gdb) 
993	}
(gdb) 
pq_getbyte () at pqcomm.c:1004
1004		while (PqRecvPointer >= PqRecvLength)
(gdb) 
1009		return (unsigned char) PqRecvBuffer[PqRecvPointer++];
(gdb) 
1010	}
(gdb) 
SocketBackend (inBuf=0x7ffe485cf560) at postgres.c:330
330		if (qtype == EOF)			/* frontend disconnected */
(gdb) 
359		switch (qtype)
(gdb) 
362				doing_extended_query_message = false;
(gdb) 
363				if (PG_PROTOCOL_MAJOR(FrontendProtocol) < 3)
(gdb) 
387				break;
(gdb) 
476		if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)
(gdb) 
478			if (pq_getmessage(inBuf, 0))
(gdb) 
483		RESUME_CANCEL_INTERRUPTS();
(gdb) 
485		return qtype;
(gdb) 
486	}
(gdb) 
ReadCommand (inBuf=0x7ffe485cf560) at postgres.c:504
504		return result;
(gdb) 
505	}
(gdb) 
PostgresMain (argc=1, argv=0x1742ca8, dbname=0x1742b88 "postgres", username=0x1742b68 "cituscluster") at postgres.c:4041
4041			CHECK_FOR_INTERRUPTS();
(gdb) 
4042			DoingCommandRead = false;
(gdb) 
4047			if (disable_idle_in_transaction_timeout)
(gdb) 
4057			if (ConfigReloadPending)
(gdb) 
4067			if (ignore_till_sync && firstchar != EOF)
(gdb) 
4070			switch (firstchar)
(gdb) 
4077						SetCurrentStatementStartTimestamp();
(gdb) 
4079						query_string = pq_getmsgstring(&input_message);
(gdb) 
4080						pq_getmsgend(&input_message);
(gdb) 
4082						if (am_walsender)
(gdb) 
4088							exec_simple_query(query_string);
(gdb) 

Breakpoint 1, pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:842
842		List	   *stmt_list = NIL;
(gdb) 
845		foreach(query_list, querytrees)
(gdb) 
847			Query	   *query = lfirst_node(Query, query_list);
(gdb) 
850			if (query->commandType == CMD_UTILITY)
(gdb) 
862				stmt = pg_plan_query(query, cursorOptions, boundParams);
(gdb) 

Breakpoint 2, pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:784
784		if (querytree->commandType == CMD_UTILITY)
(gdb) 
792		if (log_planner_stats)
(gdb) 
796		plan = planner(querytree, cursorOptions, boundParams);
(gdb) 

Breakpoint 3, distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:94
94		PlannedStmt *result = NULL;
(gdb) 
95		bool needsDistributedPlanning = NeedsDistributedPlanning(parse);
(gdb) 
96		Query *originalQuery = NULL;
(gdb) 
97		PlannerRestrictionContext *plannerRestrictionContext = NULL;
(gdb) 
98		bool setPartitionedTablesInherited = false;
(gdb) 
100		if (cursorOptions & CURSOR_OPT_FORCE_DISTRIBUTED)
(gdb) 
105		if (needsDistributedPlanning)
(gdb) 
113			if (InsertSelectIntoLocalTable(parse))
(gdb) 
129			AssignRTEIdentities(parse);
(gdb) 
130			originalQuery = copyObject(parse);
(gdb) 
132			setPartitionedTablesInherited = false;
(gdb) 
133			AdjustPartitioningForDistributedPlanning(parse, setPartitionedTablesInherited);
(gdb) 
140		ReplaceTableVisibleFunction((Node *) parse);
(gdb) 
143		plannerRestrictionContext = CreateAndPushPlannerRestrictionContext();
(gdb) 
145		PG_TRY();
(gdb) 
152			result = standard_planner(parse, cursorOptions, boundParams);
(gdb) 
154			if (needsDistributedPlanning)
(gdb) 
156				uint64 planId = NextPlanId++;
(gdb) 
158				result = CreateDistributedPlannedStmt(planId, result, originalQuery, parse,
(gdb) 

Breakpoint 5, CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:580
580		DistributedPlan *distributedPlan = NULL;
(gdb) 
581		MultiTreeRoot *logicalPlan = NULL;
(gdb) 
582		List *subPlanList = NIL;
(gdb) 
583		bool hasCtes = originalQuery->cteList != NIL;
(gdb) 
585		if (IsModifyCommand(originalQuery))
(gdb) 
636			distributedPlan = CreateRouterPlan(originalQuery, query,
(gdb) 

Breakpoint 6, CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:171
171		if (MultiRouterPlannableQuery(query,
(gdb) 
174			return CreateSingleTaskRouterPlan(originalQuery, query,
(gdb) 

Breakpoint 7, CreateSingleTaskRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:251
251		Job *job = NULL;
(gdb) 
252		DistributedPlan *distributedPlan = CitusMakeNode(DistributedPlan);
(gdb) 
254		distributedPlan->operation = query->commandType;
(gdb) 
257		distributedPlan->planningError = ErrorIfQueryHasModifyingCTE(query);
(gdb) 
258		if (distributedPlan->planningError)
(gdb) 
264		job = RouterJob(originalQuery, plannerRestrictionContext,
(gdb) 
267		if (distributedPlan->planningError)
(gdb) 
270			return NULL;
(gdb) 
281	}
(gdb) 
CreateRouterPlan (originalQuery=0x17a4f58, query=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_router_planner.c:183
183	}
(gdb) 
CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:638
638			if (distributedPlan != NULL)
(gdb) 
656		if (hasUnresolvedParams)
(gdb) 
670		boundParams = copyParamList(boundParams);
(gdb) 
678		originalQuery = (Query *) ResolveExternalParams((Node *) originalQuery,
(gdb) 
685		subPlanList = GenerateSubplansForSubqueriesAndCTEs(planId, originalQuery,
(gdb) 
701		if (list_length(subPlanList) > 0 || hasCtes)
(gdb) n
744		if (IsModifyCommand(originalQuery))
(gdb) p subPlanList
$1 = (List *) 0x0
(gdb) n
754		query->cteList = NIL;
(gdb) 
757		logicalPlan = MultiLogicalPlanCreate(originalQuery, query,
(gdb) s
MultiLogicalPlanCreate (originalQuery=0x17a4f58, queryTree=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_logical_planner.c:131
131		MultiNode *multiQueryNode = NULL;
(gdb) n
132		MultiTreeRoot *rootNode = NULL;
(gdb) 
134		if (ShouldUseSubqueryPushDown(originalQuery, queryTree))
(gdb) 
141			multiQueryNode = MultiNodeTree(queryTree);
(gdb) list
136			multiQueryNode = SubqueryMultiNodeTree(originalQuery, queryTree,
137												   plannerRestrictionContext);
138		}
139		else
140		{
141			multiQueryNode = MultiNodeTree(queryTree);
142		}
143	
144		/* add a root node to serve as the permanent handle to the tree */
145		rootNode = CitusMakeNode(MultiTreeRoot);
(gdb) s
MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:627
627		List *rangeTableList = queryTree->rtable;
(gdb) n
628		List *targetEntryList = queryTree->targetList;
(gdb) 
629		List *whereClauseList = NIL;
(gdb) 
630		List *joinClauseList = NIL;
(gdb) p *targetEntryList
$2 = {type = T_List, length = 2, head = 0x1831b48, tail = 0x1831c38}
(gdb) p *rangeTableList
$3 = {type = T_List, length = 2, head = 0x179f8c8, tail = 0x1831230}
(gdb) n
631		List *joinOrderList = NIL;
(gdb) 
632		List *tableEntryList = NIL;
(gdb) 
633		List *tableNodeList = NIL;
(gdb) 
634		List *collectTableList = NIL;
(gdb) 
635		List *subqueryEntryList = NIL;
(gdb) 
636		MultiNode *joinTreeNode = NULL;
(gdb) 
637		MultiSelect *selectNode = NULL;
(gdb) 
638		MultiProject *projectNode = NULL;
(gdb) 
639		MultiExtendedOp *extendedOpNode = NULL;
(gdb) 
640		MultiNode *currentTopNode = NULL;
(gdb) 
641		DeferredErrorMessage *unsupportedQueryError = NULL;
(gdb) 
644		unsupportedQueryError = DeferErrorIfQueryNotSupported(queryTree);
(gdb) 
645		if (unsupportedQueryError != NULL)
(gdb) 
651		whereClauseList = WhereClauseList(queryTree->jointree);
(gdb) 
652		unsupportedQueryError = DeferErrorIfUnsupportedClause(whereClauseList);
(gdb) p *whereClauseList
$4 = {type = T_List, length = 1, head = 0x183b5f0, tail = 0x183b5f0}
(gdb) n
653		if (unsupportedQueryError)
(gdb) 
662		subqueryEntryList = SubqueryEntryList(queryTree);
(gdb) s
SubqueryEntryList (queryTree=0x17a49b8) at planner/multi_logical_planner.c:574
574		List *rangeTableList = queryTree->rtable;
(gdb) n
575		List *subqueryEntryList = NIL;
(gdb) 
576		List *joinTreeTableIndexList = NIL;
(gdb) 
577		ListCell *joinTreeTableIndexCell = NULL;
(gdb) 
584		ExtractRangeTableIndexWalker((Node *) queryTree->jointree, &joinTreeTableIndexList);
(gdb) 
585		foreach(joinTreeTableIndexCell, joinTreeTableIndexList)
(gdb) 
591			int joinTreeTableIndex = lfirst_int(joinTreeTableIndexCell);
(gdb) 
592			int rangeTableListIndex = joinTreeTableIndex - 1;
(gdb) 
593			RangeTblEntry *rangeTableEntry =
(gdb) 
596			if (rangeTableEntry->rtekind == RTE_SUBQUERY)
(gdb) p *rangeTableEntry
$5 = {type = T_RangeTblEntry, rtekind = RTE_RELATION, relid = 41849, relkind = 114 'r', tablesample = 0x0, subquery = 0x0, security_barrier = 0 '\000', jointype = JOIN_INNER, 
  joinaliasvars = 0x0, functions = 0x0, funcordinality = 0 '\000', tablefunc = 0x0, values_lists = 0x1831270, ctename = 0x0, ctelevelsup = 0, self_reference = 0 '\000', coltypes = 0x0, 
  coltypmods = 0x0, colcollations = 0x0, enrname = 0x0, enrtuples = 0, alias = 0x0, eref = 0x18312a0, lateral = 0 '\000', inh = 0 '\000', inFromCl = 1 '\001', requiredPerms = 2, 
  checkAsUser = 0, selectedCols = 0x18313c8, insertedCols = 0x0, updatedCols = 0x0, securityQuals = 0x0}
(gdb) n
585		foreach(joinTreeTableIndexCell, joinTreeTableIndexList)
(gdb) 
602		return subqueryEntryList;
(gdb) 
603	}
(gdb) 
MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:663
663		if (subqueryEntryList != NIL)
(gdb) 
720			bool hasOuterJoin = false;
(gdb) list
715	
716			currentTopNode = (MultiNode *) subqueryCollectNode;
717		}
718		else
719		{
720			bool hasOuterJoin = false;
721	
722			/*
723			 * We calculate the join order using the list of tables in the query and
724			 * the join clauses between them. Note that this function owns the table
(gdb) p *subqueryEntryList
Cannot access memory at address 0x0
(gdb) n
728			joinClauseList = JoinClauseList(whereClauseList);
(gdb) 
729			tableEntryList = UsedTableEntryList(queryTree);
(gdb) n
732			tableNodeList = MultiTableNodeList(tableEntryList, rangeTableList);
(gdb) n
735			collectTableList = AddMultiCollectNodes(tableNodeList);
(gdb) p *joinClauseList
Cannot access memory at address 0x0
(gdb) p *tableEntryList
$6 = {type = T_List, length = 1, head = 0x183b898, tail = 0x183b898}
(gdb) p 
$7 = {type = T_List, length = 1, head = 0x183b898, tail = 0x183b898}
(gdb) p *tableNodeList
$8 = {type = T_List, length = 1, head = 0x183b9c8, tail = 0x183b9c8}
(gdb) n
737			hasOuterJoin = HasOuterJoin(queryTree);
(gdb) p *tableNodeList->head
$9 = {data = {ptr_value = 0x183b938, int_value = 25409848, oid_value = 25409848}, next = 0x0}
(gdb) p *tableNodeList->head->data->ptr_value
Attempt to dereference a generic pointer.
(gdb) p tableNodeList->head->data->ptr_value
$10 = (void *) 0x183b938
(gdb) p tableEntryList->head->data->ptr_value
$11 = (void *) 0x183b880
(gdb) p *collectTableList
$12 = {type = T_List, length = 1, head = 0x183ba68, tail = 0x183ba68}
(gdb) p *(MultiTable*)collectTableList->head
$13 = {unaryNode = {node = {type = {extensible = {type = 25410072, extnodename = 0x0}, citus_tag = 32}, parentNode = 0x16f6dc8}, childNode = 0x1000000d9}, relationId = 25410152, 
  rangeTableId = 0, partitionColumn = 0x183ba68, alias = 0x0, referenceNames = 0x0, subquery = 0x0}
(gdb) n
738			if (hasOuterJoin)
(gdb) 
746				joinOrderList = JoinOrderList(tableEntryList, joinClauseList);
(gdb) p hasOuterJoin
$14 = 0 '\000'
(gdb) s
JoinOrderList (tableEntryList=0x183b8b8, joinClauseList=0x0) at planner/multi_join_order.c:397
397		List *bestJoinOrder = NIL;
(gdb) n
398		List *candidateJoinOrderList = NIL;
(gdb) 
399		ListCell *tableEntryCell = NULL;
(gdb) 
401		foreach(tableEntryCell, tableEntryList)
(gdb) 
403			TableEntry *startingTable = (TableEntry *) lfirst(tableEntryCell);
(gdb) 
404			List *candidateJoinOrder = NIL;
(gdb) p *startingTable
$15 = {relationId = 41849, rangeTableId = 2}
(gdb) n
407			candidateJoinOrder = JoinOrderForTable(startingTable, tableEntryList,
(gdb) 
410			candidateJoinOrderList = lappend(candidateJoinOrderList, candidateJoinOrder);
(gdb) n
401		foreach(tableEntryCell, tableEntryList)
(gdb) 
413		bestJoinOrder = BestJoinOrder(candidateJoinOrderList);
(gdb) 
416		if (LogMultiJoinOrder)
(gdb) p bestJoinOrder
$16 = (List *) 0x183bb78
(gdb) n
421		return bestJoinOrder;
(gdb) 
422	}
(gdb) 
MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:750
750			joinTreeNode = MultiJoinTree(joinOrderList, collectTableList, joinClauseList);
(gdb) s
MultiJoinTree (joinOrderList=0x183bb78, collectTableList=0x183ba88, joinWhereClauseList=0x0) at planner/multi_logical_planner.c:1704
1704		MultiNode *currentTopNode = NULL;
(gdb) n
1705		ListCell *joinOrderCell = NULL;
(gdb) 
1706		bool firstJoinNode = true;
(gdb) 
1708		foreach(joinOrderCell, joinOrderList)
(gdb) 
1710			JoinOrderNode *joinOrderNode = (JoinOrderNode *) lfirst(joinOrderCell);
(gdb) bt
#0  MultiJoinTree (joinOrderList=0x183bb78, collectTableList=0x183ba88, joinWhereClauseList=0x0) at planner/multi_logical_planner.c:1710
#1  0x00007f27493697d8 in MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:750
#2  0x00007f2749368afd in MultiLogicalPlanCreate (originalQuery=0x17a4f58, queryTree=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_logical_planner.c:141
#3  0x00007f274935b43d in CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:757
#4  0x00007f274935b07f in CreateDistributedPlannedStmt (planId=1, localPlan=0x18324e0, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:498
#5  0x00007f274935ab2e in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:158
#6  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#7  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#8  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#9  0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#10 0x0000000000817b1f in PostgresMain (argc=1, argv=0x1742ca8, dbname=0x1742b88 "postgres", username=0x1742b68 "cituscluster") at postgres.c:4088
#11 0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#12 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#13 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#14 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#15 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
1711			uint32 joinTableId = joinOrderNode->tableEntry->rangeTableId;
(gdb) 
1712			MultiCollect *collectNode = CollectNodeForTable(collectTableList, joinTableId);
(gdb) 
1714			if (firstJoinNode)
(gdb) p *collectNode
$17 = {unaryNode = {node = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d03d5 "MultiCollect"}, citus_tag = T_MultiCollect}, parentNode = 0x0}, 
    childNode = 0x183b938}}
(gdb) n
1716				currentTopNode = (MultiNode *) collectNode;
(gdb) p firstJoinNode
$18 = 1 '\001'
(gdb) n
1717				firstJoinNode = false;
(gdb) 
1708		foreach(joinOrderCell, joinOrderList)
(gdb) 
1741		return currentTopNode;
(gdb) n
1742	}
(gdb) 
MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:752
752			currentTopNode = joinTreeNode;
(gdb) 
758		selectNode = MultiSelectNode(whereClauseList);
(gdb) s
MultiSelectNode (whereClauseList=0x183b5c0) at planner/multi_logical_planner.c:1784
1784		List *selectClauseList = NIL;
(gdb) n
1785		MultiSelect *selectNode = NULL;
(gdb) 
1787		ListCell *whereClauseCell = NULL;
(gdb) 
1788		foreach(whereClauseCell, whereClauseList)
(gdb) 
1790			Node *whereClause = (Node *) lfirst(whereClauseCell);
(gdb) 
1791			if (IsSelectClause(whereClause) || or_clause(whereClause))
(gdb) p whereClause->type
$19 = T_OpExpr
(gdb) n
1793				selectClauseList = lappend(selectClauseList, whereClause);
(gdb) 
1788		foreach(whereClauseCell, whereClauseList)
(gdb) 
1797		if (list_length(selectClauseList) > 0)
(gdb) 
1799			selectNode = CitusMakeNode(MultiSelect);
(gdb) 
1800			selectNode->selectClauseList = selectClauseList;
(gdb) 
1803		return selectNode;
(gdb) p selectNode
$20 = (MultiSelect *) 0x183bfb8
(gdb) *p selectNode
Undefined command: "".  Try "help".
(gdb) p* selectNode
$21 = {unaryNode = {node = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d03e2 "MultiSelect"}, citus_tag = T_MultiSelect}, parentNode = 0x0}, childNode = 0x0}, 
  selectClauseList = 0x183bf88}
(gdb) n
1804	}
(gdb) 
MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:759
759		if (selectNode != NULL)
(gdb) 
761			SetChild((MultiUnaryNode *) selectNode, currentTopNode);
(gdb) 
762			currentTopNode = (MultiNode *) selectNode;
(gdb) 
766		projectNode = MultiProjectNode(targetEntryList);
(gdb) s
MultiProjectNode (targetEntryList=0x1831b68) at planner/multi_logical_planner.c:1855
1855		MultiProject *projectNode = NULL;
(gdb) n
1856		List *uniqueColumnList = NIL;
(gdb) 
1857		List *columnList = NIL;
(gdb) 
1858		ListCell *columnCell = NULL;
(gdb) 
1861		columnList = pull_var_clause_default((Node *) targetEntryList);
(gdb) 
1862		foreach(columnCell, columnList)
(gdb) 
1864			Var *column = (Var *) lfirst(columnCell);
(gdb) 
1866			uniqueColumnList = list_append_unique(uniqueColumnList, column);
(gdb) p *column
$22 = {xpr = {type = T_Var}, varno = 2, varattno = 1, vartype = 23, vartypmod = -1, varcollid = 0, varlevelsup = 0, varnoold = 2, varoattno = 1, location = 22}
(gdb) n
1862		foreach(columnCell, columnList)
(gdb) 
1864			Var *column = (Var *) lfirst(columnCell);
(gdb) 
1866			uniqueColumnList = list_append_unique(uniqueColumnList, column);
(gdb) p *column
$23 = {xpr = {type = T_Var}, varno = 2, varattno = 2, vartype = 23, vartypmod = -1, varcollid = 0, varlevelsup = 0, varnoold = 2, varoattno = 2, location = 22}
(gdb) n
1862		foreach(columnCell, columnList)
(gdb) 
1870		projectNode = CitusMakeNode(MultiProject);
(gdb) 
1871		projectNode->columnList = uniqueColumnList;
(gdb) 
1873		return projectNode;
(gdb) 
1874	}
(gdb) 
MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:767
767		SetChild((MultiUnaryNode *) projectNode, currentTopNode);
(gdb) 
768		currentTopNode = (MultiNode *) projectNode;
(gdb) 
776		extendedOpNode = MultiExtendedOpNode(queryTree);
(gdb) s
MultiExtendedOpNode (queryTree=0x17a49b8) at planner/multi_logical_planner.c:1881
1881		MultiExtendedOp *extendedOpNode = CitusMakeNode(MultiExtendedOp);
(gdb) n
1882		extendedOpNode->targetList = queryTree->targetList;
(gdb) 
1883		extendedOpNode->groupClauseList = queryTree->groupClause;
(gdb) 
1884		extendedOpNode->sortClauseList = queryTree->sortClause;
(gdb) 
1885		extendedOpNode->limitCount = queryTree->limitCount;
(gdb) 
1886		extendedOpNode->limitOffset = queryTree->limitOffset;
(gdb) 
1887		extendedOpNode->havingQual = queryTree->havingQual;
(gdb) 
1888		extendedOpNode->distinctClause = queryTree->distinctClause;
(gdb) 
1889		extendedOpNode->hasDistinctOn = queryTree->hasDistinctOn;
(gdb) 
1890		extendedOpNode->hasWindowFuncs = queryTree->hasWindowFuncs;
(gdb) 
1891		extendedOpNode->windowClause = queryTree->windowClause;
(gdb) 
1893		return extendedOpNode;
(gdb) 
1894	}
(gdb) 
MultiNodeTree (queryTree=0x17a49b8) at planner/multi_logical_planner.c:777
777		SetChild((MultiUnaryNode *) extendedOpNode, currentTopNode);
(gdb) 
778		currentTopNode = (MultiNode *) extendedOpNode;
(gdb) 
780		return currentTopNode;
(gdb) 
781	}
(gdb) 
MultiLogicalPlanCreate (originalQuery=0x17a4f58, queryTree=0x17a49b8, plannerRestrictionContext=0x1831148) at planner/multi_logical_planner.c:145
145		rootNode = CitusMakeNode(MultiTreeRoot);
(gdb) 
146		SetChild((MultiUnaryNode *) rootNode, multiQueryNode);
(gdb) 
148		return rootNode;
(gdb) 
149	}
(gdb) 
CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:759
759		MultiLogicalPlanOptimize(logicalPlan);
(gdb) s
MultiLogicalPlanOptimize (multiLogicalPlan=0x183c1c8) at planner/multi_logical_optimizer.c:309
309		bool hasOrderByHllType = false;
(gdb) n
310		List *selectNodeList = NIL;
(gdb) 
311		List *projectNodeList = NIL;
(gdb) 
312		List *collectNodeList = NIL;
(gdb) 
313		List *extendedOpNodeList = NIL;
(gdb) 
314		List *tableNodeList = NIL;
(gdb) 
315		ListCell *collectNodeCell = NULL;
(gdb) 
316		ListCell *tableNodeCell = NULL;
(gdb) 
317		MultiProject *projectNode = NULL;
(gdb) 
318		MultiExtendedOp *extendedOpNode = NULL;
(gdb) 
319		MultiExtendedOp *masterExtendedOpNode = NULL;
(gdb) 
320		MultiExtendedOp *workerExtendedOpNode = NULL;
(gdb) 
322		MultiNode *logicalPlanNode = (MultiNode *) multiLogicalPlan;
(gdb) 
325		ErrorIfContainsUnsupportedAggregate(logicalPlanNode);
(gdb) 
333		selectNodeList = FindNodesOfType(logicalPlanNode, T_MultiSelect);
(gdb) 
334		if (selectNodeList != NIL)
(gdb) 
336			MultiSelect *selectNode = (MultiSelect *) linitial(selectNodeList);
(gdb) 
337			MultiSelect *andSelectNode = AndSelectNode(selectNode);
(gdb) p *selectNode
$24 = {unaryNode = {node = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d03e2 "MultiSelect"}, citus_tag = T_MultiSelect}, parentNode = 0x183c0e8}, 
    childNode = 0x183ba18}, selectClauseList = 0x183bf88}
(gdb) n
338			MultiSelect *orSelectNode = OrSelectNode(selectNode);
(gdb) 
340			if (andSelectNode != NULL && orSelectNode != NULL)
(gdb) 
350			else if (andSelectNode != NULL && orSelectNode == NULL)
(gdb) 
352				andSelectNode = selectNode; /* no need to modify the tree */
(gdb) 
355			if (andSelectNode != NULL)
(gdb) 
357				PushDownNodeLoop((MultiUnaryNode *) andSelectNode);
(gdb) 
362		projectNodeList = FindNodesOfType(logicalPlanNode, T_MultiProject);
(gdb) 
363		projectNode = (MultiProject *) linitial(projectNodeList);
(gdb) 
364		PushDownNodeLoop((MultiUnaryNode *) projectNode);
(gdb) 
367		collectNodeList = FindNodesOfType(logicalPlanNode, T_MultiCollect);
(gdb) 
368		foreach(collectNodeCell, collectNodeList)
(gdb) 
370			MultiCollect *collectNode = (MultiCollect *) lfirst(collectNodeCell);
(gdb) 
371			PullUpCollectLoop(collectNode);
(gdb) p *collectNode
$25 = {unaryNode = {node = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d03d5 "MultiCollect"}, citus_tag = T_MultiCollect}, parentNode = 0x183c138}, 
    childNode = 0x183bfb8}}
(gdb) n
368		foreach(collectNodeCell, collectNodeList)
(gdb) 
382		extendedOpNodeList = FindNodesOfType(logicalPlanNode, T_MultiExtendedOp);
(gdb) bt
#0  MultiLogicalPlanOptimize (multiLogicalPlan=0x183c1c8) at planner/multi_logical_optimizer.c:382
#1  0x00007f274935b44d in CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:759
#2  0x00007f274935b07f in CreateDistributedPlannedStmt (planId=1, localPlan=0x18324e0, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:498
#3  0x00007f274935ab2e in distributed_planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner/distributed_planner.c:158
#4  0x00000000007428cc in planner (parse=0x17a49b8, cursorOptions=256, boundParams=0x0) at planner.c:208
#5  0x000000000081361a in pg_plan_query (querytree=0x17a49b8, cursorOptions=256, boundParams=0x0) at postgres.c:796
#6  0x000000000081373a in pg_plan_queries (querytrees=0x179fd70, cursorOptions=256, boundParams=0x0) at postgres.c:862
#7  0x00000000008139ec in exec_simple_query (query_string=0x17a3648 "select * from (select * from test2 where id >10) as temp1;") at postgres.c:1027
#8  0x0000000000817b1f in PostgresMain (argc=1, argv=0x1742ca8, dbname=0x1742b88 "postgres", username=0x1742b68 "cituscluster") at postgres.c:4088
#9  0x000000000078b2d2 in BackendRun (port=0x173b3d0) at postmaster.c:4357
#10 0x000000000078aa7b in BackendStartup (port=0x173b3d0) at postmaster.c:4029
#11 0x00000000007873e6 in ServerLoop () at postmaster.c:1753
#12 0x0000000000786a6d in PostmasterMain (argc=1, argv=0x16f6b40) at postmaster.c:1361
#13 0x00000000006cf26f in main (argc=1, argv=0x16f6b40) at main.c:228
(gdb) n
383		extendedOpNode = (MultiExtendedOp *) linitial(extendedOpNodeList);
(gdb) 
385		extendedOpNodeProperties = BuildExtendedOpNodeProperties(extendedOpNode);
(gdb) 
387		masterExtendedOpNode =
(gdb) 
389		workerExtendedOpNode =
(gdb) 
392		ApplyExtendedOpNodes(extendedOpNode, masterExtendedOpNode, workerExtendedOpNode);
(gdb) 
394		tableNodeList = FindNodesOfType(logicalPlanNode, T_MultiTable);
(gdb) 
395		foreach(tableNodeCell, tableNodeList)
(gdb) 
397			MultiTable *tableNode = (MultiTable *) lfirst(tableNodeCell);
(gdb) 
398			if (tableNode->relationId == SUBQUERY_RELATION_ID)
(gdb) p *tableNode
$26 = {unaryNode = {node = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d03ee "MultiTable"}, citus_tag = T_MultiTable}, parentNode = 0x183c0e8}, childNode = 0x0}, 
  relationId = 41849, rangeTableId = 2, partitionColumn = 0x183b8e8, alias = 0x0, referenceNames = 0x18312a0, subquery = 0x0}
(gdb) n
395		foreach(tableNodeCell, tableNodeList)
(gdb) 
411		hasOrderByHllType = HasOrderByHllType(workerExtendedOpNode->sortClauseList,
(gdb) 
413		if (hasOrderByHllType)
(gdb) 
419	}
(gdb) 
CreateDistributedPlan (planId=1, originalQuery=0x17a4f58, query=0x17a49b8, boundParams=0x0, hasUnresolvedParams=0 '\000', plannerRestrictionContext=0x1831148)
    at planner/distributed_planner.c:768
768		CheckNodeIsDumpable((Node *) logicalPlan);
(gdb) 
771		distributedPlan = CreatePhysicalDistributedPlan(logicalPlan,
(gdb) s
CreatePhysicalDistributedPlan (multiTree=0x183c1c8, plannerRestrictionContext=0x1831148) at planner/multi_physical_planner.c:210
210		DistributedPlan *distributedPlan = NULL;
(gdb) n
211		Job *workerJob = NULL;
(gdb) 
212		Query *masterQuery = NULL;
(gdb) 
213		List *masterDependedJobList = NIL;
(gdb) 
216		workerJob = BuildJobTree(multiTree);
(gdb) 
219		workerJob = BuildJobTreeTaskList(workerJob, plannerRestrictionContext);
(gdb) p workerJob
$27 = (Job *) 0x183c138
(gdb) p *workerJob
$28 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d0438 "Job"}, citus_tag = T_Job}, jobId = 523566579713, jobQuery = 0x1833f00, taskList = 0x0, 
  dependedJobList = 0x0, subqueryPushdown = 0 '\000', requiresMasterEvaluation = 0 '\000', deferredPruning = 0 '\000', partitionKeyValue = 0x0}
(gdb) s
BuildJobTreeTaskList (jobTree=0x183c138, plannerRestrictionContext=0x1831148) at planner/multi_physical_planner.c:1962
1962		List *flattenedJobList = NIL;
(gdb) n
1963		uint32 flattenedJobCount = 0;
(gdb) 
1964		int32 jobIndex = 0;
(gdb) 
1971		List *jobStack = list_make1(jobTree);
(gdb) 
1972		while (jobStack != NIL)
(gdb) 
1974			Job *job = (Job *) llast(jobStack);
(gdb) 
1975			flattenedJobList = lappend(flattenedJobList, job);
(gdb) p *job
$29 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d0438 "Job"}, citus_tag = T_Job}, jobId = 523566579713, jobQuery = 0x1833f00, taskList = 0x0, 
  dependedJobList = 0x0, subqueryPushdown = 0 '\000', requiresMasterEvaluation = 0 '\000', deferredPruning = 0 '\000', partitionKeyValue = 0x0}
(gdb) p *job->jobQuery
$30 = {type = T_Query, commandType = CMD_SELECT, querySource = QSRC_ORIGINAL, queryId = 0, canSetTag = 1 '\001', utilityStmt = 0x0, resultRelation = 0, hasAggs = 0 '\000', 
  hasWindowFuncs = 0 '\000', hasTargetSRFs = 0 '\000', hasSubLinks = 0 '\000', hasDistinctOn = 0 '\000', hasRecursive = 0 '\000', hasModifyingCTE = 0 '\000', hasForUpdate = 0 '\000', 
  hasRowSecurity = 0 '\000', cteList = 0x0, rtable = 0x183d8d0, jointree = 0x183dcc8, targetList = 0x183ce90, override = OVERRIDING_NOT_SET, onConflict = 0x0, returningList = 0x0, 
  groupClause = 0x0, groupingSets = 0x0, havingQual = 0x0, windowClause = 0x0, distinctClause = 0x0, sortClause = 0x0, limitOffset = 0x0, limitCount = 0x0, rowMarks = 0x0, 
  setOperations = 0x0, constraintDeps = 0x0, withCheckOptions = 0x0, stmt_location = 0, stmt_len = 0}
(gdb) n
1978			jobStack = list_delete_ptr(jobStack, job);
(gdb) 
1979			jobStack = list_union_ptr(jobStack, job->dependedJobList);
(gdb) p *job->dependedJobList
Cannot access memory at address 0x0
(gdb) n
1972		while (jobStack != NIL)
(gdb) 
1987		flattenedJobCount = (int32) list_length(flattenedJobList);
(gdb) n
1988		for (jobIndex = (flattenedJobCount - 1); jobIndex >= 0; jobIndex--)
(gdb) p flattenedJobCount
$31 = 1
(gdb) n
1990			Job *job = (Job *) list_nth(flattenedJobList, jobIndex);
(gdb) 
1991			List *sqlTaskList = NIL;
(gdb) 
1992			List *assignedSqlTaskList = NIL;
(gdb) 
1993			ListCell *assignedSqlTaskCell = NULL;
(gdb) 
1996			if (job->subqueryPushdown)
(gdb) 
2014				sqlTaskList = SqlTaskList(job);
(gdb) n
2017			sqlTaskList = PruneSqlTaskDependencies(sqlTaskList);
(gdb) s
PruneSqlTaskDependencies (sqlTaskList=0x1840a40) at planner/multi_physical_planner.c:4166
4166		ListCell *sqlTaskCell = NULL;
(gdb) n
4167		foreach(sqlTaskCell, sqlTaskList)
(gdb) 
4169			Task *sqlTask = (Task *) lfirst(sqlTaskCell);
(gdb) 
4170			List *dependedTaskList = sqlTask->dependedTaskList;
(gdb) p *sqlTask
$32 = {type = {extensible = {type = T_ExtensibleNode, extnodename = 0x7f27493d046b "Task"}, citus_tag = T_Task}, taskType = SQL_TASK, jobId = 523566579713, taskId = 1, 
  queryString = 0x183fb40 "SELECT id, name FROM test2_102687 test2 WHERE (id OPERATOR(pg_catalog.>) 10)", anchorShardId = 102687, taskPlacementList = 0x0, dependedTaskList = 0x0, 
  partitionId = 0, upstreamTaskId = 0, shardInterval = 0x0, assignmentConstrained = 0 '\000', taskExecution = 0x0, upsertQuery = 0 '\000', replicationModel = 105 'i', 
  relationRowLockList = 0x0, modifyWithSubquery = 0 '\000', relationShardList = 0x18409f0, rowValuesLists = 0x0}
(gdb) 
Socket error Event: 32 Error: 10053.
Connection closing...Socket close.

Connection closed by foreign host.

Disconnected from remote host(citus1) at 18:02:03.

Type `help' to learn how to use Xshell prompt.
